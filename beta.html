<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
    <title>Music</title>
    <link id="favicon" rel="icon" type="image/png" href="favicon.png">
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Material+Symbols+Rounded:opsz,wght,FILL,GRAD@24,700,1,0">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jsmediatags/3.9.5/jsmediatags.min.js"></script>
    <script src="/assets/gurapp/api/gurasuraisu-api.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>
    <style>
        :root {
            --edge-refraction-filter: url('#edge-refraction-only');
            
            /* Dark Theme (Default) Variables */
            --background-color-dark: #1c1c1c;
            --text-color-dark: #f9f9f9;
            --secondary-text-color-dark: rgba(255, 255, 255, 0.7);
            --modal-background-dark: rgba(51, 51, 51, 0.8);
            --modal-transparent-dark: rgba(51, 51, 51, 0.7);
            --search-background-dark: rgba(51, 51, 51, 0.5);
            --dark-overlay: rgba(51, 51, 51, 0.2);
            --dark-transparent: rgba(255, 255, 255, 0.1); 
            --glass-border-dark: rgba(100, 100, 100, 0.2);
            
            /* Light Theme Variables */
            --background-color-light: #f0f0f0;
            --text-color-light: #333333;
            --secondary-text-color-light: rgba(0, 0, 0, 0.7);
            --modal-background-light: rgba(220, 220, 220, 0.8);
            --modal-transparent-light: rgba(240, 240, 240, 0.7);
            --search-background-light: rgba(220, 220, 220, 0.5);
            --light-overlay: rgba(220, 220, 220, 0.2);
            --light-transparent: rgba(255, 255, 255, 0.1);
            --glass-border-light: rgba(200, 200, 200, 0.2);
            
            /* Default to Dark Theme */
            --background-color: var(--background-color-dark);
            --text-color: var(--text-color-dark);
            --secondary-text-color: var(--secondary-text-color-dark);
            --modal-background: var(--modal-background-dark);
            --modal-transparent: var(--modal-transparent-dark);
            --search-background: var(--search-background-dark);
            --overlay-color: var(--dark-overlay);
            --transparent-color: var(--dark-transparent);
            --glass-border: var(--glass-border-dark);
        }
        
        body.light-theme {
            --background-color: var(--background-color-light);
            --text-color: var(--text-color-light);
            --secondary-text-color: var(--secondary-text-color-light);
            --modal-background: var(--modal-background-light);
            --modal-transparent: var(--modal-transparent-light);
            --search-background: var(--search-background-light);
            --overlay-color: var(--light-overlay);
            --transparent-color: var(--light-transparent);
            --glass-border: var(--glass-border-light);
        }
        
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: 'Inter', sans-serif;
            -webkit-tap-highlight-color: transparent;
            cursor: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="20px" height="20px" viewBox="0 0 10.04 10.04"><circle cx="5.02" cy="5.02" r="4.52" style="fill:rgba(0,0,0,0.5);stroke:rgba(255,255,255,0.5);stroke-width:1"/></svg>') 10 10, auto !important;
        }
        
        body {
            background-color: var(--background-color);
            min-height: 100vh;
            display: flex;
            user-select: none;
            position: relative;
            overflow: hidden;
            transition: background-color 0.3s, color 0.3s, background-image 0.5s;
            color: var(--text-color);
        }

        .toolbar {
            display: flex;
            justify-content: center;
            align-content: center;
            flex-direction: row;
            gap: 10px;
            padding: 15px 20px;
            background-color: transparent;
            border: none;
            position: fixed;
            top: 0px;
            left: 50%;
            transform: translateX(-50%);
            z-index: 1000;
            transition: top 0.3s ease;
            width: 100%;
            flex-wrap: wrap;
            height: 80px;
        }

        .toolbar.hidden {
            top: -100px;
            opacity: 0;
        }

        .toolbar.hidden .album-art {
            margin-top: 0px !IMPORTANT;
        }

        .toolbar::before {
            content: "";
            position: absolute;
            inset: 0;
            z-index: -1;
        }

        .toolbar::after {
            content: "";
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: -2;
            backdrop-filter: blur(2.5px);
            mask-image: linear-gradient( to bottom, rgba(0, 0, 0, 1) 0%, rgba(0, 0, 0, 1) 90%, rgba(0, 0, 0, 0) 100% );
            -webkit-mask-image: linear-gradient( to bottom, rgba(0, 0, 0, 1) 0%, rgba(0, 0, 0, 1) 90%, rgba(0, 0, 0, 0) 100% );
        }

        .tab-btn {
            background-color: var(--search-background);
            color: var(--text-color);
            border: none;
            border-radius: 50px;
            padding: 10px 9px 10px 18px;
            font-size: 0;
            cursor: pointer;
            transition: all 0.3s cubic-bezier(.3,1.2,.64,1) !IMPORTANT;
            display: flex;
            align-items: center;
            gap: 8px;
            backdrop-filter: blur(5px) saturate(2) var(--edge-refraction-filter);
            border: 1px solid var(--glass-border);
        }

        .tab-btn.active {
            background-color: var(--secondary-text-color);
            color: var(--background-color);
            border-radius: 15px;
            font-family: 'Open Runde';
            font-weight: 500;
            padding: 10px 18px 10px 16px;
            font-size: revert;
        }

        .toolbar .tab-btn .material-symbols-rounded {
            transition: color 0.3s;
            font-size: 20px;
        }

        .toolbar .tab-btn.active .material-symbols-rounded {
            color: var(--background-color) !important;
        }

        .view-container {
            flex-grow: 1;
            width: 100%;
            padding: 80px 20px 0 20px;
            overflow-y: auto;
            overflow-x: hidden;
            min-height: 0;
        }

        .view-container::-webkit-scrollbar { width: 8px; }
        .view-container::-webkit-scrollbar-track { background: transparent; }
        .view-container::-webkit-scrollbar-thumb { background-color: var(--search-background); border-radius: 50px; }

        #now-playing-view {
            padding-top: 0;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        #bottom-miniplayer {
            position: fixed;
            bottom: 24px;
            left: 50%;
            transform: translateX(-50%);
            width: 95%;
            max-width: 528px;
            height: 64px;
            background-color: var(--search-background);
            border: 1px solid var(--glass-border);
            border-radius: 22px;
            backdrop-filter: blur(5px) saturate(2) var(--edge-refraction-filter);
            display: flex;
            align-items: center;
            padding: 8px;
            gap: 12px;
            z-index: 1001;
            cursor: pointer;
            overflow: hidden;
            transition: all 0.3s cubic-bezier(.3,1.2,.64,1);
            box-shadow: 0 0 50px rgba(0, 0, 0, 0.2);
        }
        #bottom-miniplayer:active {
            transform: translateX(-50%) scale(1.05);
            transition: all 0.1s cubic-bezier(0.2, 0, 0.38, 0.9);
            filter: brightness(1.5);
        }
        #bottom-miniplayer.hidden {
            bottom: -100px;
            opacity: 0;
            pointer-events: none;
        }
        #miniplayer-art {
            width: 48px;
            height: 48px;
            border-radius: 12px;
            box-shadow: 0 0 0 1px var(--glass-border);
            flex-shrink: 0;
        }
        .miniplayer-info {
            display: flex;
            flex-direction: column;
            gap: 2px;
            flex-grow: 1;
            min-width: 0;
            color: var(--text-color);
        }
        #miniplayer-title, #miniplayer-artist {
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }
        #miniplayer-title { font-weight: bold; font-size: 16px; font-family: 'Open Runde'; }
        #miniplayer-artist { font-size: 16px; color: var(--secondary-text-color); }

        .miniplayer-controls { display: flex; align-items: center; gap: 4px; padding-right: 8px; }
        .mini-control-btn {
            background: none;
            border: none;
            color: var(--text-color);
            width: 40px;
            height: 40px;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        .miniplayer-progress {
            position: absolute;
            bottom: 0;
            left: 3.5%;
            max-width: 93%;
            height: 2px;
            background-color: var(--secondary-text-color);
            width: 0%; /* JS will control this */
            transition: width 0.25s ease;
            border-radius: 5px;
        }

        /* Responsive miniplayer */
        #miniplayer-prev-btn, #miniplayer-next-btn { display: none; }
        @media (min-width: 500px) {
            #miniplayer-prev-btn, #miniplayer-next-btn { display: flex; }
        }

        /* Generic Grid for Home/Library/Search */
        .page-content-wrapper {
            width: 100%;
            max-width: 1400px;
            margin: 0 auto;
            display: flex;
            flex-direction: column;
            height: 0;
        }
        .item-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(160px, 1fr));
            gap: 20px;
            padding-bottom: 125px;
        }
        .item-card {
            background-color: transparent; /* Cards will be minimal */
            border-radius: 12px;
            transition: all 0.2s ease;
            cursor: pointer;
            display: flex;
            flex-direction: column;
            gap: 10px;
            cursor: pointer;
            transform: scale(1);
            transition: all 0.15s cubic-bezier(0.2, 0, 0.38, 0.9);
        }
        .item-card-art {
            width: 100%;
            aspect-ratio: 1 / 1;
            box-shadow: 0 0 0 1px var(--glass-border);
            border-radius: 12px;
            object-fit: cover;
        }
        .item-card-info { padding: 0 4px 4px 4px; }
        .item-card-title { font-weight: 500; font-family: 'Open Runde'; }
        .item-card-subtitle { font-size: 14px; color: var(--secondary-text-color); }
        .section-title {
            font-size: 1.5rem;
            font-weight: 600;
            margin-bottom: 20px;
        }
        .item-card:active {
            transform: scale(0.96);
            transition: all 0.1s cubic-bezier(0.2, 0, 0.38, 0.9);
            filter: brightness(1.5);
        }

        .library-controls {
            display: flex;
            flex-wrap: nowrap;
            gap: 10px;
            flex-direction: row;
            justify-content: center;
            align-content: center;
            position: fixed;
            left: 50%;
            transform: translateX(-50%);
            z-index: 1002;
            background-color: var(--search-background);
            backdrop-filter: blur(5px) saturate(2) var(--edge-refraction-filter);
            padding: 10px 12px;
            border-radius: 32px;
            border: 1px solid var(--glass-border);
            box-shadow: 0 0 15px rgba(0, 0, 0, 0.05);
            bottom: 100px;
        }

        @media (max-width: 630px) {
            .library-controls {
                flex-wrap: wrap;
            }
        }

        .search-container {
            position: relative;
            flex-grow: 1;
            min-width: 200px;
            margin-bottom: 10px;
        }

        .library-search-input {
            width: 100%;
            padding: 10px 15px 10px 40px;
            border-radius: 25px;
            border: 1px solid var(--glass-border);
            background: var(--search-background);
            color: var(--text-color);
            backdrop-filter: blur(5px) saturate(2) var(--edge-refraction-filter);
            font-size: 14px;
            outline: none;
        }
        
        .search-icon {
            font-size: 22px;
            position: absolute;
            left: 15px;
            top: 50%;
            transform: translateY(-50%);
            color: var(--secondary-text-color);
            pointer-events: none;
        }

        .filter-container, .view-controls, .library-actions {
            display: flex;
            gap: 10px;
        }

        .filter-container .filter-btn, .filter-container .filter-btn-sc {
            padding: 8px 16px;
            height: 42px;
            border-radius: 10px;
        }

        .filter-container .filter-btn:active, .filter-container .filter-btn-sc:active {
            transform: scale(1);
            padding: 8px 20px;
            filter: brightness(1.5);
        }

        .filter-container .filter-btn.active, .filter-container .filter-btn-sc.active {
            background: var(--secondary-text-color);
            color: var(--background-color);
            border-radius: 25px !important;
            font-family: 'Open Runde';
            font-weight: 500;
        }
        
        .filter-container .filter-btn .material-symbols-rounded, .filter-container .filter-btn-sc .material-symbols-rounded{
            font-size: 22px;
        }
        
        .action-btn {
            background-color: var(--search-background);
            color: var(--text-color);
            border: none;
            border-radius: 50px;
            padding: 8px 16px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            height: 42px;
            backdrop-filter: blur(5px) saturate(2) var(--edge-refraction-filter);
            border: 1px solid var(--glass-border);
        }

        .library-action-btn {
            background-color: transparent;
            color: var(--text-color);
            border: none;
            border-radius: 50px;
            padding: 10px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            height: 42px;
        }

        .library-action-btn.active {
            background-color: var(--secondary-text-color);
            color: var(--background-color);
        }

          @keyframes fadeInOut {
            0% { opacity: 0; transform: translate(-50%, 20px); }
            10% { opacity: 1; transform: translate(-50%, 0); }
            90% { opacity: 1; transform: translate(-50%, 0); }
            100% { opacity: 0; transform: translate(-50%, -20px); }
          }
        
        .music-list::-webkit-scrollbar,
        #lyrics-queue-panel::-webkit-scrollbar,
        .lyrics-container::-webkit-scrollbar {
            width: 4px;
        }
                
        .music-list::-webkit-scrollbar-track,
        #lyrics-queue-panel::-webkit-scrollbar-track,
        .lyrics-container::-webkit-scrollbar-track {
            background: rgba(255, 255, 255, .0);
        }
        
        .music-list::-webkit-scrollbar-thumb,
        #lyrics-queue-panel::-webkit-scrollbar-thumb,
        .lyrics-container::-webkit-scrollbar-thumb {
            background: var(--modal-transparent);
            border-radius: 4px;
        } 

        #queue-list-container {
            gap: 10px;
            display: flex;
            flex-direction: column;
        }
        
        .upload-btn {
            background-color: var(--search-background);
            color: var(--text-color);
            backdrop-filter: blur(5px) saturate(2) var(--edge-refraction-filter);
            border-radius: 25px;
            padding: 10px 16px;
            cursor: pointer;
            transition: background-color 0.2s;
            display: flex; 
            align-items: center;
            border: 1px solid var(--glass-border);
            gap: 6px;
        }
        
        .music-list {
            display: flex;
            flex-direction: column;
            gap: 10px;
            overflow-y: auto;
            flex-grow: 1;
            border-radius: 10px;
        }

        .music-item.dragging, .album-section.dragging, .queue-item.dragging {
          opacity: 0.5;
          background-color: var(--modal-background);
          box-shadow: 0 0 15px rgba(0, 0, 0, 0.3);
          position: relative;
          z-index: 1000;
          transition: transform 0.1s ease;
        }
        
        .music-item {
            padding: 12px 16px;
            background-color: var(--search-background);
            border: none;
            border-radius: 20px;
            color: var(--text-color);
            cursor: pointer;
            transition: all 0.3s ease;
            border: 1px solid var(--glass-border);
            cursor: grab;
            touch-action: pan-y;
            overflow: hidden;
            min-height: fit-content;
            position: relative;
        }

        .queue-item {
            padding: 8px 1px;
            background-color: transparent;
            border: none;
            border-radius: 0;
            color: var(--text-color);
            cursor: pointer;
            transition: all 0.3s ease;
            cursor: grab;
            touch-action: pan-y;
            overflow: hidden;
            min-height: fit-content;
            position: relative;
        }
        
        .music-item.active {
            background-color: var(--background-color) !important;
            font-weight: bold;
            border-radius: 40px;
            transition: all 0.3s ease;
        }

        .queue-item.active {
            background-color: var(--search-background) !important;
            font-weight: bold;
            border-radius: 11px;
            transition: all 0.3s ease;
            padding: 5px 1px;
            border: 1px solid var(--glass-border);
            margin: 3px 0;
        }
        
        .album-art {
            border-radius: 12px;
            background-color: var(--modal-transparent);
            display: flex;
            align-items: center;
            justify-content: center;
            overflow: hidden;
            transition: transform 0.5s ease, opacity 0.3s ease;
            max-width: 500px;
            max-height: 500px;
            aspect-ratio: 1 / 1;
            box-shadow: 0 0 15px rgba(0, 0, 0, 0.05);
            margin-top: 80px;
            outline: 1px solid var(--glass-border);
        }

        .album-art.fade-out {
            opacity: 0;
            transform: scale(0.95);
        }
        
        .album-art img {
            width: 100%;
            height: 100%;
            object-fit: cover;
            border-radius: 12px;
        }

        /* Generic Modal Styling */
        .modal-overlay {
            position: fixed;
            inset: 0;
            background-color: var(--overlay-color);
            z-index: 1000;
            display: flex;
            align-items: center;
            justify-content: center;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.3s ease;
        }

        .modal-overlay.visible {
            opacity: 1;
            pointer-events: auto;
        }
        
        .music-info {
            display: flex;
            justify-content: space-between;
            align-items: center;
            color: var(--text-color);
            text-align: left;
            max-width: 500px;
            width: 100%;
        }
        
        .music-text {
            display: flex;
            flex-direction: column;
            flex-grow: 1;
            gap: 8px;
            min-width: 0;
            padding-right: 16px;
            width: 0
        }
        
        .music-title {
            font-size: 1.3rem;
            word-wrap: break-word;
            font-weight: bold;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            line-height: 1.3;
            font-family: 'Open Runde';
        }
        
        .music-artist {
            color: var(--text-color);
            font-size: 0.9em;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            line-height: 1.3;
        }
        
        .more-button {
            background: var(--overlay-color);
            border: 1px solid var(--glass-border);
            cursor: pointer;
            color: var(--text-color);
            padding: 8px;
            border-radius: 50%;
            transition: background 0.2s ease;
            backdrop-filter: blur(5px) saturate(2) var(--edge-refraction-filter);
        }
        
        .quality-badge {
            display: inline-block;
            padding: 4px 12px;
            border-radius: 12px;
            font-size: 0.8em;
            font-weight: 500;
            margin-top: 5px;
            background: var(--search-background);
            color: var(--text-color);
        }
        
        .quality-lossless {
            background: rgba(189, 214, 255, .2);
            color: #bdd6ff;
        }
        
        .quality-enhanced {
            background: rgba(144, 238, 144, .2);
            color: #90ee90;
        }
        
        .quality-normal {
            background: rgba(255, 255, 255, .2);
            color: var(--text-color);
        }
                
        .player-controls {
            display: flex;
            align-items: center;
            justify-content: center;
            max-width: 500px;
            box-sizing: border-box;
            width: 100%;
            justify-content: space-between;
            margin-bottom: 90px;
        }
        
        .player-controls button:nth-child(2),
        .player-controls button:nth-child(3),
        .player-controls button:nth-child(4) {
            order: 1; /* Middle group gets priority */
        }
        
        .player-controls button:nth-child(1) {
            order: 0; /* Shuffle on the left */
        }
        
        .player-controls button:nth-child(5) {
            order: 2; /* Repeat on the right */
        }
                
        .control-btn {
            background: var(--search-background);
            border: none;
            color: var(--text-color);
            width: 50px;
            height: 50px;
            border-radius: 35px;
            cursor: pointer;
            font-size: 1.2rem;
            transition: background-color 0.2s;
            display: flex;
            justify-content: center;
            align-items: center;
            line-height: 0;
            backdrop-filter: blur(5px) saturate(2) var(--edge-refraction-filter);
            border: 1px solid var(--glass-border);
        }
        
        .control-btn.play-pause {
            background-color: var(--search-background);
            width: 70px;
            height: 70px;
            font-size: 1.5rem;
            transition: all 0.3s ease;
            border-radius: 35px;
            display: flex;
            justify-content: center;
            align-items: center;
            line-height: 0;
        }
        
        .control-btn.play-pause.playing {
            border-radius: 25px;
        }
        
        .progress-container {
            display: flex;
            flex-direction: column;
            gap: 12px;
            width: 100%;
            max-width: 500px;
        }
        
        .progress-bar {
            width: 100%;
            height: 8px;
            background: var(--search-background);
            border-radius: 25px;
            cursor: pointer;
            transition: all 0.25s ease;
            backdrop-filter: blur(5px) saturate(2) var(--edge-refraction-filter);
            box-shadow: 0 0 0 1px var(--glass-border);
            overflow: hidden;
        }
        
        .progress {
            height: 100%;
            background: var(--secondary-text-color);
            border-radius: 25px;
            width: 0%;
            transition: all 0.25s ease;
            border: 1px solid var(--glass-border);
        }
        
        .time-info {
            display: flex;
            justify-content: space-between;
            color: var(--text-color);
            font-variant-numeric: tabular-nums;
            font-size: 0.9rem;
        }
        
        .controls-container {
            display: flex;
            align-items: center;
            gap: 8px;
            position: fixed;
            bottom: 30px;
            z-index: 10;
        }
        
        .controls-container span {
            color: var(--text-color);
            font-size: 18px;
        }

        #visualizerCanvas {
            width: 28px;
            height: 28px;
            vertical-align: middle;
        }

        .lyrics-button, .queue-button, .more-button {
            background: var(--search-background);
            border: 1px solid var(--glass-border);
            cursor: pointer;
            width: 37px;
            height: 37px;
            color: var(--text-color);
            border-radius: 50%;
            transition: background 0.2s ease;
            backdrop-filter: blur(5px) saturate(2) var(--edge-refraction-filter);
        }

        .goto-btn {
            background: var(--search-background);
            border: 1px solid var(--glass-border);
            cursor: pointer;
            padding: 10px 16px;
            color: var(--text-color);
            border-radius: 25px;
            transition: background 0.2s ease;
            backdrop-filter: blur(5px) saturate(2) var(--edge-refraction-filter);
        }

        .lyrics-button.active, .queue-button.active {
            background: var(--modal-background);
            border-radius: 10px;
        }

        .volume-control {
            display: flex;
            align-items: center;
            gap: 10px;
            background: var(--search-background);
            border-radius: 25px;
            padding: 5px 10px 5px 10px;
            backdrop-filter: blur(5px) saturate(2) var(--edge-refraction-filter);
            border: 1px solid var(--glass-border);
            height: 37px;
            width: 100px;
        }
        
        .volume-control span {
            color: var(--text-color);
            font-size: 20px;
        }
        
        .volume-slider {
            width: 100%;
            height: 25px;
            -webkit-appearance: none;
            background: rgba(0, 0, 0, .0);
            outline: none;
        }
        
        .volume-slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 15px;
            height: 15px;
            background: var(--text-color);
            border-radius: 50%;
            cursor: pointer;
            border: 1px solid var(--glass-border);
            transition: width 0.3s, height 0.3s, transform 0.3s;
        }

        .volume-slider::-webkit-slider-thumb:active {
            width: 21px;
            height: 21px;
            transform: scale(1.1);
        }

        .volume-slider::-moz-range-thumb {
            width: 15px;
            height: 15px;
            border-radius: 50%;
            background: var(--text-color);
            cursor: pointer;
            border: 1px solid var(--glass-border);
            transition: width 0.3s, height 0.3s, transform 0.3s;
        }

        .volume-slider::-moz-range-thumb:active {
            width: 21px;
            height: 21px;
            transform: scale(1.1);
        }
        
        .album-section {
            padding: 20px 0 10px;
            border-top: 1.5px solid var(--glass-border);
        }

        .album-section::after {
          content: '';
          position: absolute;
          left: 0;
          right: 0;
          height: 2px;
          background: transparent;
          transition: background 0.3s;
        }
        
        .album-section.drag-over::after {
          background: var(--text-color);
        }
        
        .album-header {
            display: flex;
            align-items: center;
            gap: 15px;
            margin-bottom: 15px;
            cursor: grab;
            position: relative;
        }
        
        .album-thumbnail {
            width: 60px;
            height: 60px;
            border-radius: 15px;
            object-fit: cover;
            box-shadow: 0 0 0 1px var(--glass-border);
        }
        
        .album-info {
            color: var(--text-color);
        }
        
        .album-name {
            font-weight: 600;
            font-size: 1.1em;
        }
        
        .album-artist, .album-year {
            color: var(--text-color);
            font-size: 0.9em;
        }
        
        .album-songs {
            display: flex;
            flex-direction: column;
            gap: 5px;
        }
        
        .song-info {
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        .track-number {
            color: var(--secondary-text-color);
            min-width: 25px;
            text-align: center;
            font-variant-numeric: tabular-nums;
        }
        
        .album-actions {
            position: absolute;
            right: 10px;
            top: 10px;
        }
        
        .delete-album {
            background: rgba(255, 0, 0, 0.8);
            color: white;
            border: none;
            border-radius: 50%;
            width: 36px;
            height: 36px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: background 0.2s;
        }
        
        .song-title {
            flex-grow: 1;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .drag-placeholder {
          height: 2px;
          background-color: var(--text-color);
          transition: all 0.2s ease;
        }
        
        @keyframes pulse {
          0% { box-shadow: 0 0 0 0 rgba(255, 255, 255, 0.4); }
          70% { box-shadow: 0 0 0 10px rgba(255, 255, 255, 0); }
          100% { box-shadow: 0 0 0 0 rgba(255, 255, 255, 0); }
        }
        
        .music-item.dragging, .album-section.dragging, .queue-item.dragging {
          animation: pulse 1.5s infinite;
        }
        
        .background-container {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            overflow: hidden;
            z-index: -9999;
        }
                        
        #distortion-container {
            position: fixed;
            inset: 0;
            overflow: hidden;
            z-index: -9998;
            filter: blur(50px) saturate(2) brightness(0.6);
            scale: 1.3;
            opacity: 1;
        }

        body.light-theme #distortion-container {
            opacity: 0.6; /* 60% opacity for light theme */
            filter: blur(50px) saturate(2) brightness(1);
        }
        
        /* The VERY back layer: heavy blur, no distortion */
        .background-blur {
            width: 100%;
            height: 100%;
            background-size: cover;
            background-position: center;
            scale: 2;
            transition: background-image 0.5s ease;
        }

        .background-blur.rotating {
            animation: rotate 45s linear infinite;
        }

        @keyframes rotate {
            from {
                transform: scale(1.42) rotate(0deg);
            }
            to {
                transform: scale(1.42) rotate(360deg);
            }
        }
        
        /* Common style for ALL moving shards */
        .distortion-shard {
            position: absolute;
            width: 150%;
            height: 150%;
            top: -25%;
            left: -25%;
            background-size: cover;
            background-position: center;
            filter: url(#albumArtDistortion);
            will-change: transform;
            transition: background-image 0.5s ease;
            scale: 0.75;
            opacity: 0.5;
        }

        body.is-mobile .distortion-shard {
            display: none !important;
        }
        
        /* Define the unique organic shapes for each shard */
        .shape-1 {
            clip-path: polygon(0% 25%, 66% 0%, 100% 33%, 75% 100%, 25% 100%);
        }
        .shape-2 {
            clip-path: polygon(33% 0%, 100% 0%, 100% 75%, 50% 100%, 0% 50%);
        }
        .shape-3 {
            clip-path: polygon(100% 33%, 80% 80%, 30% 100%, 0% 70%, 20% 20%);
        }
        
        .search-container {
            position: relative;
        }
        
        .search-input {
            width: 100%;
            padding: 10px 15px 10px 40px;
            border-radius: 25px;
            border: 1px solid var(--glass-border);
            background: var(--search-background);
            color: var(--text-color);
            backdrop-filter: blur(5px) saturate(2) var(--edge-refraction-filter);
            font-size: 14px;
            outline: none;
            transition: border-color 0.2s;
            flex-grow: 1;
        }
        
        .search-input:focus {
            border-color: var(--modal-background);
        }
        
        .search-input::placeholder {
            color: var(--secondary-text-color);
        }
        
        .search-icon {
            font-size: 20px;
            position: absolute;
            left: 12px;
            top: 50%;
            transform: translateY(-50%);
            color: var(--secondary-text-color);
            pointer-events: none;
            z-index: 1;
        }

        .filter-container {
            display: flex;
            gap: 6px;
            max-width: 340px;
            justify-content: center;
        }
        
        .filter-btn, .filter-btn-sc {
            flex: 1;
            padding: 8px 10px;
            border-radius: 20px;
            border: 1px solid var(--glass-border);
            background: var(--search-background);
            color: var(--secondary-text-color);
            font-size: 14px;
            cursor: pointer;
            transition: all 0.2s ease;
            backdrop-filter: blur(5px) saturate(2) var(--edge-refraction-filter);
        }
        
        .filter-btn.active, .filter-btn-sc.active {
            background: var(--secondary-text-color);
            color: var(--background-color);
        }

        .filter-separator {
            width: 3px;
            background: var(--search-background);
            border-radius: 5px;
            margin: 10px 5px;
        }
        
        #shuffleBtn, #repeatBtn {
            background: transparent;
            border: none;
            color: var(--text-color);
            width: 50px;
            height: 50px;
            border-radius: 50%;
            cursor: pointer;
            font-size: 1.2rem;
            transition: all 0.3s ease;
            display: flex;
            justify-content: center;
            align-items: center;
            line-height: 0;
            backdrop-filter: none;
            border: 1px solid transparent;
        }
        
        #shuffleBtn.active, #repeatBtn.active {
            backdrop-filter: blur(5px) saturate(2) var(--edge-refraction-filter);
            background: var(--search-background);
            border: 1px solid var(--glass-border);
        }
                
        .material-symbols-rounded {
          font-variation-settings:
          'FILL' 1,
          'wght' 700,
          'GRAD' 0,
          'opsz' 24;
          vertical-align: middle;
        }
        
        .no-results {
            color: var(--text-color);
            text-align: center;
            padding: 20px;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 10px;
        }
        
        .no-results .material-symbols-rounded {
            font-size: 48px;
        }
        
        .no-results p {
            font-size: 14px;
        }
        
        /* For all clickable elements */
        [onclick], 
        button, 
        a, 
        input[type="button"], 
        input[type="submit"],
        .clickable {
          cursor: pointer;
          transform: scale(1);
          transition: all 0.15s cubic-bezier(0.2, 0, 0.38, 0.9);
        }
        
        /* Active effect (when clicking down) */
        [onclick]:active, 
        button:active, 
        a:active, 
        input[type="button"]:active, 
        input[type="submit"]:active,
        .clickable:active {
          transform: scale(0.96);
          transition: all 0.1s cubic-bezier(0.2, 0, 0.38, 0.9);
          filter: brightness(1.5);
        }

        #soundcloudToggle {
            appearance: none;
            width: 50px;
            height: 32px;
            background-color: rgba(0, 0, 0, 0.1);
            border-radius: 16px;
            position: relative;
            cursor: pointer;
            transition: background-color 0.3s;
            border: 1px solid var(--glass-border);
            cursor: pointer;
        }
        
        #soundcloudToggle::before {
            content: '';
            position: absolute;
            width: 18px;
            height: 18px;
            background-color: var(--secondary-text-color);
            border-radius: 50%;
            top: 50%;
            left: 6px;
            transform: translateY(-50%);
            transition: transform 0.3s, background-color 0.3s, width 0.3s, height 0.3s, left 0.3s, right 0.3s;
            border: 1px solid var(--glass-border);
        }
        
        #soundcloudToggle:checked {
            background-color: var(--secondary-text-color);
        }
        
        #soundcloudToggle:checked::before {
            width: 22px;
            height: 22px;
            background-color: var(--background-color);
            left: 21px;
            transform: translateY(-50%);
        }

        @media (min-height: 900px) {
            .controls-container {
                position: fixed;
                bottom: 30px;
                right: 30px;
            }
        }
        
        @media (max-width: 800px) {
            .player-controls {
                gap: 15px;
            }
        }

        @media (min-width: 600px) {
            .drawer {
                left: 5vw !important;
                width: 90vw !important;
                border: 1px solid var(--glass-border);
            }
        }

        @media (min-width: 800px) {
            .drawer {
                left: 15vw !important;
                width: 70vw !important;
                border: 1px solid var(--glass-border);
            }
        }

        @media (min-width: 1000px) {
            .drawer {
                left: 25vw !important;
                width: 50vw !important;
                border: 1px solid var(--glass-border);
            }
        }

        @media (max-width: 560px) {
            #now-playing-view {
                padding: 0 10px 0 10px;
            }

            .music-info, .progress-container, .player-controls {
                padding: 0 10px !important;
            }
            
            .now-playing-wrapper {
                gap: 4vh !important;
            }

            #shuffleBtn, #repeatBtn {
                width: 30px;
                height: 30px;
                border-radius: 10px;
            }
            
            .drawer {
                height: calc(100% - 80px); /* Full height minus top toolbar */
            }
        }

        @media (max-width: 590px) {
            .toolbar {
                justify-content: flex-start;
            }

            .tab-btn {
                font-size: 0;
                padding: 12px 11px 12px 20px;
            }

            .tab-btn.active {
                font-size: 0;
                padding: 12px 11px 12px 20px;
            }
        }
        
        /* When animations are disabled */
        .reduce-animations * {
            /* Disable all animations */
            animation: none !important;
        
            /* Disable all transitions except opacity */
            transition: opacity 0.3s ease !important;
            transition-property: opacity !important;
        }
        
        /* Special handling for clickable elements */
        .reduce-animations [onclick],
        .reduce-animations button,
        .reduce-animations a,
        .reduce-animations input[type="button"],
        .reduce-animations input[type="submit"],
        .reduce-animations .clickable {
            /* Keep initial state but remove transition */
            transform: scale(1) !important;
            transition: opacity 0.3s ease !important;
        }
        
        /* Keep active state functional but without animation */
        .reduce-animations [onclick]:active,
        .reduce-animations button:active,
        .reduce-animations a:active,
        .reduce-animations input[type="button"]:active,
        .reduce-animations input[type="submit"]:active,
        .reduce-animations .clickable:active {
            /* Apply scale instantly without transition */
            transform: scale(0.98) !important;
            transition: none !important;
            filter: brightness(1.5) !important;
        }
        
        /* Adjust for background image with light/dark theme */
        body[style*="background-image"] .music-title,
        body[style*="background-image"] .music-artist,
        body[style*="background-image"] .music-album,
        body[style*="background-image"] .time-info {
            text-shadow: 0 0 10px rgba(0, 0, 0, 0.5);
        }
        
        body.light-theme[style*="background-image"] .music-title,
        body.light-theme[style*="background-image"] .music-artist,
        body.light-theme[style*="background-image"] .music-album,
        body.light-theme[style*="background-image"] .time-info {
            text-shadow: 0 0 10px rgba(255, 255, 255, 0.5);
        }

        /* Lyrics and Queue styles */
        .sidebar-back-btn {
            background: var(--search-background);
            border: 1px solid var(--glass-border);
            backdrop-filter: blur(5px) saturate(2) var(--edge-refraction-filter);
            color: var(--text-color);
            cursor: pointer;
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 14px;
            padding: 8px 15px;
            border-radius: 20px;
            width: fit-content;
        }

        .lyrics-container {
            height: 100%;
            overflow-y: auto;
            scroll-behavior: smooth;
            scroll-padding-top: 30vh;
            padding-bottom: 70vh; /* Ensures last line can also scroll to the sweet spot */
        }

        .lyrics-container p {
            white-space: pre-wrap;
            transition: all 0.4s ease-out; /* Smooth transition for filter and opacity */
            margin: 18px 0;
            padding: 0 10px;
            border-radius: 14px;
            cursor: pointer;
            font-size: 1.5rem;
            font-weight: 600;
            line-height: 1.4; /* Improves readability */
        }
 
        .queue-item .song-info {
            display: flex;
            align-items: center;
            width: 100%;
            gap: 8px;
        }
        
        .queue-item .song-title {
            flex-grow: 1;
        }
        
        .queue-item .song-artist-queue {
            color: var(--secondary-text-color);
            font-size: 0.9em;
            flex-shrink: 0;
            max-width: 100px;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }
        
        .remove-from-queue-btn {
            background: none;
            border: none;
            color: var(--secondary-text-color);
            cursor: pointer;
            padding: 10px 5px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            flex-shrink: 0;
            opacity: 0.5;
        }
        
        .queue-list-container {
            display: flex;
            flex-direction: column;
            gap: 10px; /* This adds the required space between queue items */
        }

        .more-options-menu {
            position: absolute;
            background-color: var(--search-background);
            border-radius: 25px;
            padding: 8px;
            backdrop-filter: blur(5px) saturate(2) var(--edge-refraction-filter);
            border: 1px solid var(--glass-border);
            z-index: 100;
            width: 200px;
            box-shadow: 0 4px 20px rgba(0,0,0,0.2);
            opacity: 0;
            transform: translateY(10px) scale(0.95) scaleY(0.9);
            pointer-events: none;
            transition: opacity 0.2s ease, transform 0.2s ease;
            transform-origin: bottom;
        }

        .more-options-menu.visible {
            opacity: 1;
            transform: translateY(0) scale(1);
            pointer-events: auto;
        }

        .menu-item {
            display: flex;
            align-items: center;
            gap: 12px;
            padding: 10px;
            border-radius: 8px;
            cursor: pointer;
            transition: background-color 0.2s ease;
        }

        .menu-item .material-symbols-rounded {
            font-size: 20px;
        }

        .menu-separator {
            height: 1px;
            background-color: var(--glass-border);
            margin: 8px 0;
        }

        .view-controls {
            display: flex;
            gap: 10px;
            align-items: center;
        }

        .now-playing-wrapper {
            flex-grow: 1;
            display: flex;
            flex-direction: column;
            gap: 2vh;
            justify-content: center;
            align-items: center;
            height: 100vh;
            width: 100%;
            max-width: 100vw;
            box-sizing: border-box;
            padding: 5px;
        }

        .player-column {
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            gap: 2vh;
            max-width: 500px;
            transition: max-width 0.4s ease;
        }
        
        #lyrics-queue-panel {
            width: 450px;
            height: 80vh;
            max-height: 800px;
            background-color: var(--search-background);
            border: 1px solid var(--glass-border);
            box-shadow: 0 0 50px rgba(0, 0, 0, 0.2);
            border-radius: 25px;
            backdrop-filter: blur(10px) saturate(2) var(--edge-refraction-filter);
            flex-shrink: 0;
            padding: 20px;
            display: flex;
            flex-direction: column;
            gap: 15px;
            opacity: 0;
            transform: translateX(20px);
            transition: all 0.3s cubic-bezier(.3,1.2,.64,1);
            pointer-events: none;
            overflow: auto;
            position: absolute;
            top: 50%;
            right: 20px;
            transform: translateY(-50%) translateX(20px) scale(0.9) scaleX(0.9);
            z-index: 5;
            width: 90%;
            max-width: 400px;
            transform-origin: right;
            filter: blur(1px);
        }
        
        #lyrics-queue-panel.visible {
            opacity: 1;
            transform: translateY(-50%) translateX(0);
            pointer-events: auto;
            filter: none;
        }

        /* --- Grid View Styles --- */
        .music-list.grid-view {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(140px, 1fr));
            gap: 15px;
            align-content: start;
        }

        .music-list.grid-view .music-item {
            height: max-content;
        }

        .music-list.grid-view .album-section {
            padding: 0;
            border-top: none; /* No dividers in grid view */
            display: flex;
            flex-direction: column;
            cursor: pointer; /* Albums are clickable in grid view */
        }
        
        .music-list.grid-view .album-header {
            margin-bottom: 8px;
            flex-direction: column;
            gap: 8px;
            cursor: default; /* No dragging albums in grid view */
        }

        .music-list.grid-view .album-thumbnail {
            width: 100%;
            height: auto;
            aspect-ratio: 1 / 1;
        }

        .music-list.grid-view .album-info {
            width: 100%;
            text-align: left;
        }

        .music-list.grid-view .album-name {
            font-size: 1em;
            white-space: normal;
        }
        
        .music-list.grid-view .album-artist {
            font-size: 0.85em;
        }
        
        .music-list.grid-view .album-year {
            display: none; /* Hide year in grid view for space */
        }

        .music-list.grid-view .album-songs {
            display: none; /* Hide individual songs in album grid view */
        }

        /* Song-level grid view */
        .music-list.grid-view.songs-mode .music-item,
        .music-list.grid-view.artists-mode .music-item {
             padding: 8px;
             display: flex;
             flex-direction: column;
             gap: 8px;
             align-items: center;
             text-align: center;
        }
        .music-list.grid-view.songs-mode .song-info,
        .music-list.grid-view.artists-mode .song-info {
            flex-direction: column;
            gap: 8px;
        }
        .music-list.grid-view.songs-mode .album-thumbnail,
        .music-list.grid-view.artists-mode .album-thumbnail {
            width: 100%;
            height: auto;
            aspect-ratio: 1 / 1;
            margin-right: 0;
        }
        .music-list.grid-view.songs-mode .song-title,
        .music-list.grid-view.artists-mode div[style*="font-size: 1em;"] {
            white-space: normal;
        }

        .item-list {
            display: flex;
            flex-direction: column;
            gap: 5px;
            padding-bottom: 125px;
        }
        .album-section-list {
            border-radius: 12px;
            cursor: pointer;
            padding: 10px;
        }
        .album-header-list {
            display: flex;
            align-items: center;
            gap: 15px;
        }

        /* --- Song Context Menu Styles --- */
        .music-item .song-actions,
        .album-header .song-actions {
            position: absolute;
            right: 8px;
            top: 50%;
            transform: translateY(-50%);
            color: var(--secondary-text-color);
            background: none;
            border: none;
            border-radius: 50%;
            width: 28px;
            height: 28px;
            display: flex;
            align-items: center;
            justify-content: center;
            opacity: 0.5;
            transition: opacity 0.2s, background-color 0.2s;
            z-index: 5;
        }

        /* App Drawer Styles */
        .drawer {
            position: fixed;
            bottom: -100%; /* Initially hidden */
            left: 0;
            width: 100%;
            background-color: var(--search-background); 
            z-index: 1002;
            overflow: hidden;
            touch-action: none;
            user-select: none;
            backdrop-filter: blur(10px) saturate(2) var(--edge-refraction-filter);
            border-top: 1px solid var(--glass-border);
            border-radius: 25px 25px 0 0;
            transform-origin: bottom;
            will-change: transform, opacity, bottom;
            transition: all 0.3s cubic-bezier(.3,1.2,.64,1);
            max-height: calc(100% - 80px);
        }

        .drawer.open {
            bottom: 0;
        }

        .drawer-handle {
            width: 50px;
            height: 5px;
            background-color: var(--secondary-text-color);
            border-radius: 3px;
            position: absolute;
            top: 15px;
            left: 50%;
            transform: translateX(-50%);
            cursor: grab;
        }

        .drawer-content {
            max-height: calc(100vh - 150px);
            overflow-y: auto;
            user-select: none;
            padding: 20px 20px 0 20px;
        }
        
        .drawer-content::-webkit-scrollbar { width: 4px; }
        .drawer-content::-webkit-scrollbar-track { background: transparent; }
        .drawer-content::-webkit-scrollbar-thumb { background: var(--modal-transparent); border-radius: 4px; }
        
        .drawer-header {
            padding: 40px 20px 10px 20px;
            text-align: center;
        }
        #drawer-title { font-size: 1.5rem; }
        #drawer-subtitle { color: var(--secondary-text-color); }

        .highlight-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 20px;
            margin-bottom: 40px;
        }
        .highlight-card {
            background: linear-gradient(135deg, rgba(255,255,255,0.1), rgba(255,255,255,0));
            border: 1px solid var(--glass-border);
            border-radius: 25px;
            padding: 10px 15px 10px 12px;
            display: flex;
            align-items: center;
            gap: 15px;
            cursor: pointer;
            transition: all 0.3s cubic-bezier(.3,1.2,.64,1);
        }
        .highlight-card:active {
            transform: scale(0.96);
            transition: all 0.1s cubic-bezier(0.2, 0, 0.38, 0.9);
            filter: brightness(1.5);
        }
        .highlight-card img {
            width: 80px;
            height: 80px;
            border-radius: 12px;
            box-shadow: 0 0 0 1px var(--glass-border);
            flex-shrink: 0;
            transition: all 0.3s cubic-bezier(.3,1.2,.64,1);
        }
        .highlight-card-info {
            flex-grow: 1;
            min-width: 0;
            display: flex;
            flex-direction: column;
            justify-content: center;
            gap: 4px;
            transition: all 0.3s cubic-bezier(.3,1.2,.64,1);
        }
        .highlight-card-label {
            font-size: 12px;
            color: var(--secondary-text-color);
        }
        .highlight-card-title {
            font-size: 1.2rem;
            font-weight: 600;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            font-family: 'Open Runde';
        }
        .highlight-card-subtitle {
            color: var(--secondary-text-color);
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }
        .highlight-card-play {
            margin-left: auto;
            font-size: 36px;
            transition: all 0.3s cubic-bezier(.3,1.2,.64,1);
        }
        
        .song-item-actions {
            background: none;
            border: none;
            color: var(--secondary-text-color);
            margin-left: auto;
            padding: 5px;
            border-radius: 50%;
            cursor: pointer;
        }

        .loading-message {
            position: fixed;
            left: 50%;
            top: 50%;
        }
        
        /* Source indicators for YouTube/SoundCloud */
        .source-indicator {
            position: absolute;
            bottom: 8px;
            right: 8px;
            background: var(--search-background);
            color: var(--text-color);
            border: 1px solid var(--glass-border);
            border-radius: 4px;
            padding: 2px 6px;
            font-size: 10px;
            font-weight: 600;
            backdrop-filter: blur(5px) saturate(2) var(--edge-refraction-filter);
        }
        
        .source-indicator.youtube {
            background: #ff0000;
            color: white;
        }
        
        .source-indicator.soundcloud {
            background: #ff7700;
            color: white;
        }
        
        /* Saved indicator */
        .saved-indicator {
            position: absolute;
            bottom: 8px;
            left: 8px;
            background: var(--secondary-text-color);
            color: var(--background-color);
            border-radius: 50%;
            width: 20px;
            height: 20px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 12px;
            font-weight: bold;
        }
        
        /* Cloud icon for online-only tracks */
        .cloud-indicator {
            position: absolute;
            top: 8px;
            right: 8px;
            color: var(--secondary-text-color);
            font-size: 16px;
        }
    </style>
</head>
<body data-app-name="Music">
    <svg style="position: absolute; width: 0; height: 0;">
        <filter id="albumArtDistortion">
            <feTurbulence 
                id="turbulence"
                type="turbulence" 
                baseFrequency="0.01 0.02" 
                numOctaves="1" 
                seed="0"
            />
            <feGaussianBlur stdDeviation="30" result="blurredTurbulence"/>
            <feDisplacementMap 
                id="displacement"
                in="SourceGraphic" 
                in2="blurredTurbulence" 
                scale="0" 
                xChannelSelector="R" 
                yChannelSelector="G"
            />
        </filter>
    </svg>

    <svg style="display: none">
        <filter id="edge-refraction-only" color-interpolation-filters="linearRGB">
            <!-- Part 1: Create the turbulence that will only be used at the edges -->
            <feTurbulence type="fractalNoise" baseFrequency="0.01 0.04" numOctaves="2" result="turbulence"/>
        
            <!-- Part 2: Create a mask that is only opaque at the edges -->
            <feMorphology in="SourceGraphic" operator="erode" radius="4" result="eroded"/>
            <feComposite in="SourceGraphic" in2="eroded" operator="out" result="border_mask"/>
            <feComposite in="turbulence" in2="border_mask" operator="in" result="edge_turbulence"/>
        
            <!-- Part 3: Create the final displacement map -->
            <!-- First, create the 50% gray neutral background -->
            <feFlood flood-color="#808080" result="neutral_base"/>
            
            <!-- Next, use feMerge to explicitly stack the edge turbulence ON TOP of the gray base.
                 This is the key step that prevents the center from shifting. -->
            <feMerge result="displacement_map">
                <feMergeNode in="neutral_base"/>
                <feMergeNode in="edge_turbulence"/>
            </feMerge>
        
            <!-- Part 4: Apply the final, perfectly centered displacement map -->
            <feDisplacementMap in="SourceGraphic" in2="displacement_map" scale="40" xChannelSelector="R" yChannelSelector="G"/>
        </filter>
    </svg>

    <div class="toolbar">
        <button class="tab-btn active" data-view="home">
            <span class="material-symbols-rounded">home</span>
            Home
        </button>
        <button class="tab-btn" data-view="library">
            <span class="material-symbols-rounded">newsstand</span>
            Library
        </button>
        <button class="tab-btn" data-view="integrations" id="integrations-tab" style="display: none;">
            <span class="material-symbols-rounded">podcasts</span>
            New
        </button>
        <button class="tab-btn" data-view="search">
            <span class="material-symbols-rounded">search</span>
            Search
        </button>
    </div>

    <div id="home-view" class="view-container">
        <!-- Home page content will be rendered here -->
        <div class="loading-message"><svg width="24" height="24" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg" style="color: var(--text-color);"><style>.spinner_V8m1{transform-origin:center;animation:spinner_zKoa 2s linear infinite}.spinner_V8m1 circle{stroke-linecap:round;animation:spinner_YpZS 1.5s ease-in-out infinite}@keyframes spinner_zKoa{100%{transform:rotate(360deg)}}@keyframes spinner_YpZS{0%{stroke-dasharray:0 150;stroke-dashoffset:0}47.5%{stroke-dasharray:42 150;stroke-dashoffset:-16}95%,100%{stroke-dasharray:42 150;stroke-dashoffset:-59}}</style><g class="spinner_V8m1"><circle cx="12" cy="12" r="9.5" fill="none" stroke-width="3"></circle></g></svg></div>
    </div>
    <div id="library-view" class="view-container" style="display: none;">
        <div class="page-content-wrapper">
            <div class="library-controls">
                <div class="filter-container">
                    <button class="filter-btn active" data-filter="albums" style="border-radius: 25px 10px 10px 25px;">Albums</button>
                    <button class="filter-btn" data-filter="artists">Artists</button>
                    <button class="filter-btn" data-filter="songs">Songs</button>
                    <button class="filter-btn" data-filter="playlists" style="border-radius: 10px 25px 25px 10px;">Playlists</button>
                </div>
                <div class="view-controls">
                    <button id="sortBtn" class="library-action-btn"><span class="material-symbols-rounded">history</span><span id="sort-mode-display"></span></button>
                </div>
                 <div class="library-actions">
                    <button class="library-action-btn" id="uploadBtn"><span class="material-symbols-rounded">add</span></button>
                    <button class="library-action-btn" id="manageFoldersBtn"><span class="material-symbols-rounded">folder_managed</span></button>
                </div>
            </div>
            <div id="library-grid" class="item-grid" style="padding-bottom: 240px;">
                <!-- Library content will be rendered here -->
            </div>
             <input type="file" accept="audio/*" style="display: none" id="musicUpload" multiple webkitdirectory>
        </div>
    </div>
    <div id="integrations-view" class="view-container" style="display: none;">
        <div class="page-content-wrapper">
            <div class="library-controls" id="soundcloud-controls">
                <div class="filter-container" id="soundcloud-filter-container" style="max-width: 246px;">
                    <button class="filter-btn-sc active" data-filter="albums" style="border-radius: 25px 10px 10px 25px;">Albums</button>
                    <button class="filter-btn-sc" data-filter="artists">Artists</button>
                    <button class="filter-btn-sc" data-filter="tracks" style="border-radius: 10px 25px 25px 10px;">Songs</button>
                </div>
                <div class="search-container" id="soundcloud-offline-search-container" style="display: none; max-width: 246px; margin: 0px;">
                    <span class="material-symbols-rounded search-icon">search</span>
                    <input type="text" id="soundcloudOfflineSearchInput" placeholder="Search your cached songs" class="library-search-input">
                </div>
                <div class="library-actions">
                    <button class="library-action-btn" id="soundcloudOfflineToggle">
                        <span class="material-symbols-rounded">history</span>
                    </button>
                </div>
            </div>

            <div class="search-container" id="soundcloud-search-container">
                <span class="material-symbols-rounded search-icon">search</span>
                <input type="text" id="soundcloudSearchInput" placeholder="Search YouTube & SoundCloud" class="library-search-input">
            </div>
            
            <div id="soundcloud-results-grid" class="item-grid" style="padding-bottom: 240px;">
                <!-- SoundCloud search/offline results will be rendered here -->
            </div>
        </div>
    </div>
    <div id="search-view" class="view-container" style="display: none;">
        <div class="page-content-wrapper">
            <div class="search-container">
                <span class="material-symbols-rounded search-icon">search</span>
                <input type="text" id="searchInput" placeholder="Search your Library" class="library-search-input">
            </div>
            <div id="search-results-grid" class="item-grid">
                <!-- Search results will be rendered here -->
            </div>
        </div>
    </div>
    <div id="now-playing-view" class="view-container" style="display: none;">
        <div id="distortion-container">
            <div class="background-blur"></div>
            <div class="distortion-shard shape-1"></div>
            <div class="distortion-shard shape-2"></div>
            <div class="distortion-shard shape-3"></div>
        </div>
        <div class="now-playing-wrapper">
            <div class="album-art">
                <img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAfQAAAH0CAYAAADL1t+KAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsMAAA7DAcdvqGQAAAPgSURBVHhe7cEBAQAAAIIg/69uSEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACcqAFFFQAB8Dl/nAAAAABJRU5ErkJggg==" alt="Album Art" id="albumArtImg">
            </div>
            <div class="music-info">
                <div class="music-text">
                    <div class="music-title">No song playing</div>
                    <div class="music-artist">&nbsp;</div>
                </div>
                <canvas id="visualizerCanvas"></canvas>
            </div>
            <div class="progress-container">
                <div class="progress-bar">
                    <div class="progress"></div>
                </div>
                <div class="time-info">
                    <span id="currentTime">&nbsp;</span>
                    <span id="duration">&nbsp;</span>
                </div>
            </div>
            <div class="player-controls">
                <button class="control-btn" id="shuffleBtn">
                    <span class="material-symbols-rounded">shuffle</span>
                </button>
                <button class="control-btn" id="prevBtn">
                    <span class="material-symbols-rounded">skip_previous</span>
                </button>
                <button class="control-btn play-pause" id="playPauseBtn">
                    <span class="material-symbols-rounded" id="playPauseIcon">play_arrow</span>
                </button>
                <button class="control-btn" id="nextBtn">
                    <span class="material-symbols-rounded">skip_next</span>
                </button>
                <button class="control-btn" id="repeatBtn">
                    <span class="material-symbols-rounded">repeat</span>
                </button>
            </div>
            <div class="controls-container">
                <button class="lyrics-button">
                    <span class="material-symbols-rounded" style="font-size: 18px;">tooltip_2</span>
                </button>
                <button class="queue-button">
                    <span class="material-symbols-rounded" style="font-size: 18px;">format_list_bulleted</span>
                </button>
                <button class="more-button">
                    <span class="material-symbols-rounded" style="font-size: 18px;">more_horiz</span>
                </button>
                <div class="volume-control">
                    <span class="material-symbols-rounded" id="volumeIcon">volume_up</span>
                    <input type="range" class="volume-slider" min="0" max="100" value="100">
                </div>
            </div>
            <div id="moreOptionsMenu" class="more-options-menu" style="right: 30px; bottom: 90px;">
                <div class="menu-item" id="menuFullscreenBtn">
                    <span class="material-symbols-rounded">fullscreen</span>
                    <span>Fullscreen</span>
                </div>
                <div class="menu-separator"></div>
                <div class="menu-item" id="menuEditMetadata">
                    <span class="material-symbols-rounded">edit</span>
                    <span>Edit Info</span>
                </div>
                <div class="menu-item" id="menuSaveToLibrary">
                    <span class="material-symbols-rounded">save</span>
                    <span>Save to Library</span>
                </div>
                <div class="menu-item" id="menuAddToPlaylist">
                    <span class="material-symbols-rounded">playlist_add</span>
                    <span>Add to Playlist</span>
                </div>
                <div class="menu-separator"></div>
                <div class="menu-item" id="menuCrossfade">
                    <span class="material-symbols-rounded">swap_horiz</span>
                    <span>Crossfade</span>
                    <span id="crossfadeStatus" style="margin-left: auto; font-size: 0.8em; color: var(--secondary-text-color);">Off</span>
                </div>
                <div class="menu-item" id="menuEqualizer">
                    <span class="material-symbols-rounded">equalizer</span>
                    <span>Equalizer</span>
                </div>
                <div class="menu-item" id="menuSleepTimer">
                    <span class="material-symbols-rounded">timer</span>
                    <span>Sleep Timer</span>
                </div>
                <div class="menu-separator"></div>
                <div class="menu-item" id="menuDeleteSong" style="color: #ff6b6b;">
                    <span class="material-symbols-rounded">delete</span>
                    <span>Delete Song</span>
                </div>
            </div>
            <div id="lyrics-queue-panel" class="hidden">
                 <!-- Lyrics or Queue content will be rendered here by JS -->
            </div>
        </div>
    </div>

    <div id="bottom-miniplayer" class="hidden">
        <div class="miniplayer-progress"></div>
        <img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAfQAAAH0CAYAAADL1t+KAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsMAAA7DAcdvqGQAAAPgSURBVHhe7cEBAQAAAIIg/69uSEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACcqAFFFQAB8Dl/nAAAAABJRU5ErkJggg==" alt="mini-art" id="miniplayer-art">
        <div class="miniplayer-info">
            <div id="miniplayer-title">No song playing</div>
            <div id="miniplayer-artist"></div>
        </div>
        <div class="miniplayer-controls">
            <button id="miniplayer-prev-btn" class="mini-control-btn"><span class="material-symbols-rounded">skip_previous</span></button>
            <button id="miniplayer-play-btn" class="mini-control-btn"><span class="material-symbols-rounded">play_arrow</span></button>
            <button id="miniplayer-next-btn" class="mini-control-btn"><span class="material-symbols-rounded">skip_next</span></button>
        </div>
    </div>

    <!-- Manage Folders Modal -->
    <div id="manageFoldersModal" class="modal-overlay">
        <div style="background: var(--modal-background); padding: 25px; border-radius: 40px; width: 90%; max-width: 450px; backdrop-filter: blur(10px) saturate(2) var(--edge-refraction-filter); border: 1px solid var(--glass-border);">
            <h2 style="margin-bottom: 20px;">Connected Folders</h2>
            <div id="folderList" style="max-height: 250px; overflow-y: auto; margin-bottom: 15px;">
                <!-- Folder list will be populated here -->
            </div>
            
            <div class="menu-separator"></div>
            
            <h2 style="margin-top: 20px; margin-bottom: 15px;">Integrations</h2>
            <div style="display: flex; flex-direction: column; gap: 15px;">
                <div style="display: flex; align-items: center; justify-content: space-between;">
                    <label for="soundcloudToggle">Enable SoundCloud Streaming</label>
                    <input type="checkbox" id="soundcloudToggle">
                </div>
                <input type="text" id="soundcloudClientId" placeholder="SoundCloud Client ID" class="search-input" style="padding-left: 15px;">
                You will need to disable CORS to use SoundCloud streaming. A browser extension may be required.
                
                <div style="display: flex; align-items: center; justify-content: space-between;">
                    <label for="youtubeToggle">Enable YouTube Integration</label>
                    <input type="checkbox" id="youtubeToggle">
                </div>
                <input type="text" id="youtubeApiKey" placeholder="YouTube API Key" class="search-input" style="padding-left: 15px;">
                YouTube integration allows you to search and play music videos without CORS restrictions.
            </div>

            <div style="display: flex; justify-content: flex-end; margin-top: 25px;">
                <button id="saveIntegrations" class="filter-btn">Save</button>
                <button id="closeFoldersModal" class="filter-btn active">Close</button>
            </div>
        </div>
    </div>

    <!-- Edit Song Modal -->
    <div id="editModal" class="modal-overlay">
        <div id="editModalContent" style="background: var(--modal-background); padding: 25px; border-radius: 40px; width: 90%; max-width: 400px; backdrop-filter: blur(10px) saturate(2) var(--edge-refraction-filter); border: 1px solid var(--glass-border);">
            <h2 style="margin-bottom: 20px;">Edit Song Info</h2>
            <input type="hidden" id="editSongId">
            <div style="display: flex; flex-direction: column; gap: 15px;">
                <input type="text" id="editTitle" placeholder="Title" class="search-input" style="padding-left: 15px;">
                <input type="text" id="editArtist" placeholder="Artist" class="search-input" style="padding-left: 15px;">
                <input type="text" id="editAlbum" placeholder="Album" class="search-input" style="padding-left: 15px;">
            </div>
            <div style="display: flex; justify-content: flex-end; gap: 10px; margin-top: 25px;">
                <button id="cancelEdit" class="filter-btn">Cancel</button>
                <button id="saveEdit" class="filter-btn active">Save</button>
            </div>
        </div>
    </div>

    <!-- Sleep Timer Modal -->
    <div id="sleepTimerModal" class="modal-overlay">
        <div style="background: var(--modal-background); padding: 25px; border-radius: 40px; width: 90%; max-width: 300px; backdrop-filter: blur(10px) saturate(2) var(--edge-refraction-filter); border: 1px solid var(--glass-border);">
            <h2 style="margin-bottom: 20px;">Sleep Timer</h2>
            <p style="margin-bottom: 15px; color: var(--secondary-text-color);">Playback will stop after:</p>
            <div style="display: flex; flex-direction: column; gap: 10px;">
                <button class="filter-btn" onclick="setSleepTimer(15)">15 Minutes</button>
                <button class="filter-btn" onclick="setSleepTimer(30)">30 Minutes</button>
                <button class="filter-btn" onclick="setSleepTimer(60)">1 Hour</button>
            </div>
            <div class="menu-separator"></div>
            <button id="cancelSleepTimer" class="filter-btn active" style="width: 100%;">Cancel Timer</button>
        </div>
    </div>

    <!-- Playlist Modal -->
    <div id="playlistModal" class="modal-overlay">
         <div style="background: var(--modal-background); padding: 25px; border-radius: 40px; width: 90%; max-width: 400px; backdrop-filter: blur(10px) saturate(2) var(--edge-refraction-filter); border: 1px solid var(--glass-border);">
            <h2 style="margin-bottom: 20px;">Add to playlist</h2>
            <div id="playlistList" style="max-height: 200px; overflow-y: auto; margin-bottom: 15px;"></div>
            <div class="menu-separator"></div>
            <input type="text" id="newPlaylistName" placeholder="Create new playlist" class="search-input" style="padding-left: 15px; margin-bottom: 10px;">
            <div style="display: flex; justify-content: flex-end; gap: 10px;">
                <button id="closePlaylistModal" class="filter-btn">Cancel</button>
                <button id="createPlaylistBtn" class="filter-btn active">Create & Add</button>
            </div>
        </div>
    </div>
    
    <!-- Equalizer Modal -->
    <div id="equalizerModal" class="modal-overlay">
        <div style="background: var(--modal-background); padding: 25px; border-radius: 40px; width: 90%; max-width: 400px; backdrop-filter: blur(10px) saturate(2) var(--edge-refraction-filter); border: 1px solid var(--glass-border);">
            <h2 style="margin-bottom: 20px;">Equalizer</h2>
            
            <div id="eq-bands-container" style="display: flex; flex-direction: column; gap: 20px; margin-bottom: 25px;">
                <!-- Bass Slider -->
                <div class="eq-band">
                    <label for="bass-slider" style="display: block; margin-bottom: 5px; color: var(--secondary-text-color);">Bass</label>
                    <input type="range" id="bass-slider" class="volume-slider" min="-10" max="10" value="0" step="1">
                </div>
                <!-- Mid Slider -->
                <div class="eq-band">
                    <label for="mid-slider" style="display: block; margin-bottom: 5px; color: var(--secondary-text-color);">Mid</label>
                    <input type="range" id="mid-slider" class="volume-slider" min="-10" max="10" value="0" step="1">
                </div>
                <!-- Treble Slider -->
                <div class="eq-band">
                    <label for="treble-slider" style="display: block; margin-bottom: 5px; color: var(--secondary-text-color);">Treble</label>
                    <input type="range" id="treble-slider" class="volume-slider" min="-10" max="10" value="0" step="1">
                </div>
            </div>

            <div style="display: flex; justify-content: space-between; gap: 10px;">
                <button id="resetEq" class="filter-btn">Reset</button>
                <button id="closeEqModal" class="filter-btn active">Close</button>
            </div>
        </div>
    </div>

    <div id="songContextMenu" class="more-options-menu" style="width: auto;">
        <div class="menu-item" id="menuAddToQueueNext">
            <span class="material-symbols-rounded">playlist_play</span>
            <span>Play Next</span>
        </div>
        <div class="menu-item" id="menuAddToQueueLast">
            <span class="material-symbols-rounded">playlist_add</span>
            <span>Add to Queue</span>
        </div>
    </div>

    <div id="drawer" class="drawer">
        <div class="drawer-handle"></div>
        <div class="drawer-header">
            <h2 id="drawer-title"></h2>
            <p id="drawer-subtitle"></p>
        </div>
        <div class="drawer-content" id="drawer-content">
            <!-- Content will be injected here -->
        </div>
    </div>
    <div id="drawer-overlay" class="modal-overlay"></div>

    <!-- Hidden YouTube iframe for silent playback -->
    <div id="youtube-player-container" style="position: fixed; top: -9999px; left: -9999px; width: 1px; height: 1px; overflow: hidden; z-index: -9999;">
        <iframe id="youtube-player" width="1" height="1" src="about:blank" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>
    </div>

    <script>
        const musicList = document.querySelector('.music-list');
        const musicUpload = document.getElementById('musicUpload');
        const audioPlayer = new Audio();
        const playPauseBtn = document.getElementById('playPauseBtn');
        const prevBtn = document.getElementById('prevBtn');
        const nextBtn = document.getElementById('nextBtn');
        const progressBar = document.querySelector('.progress-bar');
        const progress = document.querySelector('.progress');
        const currentTimeDisplay = document.getElementById('currentTime');
        const durationDisplay = document.getElementById('duration');
        const volumeSlider = document.querySelector('.volume-slider');
        const musicTitle = document.querySelector('.music-title');
        const musicArtist = document.querySelector('.music-artist');
        const albumArtImg = document.getElementById('albumArtImg');
        const playPauseIcon = document.getElementById('playPauseIcon');
        const volumeIcon = document.getElementById('volumeIcon');
        const body = document.body;
        const menuBtn = document.createElement('button');
        const storedLightMode = localStorage.getItem('theme') || 'dark';
        const isMobile = /Mobi|Android/i.test(navigator.userAgent);

        let activeView = 'home'; // 'home', 'library', 'search', 'nowPlaying'
        let isPanelVisible = false;
        let panelContent = null; // 'lyrics' or 'queue'
        let libraryScrollPosition = 0;
        let isFullscreen = false;
        let lastMainView = 'home'; // To remember where to return after playback ends
        let lastScrollPosition = 0; // To remember scroll position when entering Now Playing
        let scrollPositions = { home: 0, library: 0, search: 0 };
        const viewContainers = document.querySelectorAll('.view-container');
        const tabBtns = document.querySelectorAll('.tab-btn');
        const miniplayer = document.getElementById('bottom-miniplayer');
        const miniplayerArt = document.getElementById('miniplayer-art');
        const miniplayerTitle = document.getElementById('miniplayer-title');
        const miniplayerArtist = document.getElementById('miniplayer-artist');
        const miniplayerPlayBtn = document.getElementById('miniplayer-play-btn');
        const miniplayerProgress = document.querySelector('.miniplayer-progress');
        const toolbar = document.querySelector('.toolbar');
        
        const drawer = document.getElementById('drawer');
        const drawerContent = document.getElementById('drawer-content');
        const drawerOverlay = document.getElementById('drawer-overlay');
        let isDrawerOpen = false;
        let closeDrawerTimeout = null;
        
        let listenAgainIndex = parseInt(localStorage.getItem('listenAgainIndex') || '0');
        let currentMediaSessionArtBlobUrl = null;
        let shardContainer; 
        let shards = [];
        let lastOriginalImageUrl = null;
        let lastResizedImageUrl = null;
        let songs = [];
        let currentSongId = null;
        let isPlayerLoading = false;
        let db;
        let directoryHandles = []; // For File System Access API
        let isShuffleEnabled = false;
        let repeatMode = 'none'; // 'none', 'all', or 'one'
        let playQueue = [];
        let isQueueUserModified = false;
        let currentQueueIndex = -1;
        let searchTimeout;
        let searchInput;
        let isDragging = false;
        let draggedItem = null;
        let isDraggingAlbum = false;
        let touchStartY = 0;
        let initialY = 0;
        let touchTarget = null;
        let audioContext;
        let analyser;
        let isVisualizerInitialized = false;
        let source;
        let currentFilter = 'albums'; // 'albums', 'artists', 'songs'
        let editModal, editSongId, editTitle, editArtist, editAlbum, saveEdit, cancelEdit, equalizerModal, manageFoldersModal;
        let crossfadeEnabled = false;
        let sleepTimerId = null;
        let eqBass, eqMid, eqTreble; // Add these for the EQ
        let playlists = [];
        let playlistModal, sleepTimerModal;
        let currentSortMode = 'dateAdded'; // 'dateAdded', 'alpha'
        let activeAlbum = null; // Will store { artist, name } of the selected album

        // --- SoundCloud variables ---
        let soundcloudClientId = '';
        let isSoundcloudEnabled = false;
        let soundcloudSearchTimeout;
        let currentlyPlayingSong = null;
        let isSoundcloudOfflineMode = false;
        let soundcloudFilter = 'tracks';
        let lastSoundcloudSearchResults = []; // To store API results for filtering
        const SOUNDCLOUD_CACHE_LIMIT = 200 * 1024 * 1024; // 200MB

        // --- YouTube variables ---
        let youtubeApiKey = '';
        let isYoutubeEnabled = false;
        let youtubeSearchTimeout;
        let lastYoutubeSearchResults = []; // To store API results for filtering
        let youtubePlayer = null;
        let isYoutubePlayerReady = false;

        function sanitize(str) {
            if (!str) return '';
            return str.toString().replace(/</g, "<").replace(/>/g, ">");
        }

        function openModal(modal) {
            if (modal) modal.classList.add('visible');
        }
        
        function closeModal(modal) {
            if (modal) modal.classList.remove('visible');
        }

function openDrawer(title, subtitle, contentHtml) {
    // Clear any pending close timeout to prevent the drawer from closing immediately
    clearTimeout(closeDrawerTimeout);

    document.getElementById('drawer-title').textContent = sanitize(title);
    document.getElementById('drawer-subtitle').textContent = sanitize(subtitle);
    drawerContent.innerHTML = contentHtml;
    drawer.classList.add('open');
    drawerOverlay.classList.add('visible');
    isDrawerOpen = true;
}

function closeDrawer() {
    drawer.classList.remove('open');
    drawerOverlay.classList.remove('visible');
    isDrawerOpen = false;
    // Clear content after animation
    closeDrawerTimeout = setTimeout(() => {
        drawer.style.transform = '';
        drawerContent.innerHTML = '';
    }, 400);
}
        
function setupDrawerInteractions() {
    let startY = 0;
    let currentY = 0;
    let isDragging = false;
    const handle = document.querySelector('.drawer-handle');
    const drawer = document.getElementById('drawer');

    const startDrag = (y) => {
        if (!isDrawerOpen) return;
        isDragging = true;
        startY = y;
        drawer.style.transition = 'none';
    };

    const moveDrag = (y) => {
        if (!isDragging) return;
        currentY = y;
        const deltaY = currentY - startY;
        if (deltaY > 0) { // Only allow dragging down
            drawer.style.transform = `translateY(${deltaY}px)`;
        }
    };

    const endDrag = () => {
        if (!isDragging) return;
        isDragging = false;
        drawer.style.transition = '';
        drawer.style.transform = ''; // Reset transform to allow CSS transition
        
        const deltaY = currentY - startY;
        if (deltaY > 100) { // Close threshold
            closeDrawer();
        } else {
            drawer.style.bottom = '0';
        }
    };

    handle.addEventListener('mousedown', (e) => startDrag(e.clientY));
    document.addEventListener('mousemove', (e) => moveDrag(e.clientY));
    document.addEventListener('mouseup', endDrag);
    document.addEventListener('mouseleave', endDrag);

    handle.addEventListener('touchstart', (e) => startDrag(e.touches[0].clientY), { passive: true });
    document.addEventListener('touchmove', (e) => moveDrag(e.touches[0].clientY), { passive: true });
    document.addEventListener('touchend', endDrag);

    document.getElementById('drawer-overlay').addEventListener('click', closeDrawer);
}

function getHighResArtwork(url) {
    if (!url) {
        return generateRandomGradient(); // Fallback for tracks with no artwork
    }
    // This is a more robust replacement that handles multiple small sizes
    return url.replace('-large.jpg', '-t500x500.jpg')
              .replace('-t300x300.jpg', '-t500x500.jpg')
              .replace('-badge.jpg', '-t500x500.jpg');
}
        
function renderSearchResults() {
    const searchGrid = document.getElementById('search-results-grid');
    const query = document.getElementById('searchInput').value.toLowerCase();
    if (!query) {
        searchGrid.innerHTML = '';
        return;
    }

    const results = songs.filter(s => 
        s.name.toLowerCase().includes(query) ||
        s.artist.toLowerCase().includes(query) ||
        s.album.toLowerCase().includes(query)
    );

    if (results.length === 0) {
        searchGrid.innerHTML = `<div class="no-results" style="grid-column: 1 / -1;"><p>No results found for "${query}"</p></div>`;
        return;
    }
    
    // For now, just show a list of matching songs
    const resultsHtml = results.map(song => `
        <div class="music-item" data-id="${song.id}" style="cursor: pointer;">
             <div class="song-info">
                <img src="${song.albumArt}" class="album-thumbnail" style="width: 40px; height: 40px; border-radius: 8px; margin-right: 6px;">
                <div>
                    <div class="song-title" style="white-space: normal;">${sanitize(song.name)}</div>
                    <div class="album-artist" style="font-size: 0.8em;">${sanitize(song.artist)}</div>
                </div>
            </div>
        </div>
    `).join('');
    searchGrid.className = 'item-list'; // Search results are a list
    searchGrid.innerHTML = resultsHtml;

    requestAnimationFrame(() => {
        const searchView = document.getElementById('search-view');
        searchView.scrollTop = scrollPositions.search;
    });
}

function renderSoundcloudSearchResults() {
    const resultsGrid = document.getElementById('soundcloud-results-grid');
    if (!lastSoundcloudSearchResults || lastSoundcloudSearchResults.length === 0) {
        resultsGrid.innerHTML = '<div class="no-results" style="grid-column: 1 / -1;"><p>No results found.</p></div>';
        return;
    }

    let resultsHtml = '';
    switch (soundcloudFilter) {
        case 'artists':
            resultsGrid.className = 'item-grid';
            const artists = lastSoundcloudSearchResults.reduce((acc, track) => {
                const artistName = track.user.username;
                if (!acc[artistName]) {
                    acc[artistName] = getHighResArtwork(track.artwork_url) || track.user.avatar_url || generateRandomGradient();
                }
                return acc;
            }, {});
            resultsHtml = Object.entries(artists).map(([name, art]) => `
                <div class="item-card" data-artist-name="${sanitize(name)}">
                    <img src="${art}" class="item-card-art" style="border-radius: 50%;">
                    <div class="item-card-info" style="text-align: center;"><div class="item-card-title">${sanitize(name)}</div></div>
                </div>`).join('');
            break;
        case 'albums':
            resultsGrid.className = 'item-grid';
            const albums = lastSoundcloudSearchResults.reduce((acc, track) => {
                const albumName = track.title.split('-')[0].trim(); // Simple album name parsing
                if (!acc[albumName]) {
                    acc[albumName] = { art: getHighResArtwork(track.artwork_url), artist: track.user.username };
                }
                return acc;
            }, {});
             resultsHtml = Object.entries(albums).map(([name, data]) => `
                <div class="item-card" data-album-name="${sanitize(name)}">
                    <img src="${data.art}" class="item-card-art">
                    <div class="item-card-info"><div class="item-card-title">${sanitize(name)}</div><div class="item-card-subtitle">${sanitize(data.artist)}</div></div>
                </div>`).join('');
            break;
        case 'tracks':
        default:
            resultsGrid.className = 'item-grid';
            resultsHtml = lastSoundcloudSearchResults.map(track => `
                <div class="item-card" data-track-id="${track.id}">
                    <img src="${getHighResArtwork(track.artwork_url)}" class="item-card-art">
                    <div class="item-card-info">
                        <div class="item-card-title">${sanitize(track.title)}</div>
                        <div class="item-card-subtitle">${sanitize(track.user.username)}</div>
                    </div>
                </div>`).join('');
            break;
    }
    resultsGrid.innerHTML = resultsHtml;
}

function renderIntegrationsSearchResults() {
    const resultsGrid = document.getElementById('soundcloud-results-grid');
    const allResults = [];
    
    // Add SoundCloud results with source indicator
    if (isSoundcloudEnabled && lastSoundcloudSearchResults && lastSoundcloudSearchResults.length > 0) {
        const soundcloudResults = lastSoundcloudSearchResults.map(track => ({
            ...track,
            source: 'soundcloud',
            displayName: track.title,
            displayArtist: track.user.username,
            displayArt: getHighResArtwork(track.artwork_url),
            isSaved: isTrackSavedInLibrary(track.id, 'soundcloud')
        }));
        allResults.push(...soundcloudResults);
    }
    
    // Add YouTube results with source indicator
    if (isYoutubeEnabled && lastYoutubeSearchResults && lastYoutubeSearchResults.length > 0) {
        const youtubeResults = lastYoutubeSearchResults.map(video => ({
            ...video,
            source: 'youtube',
            displayName: parseYouTubeTitle(video.snippet.title),
            displayArtist: video.snippet.channelTitle,
            displayArt: video.snippet.thumbnails.high.url,
            isSaved: isTrackSavedInLibrary(video.id, 'youtube')
        }));
        allResults.push(...youtubeResults);
    }
    
    if (allResults.length === 0) {
        resultsGrid.innerHTML = '<div class="no-results" style="grid-column: 1 / -1;"><p>No results found.</p></div>';
        return;
    }
    
    // Sort by relevance (simple alphabetical for now)
    allResults.sort((a, b) => a.displayName.localeCompare(b.displayName));
    
    // Render unified results
    resultsGrid.className = 'item-grid';
    const resultsHtml = allResults.map(item => `
        <div class="item-card" data-${item.source === 'youtube' ? 'video-id' : 'track-id'}="${item.source === 'youtube' ? item.id : item.id}" data-source="${item.source}">
            <img src="${item.displayArt}" class="item-card-art">
            <div class="item-card-info">
                <div class="item-card-title">${sanitize(item.displayName)}</div>
                <div class="item-card-subtitle">${sanitize(item.displayArtist)}</div>
            </div>
            ${item.isSaved ? '<div class="saved-indicator"></div>' : ''}
            ${(isSoundcloudEnabled && isYoutubeEnabled) ? (item.source === 'youtube' ? '<div class="source-indicator youtube">YT</div>' : '<div class="source-indicator soundcloud">SC</div>') : ''}
            <div class="cloud-indicator">
                <span class="material-symbols-rounded">cloud</span>
            </div>
        </div>`).join('');
    
    resultsGrid.innerHTML = resultsHtml;
}

function setView(viewName) {
    activeView = viewName;
    const isNowPlaying = (viewName === 'now-playing');

    tabBtns.forEach(btn => {
        btn.classList.toggle('active', btn.dataset.view === viewName);
    });

    viewContainers.forEach(container => {
        const isVisible = container.id === `${viewName}-view`;
        container.style.display = isVisible ? 'flex' : 'none';

        if (isVisible) {
            if (viewName === 'library') { renderLibraryPage(); } 
            else if (viewName === 'home') { renderHomePage(); } 
            else if (viewName === 'search') { renderSearchResults(); }
        }
    });
    
    if (isNowPlaying && currentSongId) {
        const song = currentlyPlayingSong; 
        if (song) updatePlayerUI(song);
    }

    if (viewName !== 'search') {
        document.getElementById('searchInput').value = '';
        if(activeView === 'search') renderSearchResults(); // Clear results visually
    }
    
    toolbar.classList.toggle('hidden', isNowPlaying && isFullscreen);
    updateMiniplayerUI(currentlyPlayingSong, audioPlayer.paused ? 'paused' : 'playing');

    document.getElementById('distortion-container').classList.toggle('active', isNowPlaying);
    if (isVisualizerInitialized && isNowPlaying && audioContext.state === 'suspended') {
        audioContext.resume();
    }
}
     
const initDB = () => {
    return new Promise((resolve, reject) => {
        // DB version bumped to 7
        const request = indexedDB.open('musicDB', 7);

        request.onerror = (event) => {
            console.error('IndexedDB error:', event.target.error);
            reject(event.target.error);
        };

        request.onupgradeneeded = (event) => {
            db = event.target.result;
            if (!db.objectStoreNames.contains('musicFiles')) {
                db.createObjectStore('musicFiles', { keyPath: 'id' });
            }
            if (!db.objectStoreNames.contains('songs')) {
                const songStore = db.createObjectStore('songs', { keyPath: 'id' });
                songStore.createIndex('albumArtist', 'albumArtist');
                // Add new index for play count
                songStore.createIndex('playCount', 'playCount');
            } else {
                // Ensure playCount index exists on existing stores
                const songStore = event.target.transaction.objectStore('songs');
                if (!songStore.indexNames.contains('playCount')) {
                    songStore.createIndex('playCount', 'playCount');
                }
            }
            if (!db.objectStoreNames.contains('playlists')) {
                db.createObjectStore('playlists', { keyPath: 'id', autoIncrement: true });
            }
            if (!db.objectStoreNames.contains('config')) {
                db.createObjectStore('config', { keyPath: 'key' });
            }
            // Create new store for play history
            if (!db.objectStoreNames.contains('playHistory')) {
                db.createObjectStore('playHistory', { keyPath: 'timestamp' });
            }
            if (!db.objectStoreNames.contains('soundcloudCache')) {
                const cacheStore = db.createObjectStore('soundcloudCache', { keyPath: 'id' });
                cacheStore.createIndex('timestamp', 'timestamp');
            }
        };

        request.onsuccess = (event) => {
            db = event.target.result;
            resolve();
        };
    });
};

function promiseIDBRequest(request) {
    return new Promise((resolve, reject) => {
        request.onsuccess = () => resolve(request.result);
        request.onerror = () => reject(request.error);
    });
}

function createPlayQueue() {
    if (isShuffleEnabled) {
        let availableSongs = [...songs];
        let currentSong = null;
        
        if (currentSongId) {
            currentSong = availableSongs.find(s => s.id === currentSongId);
            availableSongs = availableSongs.filter(s => s.id !== currentSongId);
        }
        
        for (let i = availableSongs.length - 1; i > 0; i--) {
            const j = Math.floor(Math.random() * (i + 1));
            [availableSongs[i], availableSongs[j]] = [availableSongs[j], availableSongs[i]];
        }
        
        return currentSong ? [currentSong, ...availableSongs] : availableSongs;
    }
    
    return [...songs];
}

function resetPlayer() {
    audioPlayer.pause();
    audioPlayer.currentTime = 0;
    currentSongId = null;
    currentlyPlayingSong = null; // Clear the currently playing song object
    updateMiniplayerUI(null);
    playQueue = [];
    currentQueueIndex = -1;

    isShuffleEnabled = false;
    updateShuffleButtonState();

    const defaultImage = "/music/favicon.png";
    const defaultImageBig = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAfQAAAH0CAYAAADL1t+KAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsMAAA7DAcdvqGQAAAPgSURBVHhe7cEBAQAAAIIg/69uSEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACcqAFFFQAB8Dl/nAAAAABJRU5ErkJggg==";

    albumArtImg.src = defaultImageBig;

    updateAllBackgrounds('');
    
    document.querySelector('.background-blur').classList.remove('rotating');

    musicTitle.textContent = 'No song playing';
    musicArtist.textContent = '&nbsp;';
    
    updateTimeDisplays();
    playPauseIcon.textContent = 'play_arrow';
    playPauseBtn.classList.remove('playing');
    Gurasuraisu.updatePlaybackState({ playbackState: 'paused' });
    document.title = 'Music';
    updateFavicon(defaultImage);

    Gurasuraisu.clearMediaSession();

    connectAudioGraph();
    document.querySelector('.lyrics-button').style.display = ''; // Ensure lyrics button is visible on reset

    if ('mediaSession' in navigator) {
        navigator.mediaSession.metadata = null;
        navigator.mediaSession.playbackState = 'none';
    }
    
    if (activeView === 'now-playing') {
        setView(lastMainView);
    }
}
    
        function formatTime(seconds) {
            if (isNaN(seconds) || seconds < 0) return "-:--";
            const minutes = Math.floor(seconds / 60);
            const remainingSeconds = Math.floor(seconds % 60);
            return `${minutes}:${remainingSeconds.toString().padStart(2, '0')}`;
        }
        
function makeElementsDraggable() {
      // This function is intentionally left blank to disable drag-and-drop for the library view.
      // Drag-and-drop for the queue is handled by a separate function.
}

// Function to update the songs array based on the DOM order
function updateSongsArrayFromDOM() {
  const newSongsOrder = [];
  const albumOrder = [];
  
  document.querySelectorAll('.album-section').forEach((albumSection, albumIndex) => {
    const albumName = albumSection.querySelector('.album-name').textContent;
    const albumArtist = albumSection.querySelector('.album-artist').textContent;
    
    albumOrder.push({
      name: albumName,
      index: albumIndex
    });
    
    albumSection.querySelectorAll('.music-item').forEach((musicItem, songIndex) => {
      const songId = parseFloat(musicItem.dataset.id);
      const song = songs.find(s => s.id === songId);
      
      if (song) {
        song.trackNumber = songIndex + 1;
        song.albumOrder = albumIndex;
        newSongsOrder.push(song);
      }
    });
  });
  
  songs = newSongsOrder;
  
  updatePlayQueue();
  
  saveSongs();
}

function loadAndPlaySong(song) {
    if (!song) return;
    playSong(song);
}
        
function updatePageTitle() {
    if (currentSongId) {
        const song = currentlyPlayingSong;
        if (song) {
            const currentTime = formatTime(audioPlayer.currentTime);
            document.title = `${currentTime} | ${sanitize(song.name)}  ${sanitize(song.artist)}`;
        }
    } else {
        document.title = 'Music'; // Default title when no song is playing
    }
}
        
        function isAudioFile(file) {
            const allowedTypes = [
                'audio/mpeg', 'audio/wav', 'audio/wave', 'audio/x-wav', 'audio/flac', 
                'audio/ogg', 'audio/opus', 'audio/x-m4a', 'audio/aac', 'audio/webm', 'audio/x-flac'
            ];
            const allowedExtensions = /\.(mp3|wav|flac|ogg|opus|m4a|aac)$/i;
            
            return allowedTypes.includes(file.type) || (file.name && file.name.match(allowedExtensions));
        }
        
function generateRandomGradient() {
    const colors = [
        '#ff6b6b', '#4ecdc4', '#45b7d1', '#96ceb4', '#ffeead',
        '#d4a5a5', '#9b59b6', '#3498db', '#e74c3c', '#2ecc71',
        '#f1c40f', '#1abc9c', '#e67e22', '#7f8c8d', '#2c3e50'
    ];
    
    const color1 = colors[Math.floor(Math.random() * colors.length)];
    let color2;
    do {
        color2 = colors[Math.floor(Math.random() * colors.length)];
    } while (color1 === color2);
    
    const angle = Math.floor(Math.random() * 360);
    
    const canvas = document.createElement('canvas');
    canvas.width = 500;
    canvas.height = 500;
    const ctx = canvas.getContext('2d');
    
    const gradient = ctx.createLinearGradient(0, 0, 500, 500);
    gradient.addColorStop(0, color1);
    gradient.addColorStop(1, color2);
    
    ctx.fillStyle = gradient;
    ctx.fillRect(0, 0, 500, 500);
    
    return canvas.toDataURL('image/jpeg', 0.9);
}
        
async function preloadSongs(files) {
    const allowedTypes = [
        'audio/mpeg',        // MP3
        'audio/wav',         // WAV
        'audio/flac',        // FLAC
        'audio/ogg',         // OGG
        'audio/opus',        // OPUS
        'audio/x-m4a',       // M4A
        'audio/aac',         // AAC
        'audio/webm',        // WEBM audio
        'audio/x-flac'       // Alternative FLAC MIME type
    ];

    const filesArray = Array.from(files).filter(file => 
        allowedTypes.includes(file.type) || 
        file.name.match(/\.(mp3|wav|flac|ogg|opus|m4a|aac)$/i)
    );
    
    if (filesArray.length === 0) {
        console.warn('No valid audio files found');
        return;
    }

    for (const file of filesArray) {
        try {
            const arrayBuffer = await file.arrayBuffer();
            
            await new Promise((resolve, reject) => {
                const transaction = db.transaction(['musicFiles'], 'readwrite');
                const store = transaction.objectStore('musicFiles');
                
                const song = {
                    id: Date.now() + Math.random(),
                    file: new Blob([arrayBuffer], { type: file.type })
                };
                
                const request = store.put(song);
                
                transaction.oncomplete = () => resolve();
                transaction.onerror = (event) => reject(event.target.error);
            });
        } catch (error) {
            console.error('Error processing file:', error);
        }
    }
}

function updateFavicon(albumArt) {
  if (!albumArt) return;
  const canvas = document.createElement('canvas');
  const ctx = canvas.getContext('2d');
  const size = 32; 
  const radius = 10;

  canvas.width = size;
  canvas.height = size;

  const img = new Image();
  if (!albumArt.startsWith('data:')) {
    img.crossOrigin = 'anonymous';
  }

  img.onload = function() {
    ctx.clearRect(0, 0, size, size);
    ctx.beginPath();
    if (ctx.roundRect) {
        ctx.roundRect(0, 0, size, size, radius);
    } else { // Fallback for older browsers
        ctx.rect(0, 0, size, size);
    }
    ctx.closePath();
    ctx.clip();
    ctx.drawImage(img, 0, 0, size, size);

    const roundedImageURL = canvas.toDataURL('image/png');
    const existingFavicon = document.getElementById('favicon');
    if (existingFavicon) {
        existingFavicon.href = roundedImageURL;
    }
  };

  img.onerror = function() {
    console.error('Error loading album art for favicon');
  };
  img.src = albumArt;
}

async function loadSong(song) {
    playSong(song);
}
        
async function extractMetadata(file) {
    return new Promise((resolve) => {
        new jsmediatags.Reader(file)
            .read({
                onSuccess: async function(tag) {
                    let albumArt;
                    if (tag.tags.picture) {
                        const { data, format } = tag.tags.picture;
                        const base64String = data.reduce((acc, curr) => acc + String.fromCharCode(curr), '');
                        albumArt = `data:${format};base64,${btoa(base64String)}`;
                    } else {
                        albumArt = generateRandomGradient();
                    }

                    let lyricsText = null;
                    let lrcData = null;
                    let foundSyncedLyrics = false;
                    const lrcCandidates = [
                        tag.tags.USLT?.lyrics,
                        (typeof tag.tags.lyrics === 'object' ? tag.tags.lyrics.lyrics : tag.tags.lyrics),
                        tag.tags.LYRICS
                    ];
                    for (const candidate of lrcCandidates) {
                        if (candidate) {
                            const parsed = parseLRC(candidate);
                            if (parsed) {
                                lrcData = parsed;
                                lyricsText = candidate;
                                foundSyncedLyrics = true;
                                break;
                            }
                        }
                    }
                    if (!foundSyncedLyrics) {
                        lyricsText = lrcCandidates.find(text => typeof text === 'string' && text.trim() !== '') || null;
                    }

                    const parseComplexTag = (rawTag) => {
                        if (!rawTag) return null;
                        const value = rawTag.data || rawTag;
                        if (typeof value === 'object' && value.no) {
                            return parseInt(value.no, 10);
                        }
                        const parsed = parseInt(String(value).split('/')[0], 10);
                        return isNaN(parsed) ? null : parsed;
                    };

                    const discNumber = parseComplexTag(tag.tags.DISCNUMBER || tag.tags.disk || tag.tags.TPOS);
                    const trackNumber = parseComplexTag(tag.tags.TRACKNUMBER || tag.tags.track);
                    
                    const albumArtist = tag.tags.TPE2?.data || tag.tags.album_artist || tag.tags.artist || 'Unknown Artist';

                    const genreTag = tag.tags.TCON || tag.tags.genre;
                    const genre = genreTag ? (genreTag.data || genreTag) : null;

                    resolve({
                        title: tag.tags.title || file.name.replace(/\.[^/.]+$/, ""),
                        artist: tag.tags.artist || 'Unknown Artist',
                        album: tag.tags.album || 'Unknown Album',
                        albumArtist: albumArtist,
                        year: tag.tags.year || '',
                        albumArt: albumArt,
                        trackNumber: trackNumber,
                        discNumber: discNumber,
                        lyrics: lyricsText,
                        lrcData: lrcData,
                        genre: genre
                    });
                },
                onError: (error) => {
                    console.error("jsmediatags ERROR for:", file.name, error);
                    resolve({
                        title: file.name.replace(/\.[^/.]+$/, ""),
                        artist: 'Unknown Artist',
                        album: 'Unknown Album',
                        albumArtist: 'Unknown Artist',
                        year: '',
                        albumArt: generateRandomGradient(),
                        trackNumber: null,
                        discNumber: null,
                        lyrics: null,
                        lrcData: null,
                        genre: null
                    });
                }
            });
    });
}
        
async function addSongs(files, storageType) {
    const newSongs = [];
    const songFilesToStore = [];

    for (let fileHandleOrFile of files) {
        try {
            const file = storageType === 'filesystem' ? await fileHandleOrFile.getFile() : fileHandleOrFile;
            if (!isAudioFile(file)) continue;

            const metadata = await extractMetadata(file);
            const newSongId = Date.now() + Math.random();

            newSongs.push({
                id: newSongId,
                name: metadata.title,
                artist: metadata.artist,
                album: metadata.album,
                albumArtist: metadata.albumArtist,
                storage: storageType,
                handleName: file.name,
                dateAdded: Date.now(),
                year: metadata.year,
                albumArt: metadata.albumArt,
                trackNumber: metadata.trackNumber,
                discNumber: metadata.discNumber,
                lyrics: metadata.lyrics,
                lrcData: metadata.lrcData,
                genre: metadata.genre,
                playCount: 0 // Initialize playCount
            });

            if (storageType === 'indexeddb') {
                songFilesToStore.push({ id: newSongId, file: file });
            }

        } catch (error) {
            console.error("Could not process file:", fileHandleOrFile.name, error);
        }
    }

    if (newSongs.length > 0) {
        songs.push(...newSongs);
        processAndSortSongs();
        await saveSongs();

        if (songFilesToStore.length > 0) {
            const tx = db.transaction(['musicFiles'], 'readwrite');
            songFilesToStore.forEach(item => tx.objectStore('musicFiles').put(item));
            await tx.done;
        }
    }

    // Re-render the current view to show the new songs
    if (activeView === 'library') {
        renderLibraryPage();
    } else if (activeView === 'home') {
        renderHomePage();
    }
}

async function scanForNewSongs() {
    if (directoryHandles.length === 0) return false;

    console.log("Scanning for new songs in existing directories...");
    const filesToAdd = [];
    
    const existingSongNames = new Set(songs.map(s => s.handleName));

    for (const handle of directoryHandles) {
        try {
            for await (const entry of handle.values()) {
                if (entry.kind === 'file' && isAudioFile({ name: entry.name }) && !existingSongNames.has(entry.name)) {
                    filesToAdd.push(entry);
                }
            }
        } catch (e) {
            console.error(`Could not scan directory "${handle.name}". It may need to be re-added.`, e);
        }
    }

    if (filesToAdd.length > 0) {
        console.log(`Found ${filesToAdd.length} new songs. Adding them to the library...`);
        await addSongs(filesToAdd, 'filesystem');
        return true; 
    }
    
    console.log("No new songs found.");
    return false;
}

function parseLRC(lrcText) {
    if (!lrcText || !lrcText.includes('[')) {
        return null;
    }

    const lrcData = [];
    const timeRegex = /\[(\d{2}):(\d{2})\.(\d{2,3})\]/g;
    
    const matches = [...lrcText.matchAll(timeRegex)];

    if (matches.length === 0) {
        return null;
    }

    matches.forEach((match, index) => {
        const minutes = parseInt(match[1], 10);
        const seconds = parseInt(match[2], 10);
        const milliseconds = parseInt(match[3].padEnd(3, '0'), 10);
        const time = minutes * 60 + seconds + milliseconds / 1000;

        const textStartIndex = match.index + match[0].length;
        
        const nextMatch = matches[index + 1];
        const textEndIndex = nextMatch ? nextMatch.index : lrcText.length;
        
        const text = lrcText.substring(textStartIndex, textEndIndex).trim();

        lrcData.push({ time, text });
    });

    return lrcData.length > 0 ? lrcData : null;
}
        
async function loadSongsFromStorage() {
    try {
        const tx = db.transaction(['songs'], 'readonly');
        const songStore = tx.objectStore('songs');
        const songsRequest = songStore.getAll();
        
        const loadedSongs = await new Promise((resolve, reject) => {
            songsRequest.onsuccess = () => resolve(songsRequest.result);
            songsRequest.onerror = (e) => reject(e.target.error);
        });
        
        songs = loadedSongs || [];
        processAndSortSongs();
        updatePlayQueue();
    } catch (error) {
        console.error('Error loading songs from storage:', error);
    }
}
        
async function saveSongs() {
    const transaction = db.transaction(['songs'], 'readwrite');
    const store = transaction.objectStore('songs');
    
    return new Promise((resolve, reject) => {
        transaction.onerror = (event) => {
            console.error("Transaction error while saving songs:", event.target.error);
            reject(event.target.error);
        }
        
        store.clear();
        songs.forEach(song => {
            const songToStore = {
                id: song.id, name: song.name, artist: song.artist, album: song.album,
                albumArtist: song.albumArtist, year: song.year, albumArt: song.albumArt, 
                trackNumber: song.trackNumber, discNumber: song.discNumber,
                lyrics: song.lyrics, lrcData: song.lrcData, storage: song.storage,
                handleName: song.handleName, dateAdded: song.dateAdded,
                genre: song.genre,
                playCount: song.playCount || 0
            };
            store.add(songToStore);
        });
        
        transaction.oncomplete = () => {
            console.log(`Songs saved. Total count: ${songs.length}`);
            resolve();
        };
    });
}

async function migrateToFSA() {
    if (directoryHandles.length === 0) return;

    const songsToMigrate = songs.filter(s => s.storage === 'indexeddb');
    if (songsToMigrate.length === 0) {
        console.log("No songs to migrate.");
        return;
    }

    console.log(`Starting migration for ${songsToMigrate.length} songs...`);
    const blobIdsToDelete = [];
    let migrationOccurred = false;

    for (const song of songsToMigrate) {
        let foundInHandles = false;
        for (const handle of directoryHandles) {
            try {
                await handle.getFileHandle(song.handleName);
                foundInHandles = true;
                break;
            } catch (e) { /* Not in this handle */ }
        }
        
        if (foundInHandles) {
            song.storage = 'filesystem';
            blobIdsToDelete.push(song.id);
            migrationOccurred = true;
            console.log(`Migrated "${song.name}" to File System Access.`);
        } else {
            console.warn(`Could not find "${song.handleName}" in the directory. It will remain in browser storage.`);
        }
    }

    if (migrationOccurred) {
        if (blobIdsToDelete.length > 0) {
            const deleteTx = db.transaction('musicFiles', 'readwrite');
            blobIdsToDelete.forEach(id => deleteTx.objectStore('musicFiles').delete(id));
            await deleteTx.done;
        }
        
        await saveSongs();
        Gurasuraisu.showPopup(`Successfully migrated ${blobIdsToDelete.length} songs to use direct file access, freeing up browser storage!`);
    }
}

function initializeShards() {
    const shardElements = document.querySelectorAll('.distortion-shard');
    
    const homePositions = [
        { x: -50, y: -80 }, 
        { x: 80, y: 40 }, 
        { x: -70, y: 60 }
    ];

    shardElements.forEach((el, i) => {
        const homeX = homePositions[i % homePositions.length].x;
        const homeY = homePositions[i % homePositions.length].y;
        
        const magnitude = Math.sqrt(homeX * homeX + homeY * homeY);
        const dirX = magnitude > 0 ? homeX / magnitude : 0;
        const dirY = magnitude > 0 ? homeY / magnitude : 0;

        shards.push({
            element: el,
            bgPos: `${i * 50}% 50%`, 
            rotationSpeed: (Math.random() - 0.5) * 0.25,
            xDrift: (Math.random() - 0.5) * 0.2, 
            yDrift: (Math.random() - 0.5) * 0.2,
            rotation: Math.random() * 360,
            homeX: homeX,
            homeY: homeY,
            dirX: dirX,
            dirY: dirY
        });
        el.style.backgroundPosition = shards[i].bgPos;
    });
}

function setDistortionBackgrounds(url) {
    const backgroundUrl = url ? `url('${url}')` : '';
    shardContainer.querySelector('.background-blur').style.backgroundImage = backgroundUrl;
    shards.forEach(shard => {
        shard.element.style.backgroundImage = backgroundUrl;
    });
}

async function createResizedImageURL(imageUrl, width, height) {
    return new Promise((resolve, reject) => {
        const img = new Image();
        if (!imageUrl.startsWith('data:')) {
            img.crossOrigin = 'Anonymous';
        }
        
        img.onload = () => {
            const canvas = document.createElement('canvas');
            canvas.width = width;
            canvas.height = height;
            const ctx = canvas.getContext('2d');
            ctx.drawImage(img, 0, 0, width, height);
            resolve(canvas.toDataURL('image/jpeg', 0.8)); 
        };
        
        img.onerror = (err) => {
            console.error("Failed to load image for resizing.", err);
            reject(imageUrl); 
        };
        
        img.src = imageUrl;
    });
}

async function updateAllBackgrounds(imageUrl) {
    if (imageUrl === lastOriginalImageUrl && lastResizedImageUrl) {
        setDistortionBackgrounds(lastResizedImageUrl);
        return;
    }

    if (!imageUrl) {
        setDistortionBackgrounds('');
        lastOriginalImageUrl = null;
        lastResizedImageUrl = null;
        return;
    }

    try {
        const resizedUrl = await createResizedImageURL(imageUrl, 64, 64);
        lastOriginalImageUrl = imageUrl;
        lastResizedImageUrl = resizedUrl;
        setDistortionBackgrounds(resizedUrl);
    } catch (originalUrl) {
        console.warn("Could not resize background image, falling back to original.");
        setDistortionBackgrounds(originalUrl);
    }
}

class BeatDetector {
    constructor(frequencyBands, historySize = 60, minThreshold = 5) {
        this.frequencyBands = frequencyBands;
        this.historySize = historySize;
        this.minFluxThreshold = minThreshold;
        this.fluxHistories = this.frequencyBands.map(() => []);
        this.lastEnergies = new Array(this.frequencyBands.length).fill(0);
        this.beatValue = 0.0;
        this.decayRate = 0.96;
        this.dynamicSensitivity = 1.4;
        this.minSensitivity = 1.2;
        this.maxSensitivity = 2.4;
        this.increaseFactor = 1.05;
        this.decreaseFactor = 0.999;
    }

    _calculateStandardDeviation(array, mean) {
        if (array.length < 2) return 0;
        const variance = array.reduce((acc, val) => acc + (val - mean) ** 2, 0) / array.length;
        return Math.sqrt(variance);
    }

    update(dataArray) {
        let beatDetectedThisFrame = false;

        for (let i = 0; i < this.frequencyBands.length; i++) {
            const band = this.frequencyBands[i];
            const history = this.fluxHistories[i];
            
            let currentEnergy = 0;
            for (let j = band[0]; j <= band[1]; j++) currentEnergy += dataArray[j];
            currentEnergy /= (band[1] - band[0] + 1);

            const flux = Math.max(0, currentEnergy - this.lastEnergies[i]);
            this.lastEnergies[i] = currentEnergy;

            if (history.length < this.historySize) {
                history.push(flux);
                continue;
            }
            
            const averageFlux = history.reduce((a, b) => a + b, 0) / history.length;
            const stdDev = this._calculateStandardDeviation(history, averageFlux);
            const dynamicThreshold = averageFlux + (this.dynamicSensitivity * stdDev);

            if (flux > dynamicThreshold && flux > this.minFluxThreshold) {
                beatDetectedThisFrame = true;
            }

            history.push(flux);
            history.shift();
        }

        if (beatDetectedThisFrame) {
            this.beatValue = 1.0;
            this.dynamicSensitivity *= this.increaseFactor;
        } else {
            this.beatValue *= this.decayRate;
            this.dynamicSensitivity *= this.decreaseFactor;
        }
        
        this.dynamicSensitivity = Math.max(this.minSensitivity, Math.min(this.maxSensitivity, this.dynamicSensitivity));
        return this.beatValue;
    }
}

function initVisualizer() {
    if (document.body.classList.contains('reduce-animations')) {
        const canvas = document.getElementById('visualizerCanvas');
        if (canvas) canvas.style.display = 'none';
        return; 
    }

    if (isVisualizerInitialized) return;

    try {
        audioContext = new (window.AudioContext || window.webkitAudioContext)();
        
        eqBass = audioContext.createBiquadFilter();
        eqMid = audioContext.createBiquadFilter();
        eqTreble = audioContext.createBiquadFilter();
        eqBass.type = 'lowshelf'; eqBass.frequency.value = 300; 
        eqMid.type = 'peaking'; eqMid.frequency.value = 1000; eqMid.Q.value = 1; 
        eqTreble.type = 'highshelf'; eqTreble.frequency.value = 3000;
        
        analyser = audioContext.createAnalyser();
        
        source = audioContext.createMediaElementSource(audioPlayer);

        source.connect(eqBass);
        eqBass.connect(eqMid);
        eqMid.connect(eqTreble);
        eqTreble.connect(analyser);
        analyser.connect(audioContext.destination);

        if (isMobile) {
            analyser.fftSize = 64;
        } else {
            analyser.fftSize = 2048;
        }
        
        analyser.smoothingTimeConstant = 0.8;
        const bufferLength = analyser.frequencyBinCount;
        const dataArray = new Uint8Array(bufferLength);
        
        const displacementFilter = document.getElementById('displacement');
        const turbulenceFilter = document.getElementById('turbulence');

        const baselineDistortion = 80;
        const peakDistortion = 250;

        let beatDetector;
        if (!isMobile) {
            beatDetector = new BeatDetector([[0, 10], [20, 50], [80, 120]]);
        }
        
        const canvas = document.getElementById('visualizerCanvas');
        const canvasCtx = canvas.getContext('2d');
        
        // Define separate bar indices for desktop and mobile to match their FFT sizes.
        const desktopBarIndices = [5, 10, 30, 100, 200, 400];
        const mobileBarIndices = [1, 3, 6, 12, 20, 28]; // Mapped to a 32-bin array
        const numBars = 6;
        
        const sensitivityMultipliers = [1, 1.05, 1.1, 1.15, 1.25, 1.4];
        const powerCurve = 2.2;
        
        let smoothedPulse = 0.0; 
        const smoothingFactor = 0.2;

        function draw() {
            requestAnimationFrame(draw);
            analyser.getByteFrequencyData(dataArray);

            if (!isMobile) {
                const beatPulseTarget = beatDetector.update(dataArray);
                smoothedPulse += (beatPulseTarget - smoothedPulse) * smoothingFactor;
    
                const distortionRange = peakDistortion - baselineDistortion;
                const currentDistortion = baselineDistortion + (smoothedPulse * distortionRange);
                displacementFilter.setAttribute('scale', currentDistortion);
    
                const maxShift = 60; 
                const outwardShift = smoothedPulse * maxShift;
                const shardTime = Date.now() * 0.00005;
    
                shards.forEach((shard) => {
                    shard.rotation += shard.rotationSpeed;
                    const baseX = shard.homeX + Math.sin(shardTime * shard.xDrift * 10) * 15;
                    const baseY = shard.homeY + Math.cos(shardTime * shard.yDrift * 10) * 15;
                    const totalX = baseX + (shard.dirX * outwardShift);
                    const totalY = baseY + (shard.dirY * outwardShift);
                    shard.element.style.transform = `translate(${totalX}px, ${totalY}px) rotate(${shard.rotation}deg)`;
                });
    
                turbulenceFilter.setAttribute('seed', Date.now() / 30);
            }
            
            if (canvas.width !== canvas.clientWidth) canvas.width = canvas.clientWidth;
            if (canvas.height !== canvas.clientHeight) canvas.height = canvas.clientHeight;
            canvasCtx.clearRect(0, 0, canvas.width, canvas.height);
            
            const gap = 2;
            const barWidth = (canvas.width - (numBars - 1) * gap) / numBars;
            const style = getComputedStyle(document.body);
            const textColor = style.getPropertyValue('--text-color').trim() || '#FFFFFF';
            canvasCtx.fillStyle = textColor;

            const indicesToUse = isMobile ? mobileBarIndices : desktopBarIndices;

            for (let i = 0; i < numBars; i++) {
                const x = i * (barWidth + gap);
                const value = Math.min(dataArray[indicesToUse[i]] * sensitivityMultipliers[i], 255);
                const barHeight = Math.pow(value / 255, powerCurve) * canvas.height;
                
                const pillRadius = Math.max(0, barWidth / 2);
                if (barHeight < pillRadius * 2) {
                    const dotRadius = barHeight / 2;
                    if (dotRadius < 1) continue;
                    canvasCtx.globalAlpha = barHeight / (pillRadius * 2);
                    canvasCtx.beginPath();
                    canvasCtx.arc(x + pillRadius, canvas.height / 2, dotRadius, 0, 2 * Math.PI);
                    canvasCtx.fill();
                } else {
                    const y = (canvas.height - barHeight) / 2;
                    canvasCtx.globalAlpha = 1.0;
                    canvasCtx.beginPath();
                    if (canvasCtx.roundRect) {
                        canvasCtx.roundRect(x, y, barWidth, barHeight, pillRadius);
                    } else { // Fallback
                        canvasCtx.rect(x, y, barWidth, barHeight);
                    }
                    canvasCtx.fill();
                }
            }
            canvasCtx.globalAlpha = 1.0;
        }

        draw();
        isVisualizerInitialized = true;

    } catch(e) {
        console.error("Failed to initialize AudioContext/Visualizer:", e);
    }
}

function processAndSortSongs() {
    const songsByAlbum = songs.reduce((acc, song) => {
        const albumArtistKey = song.albumArtist || 'Unknown Artist';
        const albumKey = `${albumArtistKey}::${song.album || 'Unknown Album'}`;
        if (!acc[albumKey]) acc[albumKey] = [];
        acc[albumKey].push(song);
        return acc;
    }, {});

    for (const albumKey in songsByAlbum) {
        const albumSongs = songsByAlbum[albumKey];
        albumSongs.sort((a, b) => (a.handleName || a.name).localeCompare(b.handleName || b.name));

        let inferredDisc = 1;
        let lastTrack = 0;
        
        albumSongs.forEach(song => {
            if (song.trackNumber !== null && song.trackNumber < lastTrack) {
                inferredDisc++;
            }
            song.effectiveDiscNumber = song.discNumber || inferredDisc;
            lastTrack = song.trackNumber || 0;
        });
    }
}

async function getArtColors(imageUrl) {
    return new Promise((resolve) => {
        const img = new Image();
        img.crossOrigin = 'Anonymous';
        img.src = imageUrl;
        img.onload = () => {
            const canvas = document.createElement('canvas');
            canvas.width = img.width;
            canvas.height = img.height;
            const ctx = canvas.getContext('2d', { willReadFrequently: true });
            ctx.drawImage(img, 0, 0);
            
            // Get colors from top-left and bottom-right for a simple gradient
            const topLeft = ctx.getImageData(0, 0, 1, 1).data;
            const bottomRight = ctx.getImageData(img.width - 1, img.height - 1, 1, 1).data;

            const color1 = `rgba(${topLeft[0]}, ${topLeft[1]}, ${topLeft[2]}, 0.4)`;
            const color2 = `rgba(${bottomRight[0]}, ${bottomRight[1]}, ${bottomRight[2]}, 0.1)`;
            resolve(`linear-gradient(135deg, ${color1}, ${color2})`);
        };
        img.onerror = () => {
            // Fallback for failed image loads
            resolve('linear-gradient(135deg, rgba(255,255,255,0.1), rgba(255,255,255,0))');
        };
    });
}

async function renderHomePage() {
    const homeView = document.getElementById('home-view');
    if (!homeView) return;

    // --- 1. Fetch all necessary data asynchronously ---
    const topSongsPromise = new Promise(resolve => {
        const tx = db.transaction('songs', 'readonly');
        const index = tx.objectStore('songs').index('playCount');
        const req = index.getAll();
        req.onsuccess = () => resolve(req.result.sort((a,b) => (b.playCount || 0) - (a.playCount || 0)).slice(0, 10));
    });

    const historyPromise = new Promise(resolve => {
        const tx = db.transaction('playHistory', 'readonly');
        const store = tx.objectStore('playHistory');
        const req = store.getAll();
        req.onsuccess = () => resolve(req.result.sort((a,b) => b.timestamp - a.timestamp));
    });

    const [topSongs, history] = await Promise.all([topSongsPromise, historyPromise]);
    // --- 2. Select 4 unique songs for the highlights ---
    
    const highlightSongs = new Set();
    const listenAgainSongs = [];
    if (topSongs.length > 0) {
        listenAgainIndex = (listenAgainIndex + 1) % Math.min(topSongs.length, 10);
        localStorage.setItem('listenAgainIndex', listenAgainIndex);
        listenAgainSongs.push(topSongs[listenAgainIndex]);
        if (topSongs.length > 1) {
            listenAgainSongs.push(topSongs[(listenAgainIndex + 1) % topSongs.length]);
        }
        if (topSongs.length > 2) {
            listenAgainSongs.push(topSongs[(listenAgainIndex + 2) % topSongs.length]);
        }
        if (topSongs.length > 3) {
            listenAgainSongs.push(topSongs[(listenAgainIndex + 3) % topSongs.length]);
        }
    }
    listenAgainSongs.forEach(s => highlightSongs.add(s));

    const recommendations = songs.filter(s => !listenAgainSongs.some(ls => ls.id === s.id));
    for (let i = 0; i < 4 && recommendations.length > 0; i++) {
        const randomIndex = Math.floor(Math.random() * recommendations.length);
        highlightSongs.add(recommendations.splice(randomIndex, 1)[0]);
    }
    
    // --- 3. Build the HTML ---
    const highlights = Array.from(highlightSongs);
    const highlightsHtml = highlights.map((song, i) => {
        const isListenAgain = listenAgainSongs.includes(song);
        return `
        <div class="highlight-card" data-id="${song.id}" id="highlight-${i+1}">
            <img src="${song.albumArt}">
            <div class="highlight-card-info">
                <div class="highlight-card-label">${isListenAgain ? 'Listen Again' : 'From Your Library'}</div>
                <div class="highlight-card-title">${sanitize(song.name)}</div>
                <div class="highlight-card-subtitle">${sanitize(song.artist)}</div>
            </div>
            <span class="material-symbols-rounded highlight-card-play">play_circle</span>
        </div>`;
    }).join('');

    const recentSongIds = [...new Set(history.map(h => h.songId))];
    const recentlyPlayedSongs = recentSongIds.map(id => songs.find(s => s.id === id)).filter(Boolean);
    const recentAlbums = [];
    const recentAlbumIds = new Set();
    for (const song of recentlyPlayedSongs) {
        const albumId = `${song.albumArtist}::${song.album}`;
        if (!recentAlbumIds.has(albumId)) {
            recentAlbumIds.add(albumId);
            recentAlbums.push(song); // Use the song object as a representative for the album
        }
        if (recentAlbums.length >= 40) break; // Limit to 40 albums
    }
    const recentlyPlayedHtml = recentAlbums.map(song => `
         <div class="item-card" data-album-id="${sanitize(song.albumArtist)}::${sanitize(song.album)}">
            <img src="${song.albumArt}" class="item-card-art">
            <div class="item-card-info">
                <div class="item-card-title">${sanitize(song.album)}</div>
                <div class="item-card-subtitle">${sanitize(song.albumArtist)}</div>
            </div>
        </div>
    `).join('');
    
    const genres = [...new Set(songs.map(s => s.genre).filter(Boolean))];
    const genreSectionsHtml = genres.map(genre => {
        const genreSongs = songs.filter(s => s.genre === genre).slice(0, 8);
        return `
        <div>
            <h2 class="section-title">${sanitize(genre)}</h2>
            <div class="item-grid">${genreSongs.map(song => `
                <div class="item-card" data-album-id="${sanitize(song.albumArtist)}::${sanitize(song.album)}">
                    <img src="${song.albumArt}" class="item-card-art">
                    <div class="item-card-info">
                        <div class="item-card-title">${sanitize(song.album)}</div>
                        <div class="item-card-subtitle">${sanitize(song.albumArtist)}</div>
                    </div>
                </div>
            `).join('')}</div> 
        </div>`;
    }).join('');

    homeView.innerHTML = `
    <div class="page-content-wrapper">
        <div class="highlight-grid">${highlightsHtml}</div>
        <div>
            <h2 class="section-title">Recently Played</h2>
            <div class="item-grid">${recentlyPlayedHtml}</div>
        </div>
        ${genreSectionsHtml}
    </div>`;
    
    // --- 4. Asynchronously Apply Gradients ---
    highlights.forEach((song, i) => {
        const card = document.getElementById(`highlight-${i+1}`);
        if (card) {
            getArtColors(song.albumArt).then(gradient => { card.style.background = gradient; });
        }
    });

    requestAnimationFrame(() => {
        const homeView = document.getElementById('home-view');
        homeView.scrollTop = scrollPositions.home;
    });
}

function renderLibraryPage() {
    const libraryView = document.getElementById('library-view');
    const libraryGrid = document.getElementById('library-grid');
    if (!libraryGrid) return;

    // --- RENDER MAIN LIBRARY VIEW ---
    const searchFilteredSongs = songs; // No search bar here anymore

    if (searchFilteredSongs.length === 0) {
        libraryGrid.innerHTML = `<div class="no-results" style="grid-column: 1 / -1;"><span class="material-symbols-rounded">library_music</span><p>Your library is empty.</p><p style="font-size: 0.8em; color: var(--secondary-text-color);">Click "Add Music" to get started.</p></div>`;
        return;
    }
    
    let itemsHtml = ''; // Declare itemsHtml here

    switch (currentFilter) {
        case 'artists':
            libraryGrid.className = 'item-grid';
            const artistsMap = new Map();
            searchFilteredSongs.forEach(song => {
                const artist = song.artist || 'Unknown Artist';
                if (!artistsMap.has(artist)) {
                    artistsMap.set(artist, song.albumArt);
                }
            });
            let artistsList = Array.from(artistsMap.entries());
            if (currentSortMode === 'alpha') artistsList.sort((a, b) => a[0].localeCompare(b[0]));
            
            itemsHtml = artistsList.map(([artist, art]) => `
                <div class="item-card" data-artist-name="${artist}">
                    <img src="${art || generateRandomGradient()}" alt="${artist}" class="item-card-art" style="border-radius: 50%;">
                    <div class="item-card-info" style="text-align: center;">
                        <div class="item-card-title">${sanitize(artist)}</div>
                    </div>
                </div>`).join('');
            break;
        
        case 'songs':
            libraryGrid.className = 'item-list'; // Enforce list view
            const sortedSongs = [...searchFilteredSongs]; // Create a copy to sort
             if (currentSortMode === 'alpha') searchFilteredSongs.sort((a,b) => a.name.localeCompare(b.name));
             else searchFilteredSongs.sort((a,b) => b.dateAdded - a.dateAdded);

            itemsHtml = searchFilteredSongs.map(song => `
                <div class="music-item" data-id="${song.id}" style="cursor: pointer; position: relative;">
                     <div class="song-info">
                        <img src="${song.albumArt}" class="album-thumbnail" style="width: 40px; height: 40px; border-radius: 8px; margin-right: 6px;">
                        <div>
                            <div class="song-title" style="white-space: normal;">${sanitize(song.name)}</div>
                            <div class="album-artist" style="font-size: 0.8em;">${sanitize(song.artist)}</div>
                        </div>
                    </div>
                    ${(song.storage === 'soundcloud' || song.storage === 'youtube') ? '<div class="cloud-indicator"><span class="material-symbols-rounded">cloud</span></div>' : ''}
                </div>
            `).join('');
            break;

        case 'playlists':
            libraryGrid.className = 'item-grid'; // Enforce grid view
            itemsHtml = playlists.map(p => {
                const playlistSongs = p.songIds.map(id => songs.find(s => s.id === id)).filter(Boolean);
                const art = playlistSongs.length > 0 ? playlistSongs[0].albumArt : generateRandomGradient();
                return `
                <div class="item-card" data-playlist-id="${p.id}">
                    <img src="${art}" alt="${p.name}" class="item-card-art">
                    <div class="item-card-info">
                        <div class="item-card-title">${sanitize(p.name)}</div>
                        <div class="item-card-subtitle">${playlistSongs.length} songs</div>
                    </div>
                </div>`;
            }).join('');
            break;

        case 'albums':
        default:
            libraryGrid.className = 'item-grid'; // Enforce grid view
            const albums = groupSongsByAlbum(searchFilteredSongs);
            itemsHtml = albums.map(album => {
                const albumId = `${album.artist}::${album.originalAlbum}`;
                return `
                <div class="item-card" data-album-id="${albumId}">
                    <img src="${album.albumArt}" alt="${album.name}" class="item-card-art">
                    <div class="item-card-info">
                        <div class="item-card-title">${sanitize(album.name)}</div>
                        <div class="item-card-subtitle">${sanitize(album.artist)}</div>
                    </div>
                </div>`;
            }).join('');
            break;
    }
    
    libraryGrid.innerHTML = itemsHtml;

    // --- SCROLL RESTORATION LOGIC ---
    requestAnimationFrame(() => {
        const libraryView = document.getElementById('library-view');
        libraryView.scrollTop = scrollPositions.library;
    });
}
        
function renderPlaylists() {
    const musicListContainer = document.querySelector('.music-list');
    musicListContainer.innerHTML = ''; 

    if (playlists.length === 0) {
        musicListContainer.innerHTML = '<div class="no-results"><span class="material-symbols-rounded">playlist_add</span><p>No playlists to add to</p><p style="font-size: 0.8em; color: var(--secondary-text-color);">Create one from the "More Options" menu while a song is playing.</p></div>';
        return;
    }

    playlists.forEach(playlist => {
        const playlistSongs = playlist.songIds.map(id => songs.find(s => s.id === id)).filter(Boolean);
        const albumArt = playlistSongs.length > 0 ? playlistSongs[0].albumArt : generateRandomGradient();
        
        const item = document.createElement('div');
        item.className = 'music-item';
        item.style.position = 'relative'; 
        item.innerHTML = `
            <div class="song-info">
                <img src="${albumArt}" class="album-thumbnail" style="width: 40px; height: 40px; border-radius: 8px; margin-right: 5px;">
                <div>
                    <div class="song-title" style="font-size: 1em; margin-bottom: 2px; white-space: normal;">${playlist.name}</div>
                    <div class="album-artist" style="font-size: 0.8em;">${playlistSongs.length} songs</div>
                </div>
            </div>
            <button class="remove-from-queue-btn" onclick="deletePlaylist(${playlist.id}, event)" style="position: absolute; right: 10px; top: 50%; transform: translateY(-50%);">
                <span class="material-symbols-rounded" style="font-size: 14px;">cancel</span>
            </button>`;
        
        item.addEventListener('click', (e) => {
            if (e.target.closest('button')) return; 
            renderPlaylistSongs(playlist.id);
        });

        musicListContainer.appendChild(item);
    });
}

function renderPlaylistSongs(playlistId) {
    activePlaylistId = playlistId;
    const playlist = playlists.find(p => p.id === playlistId);
    if (!playlist) return;

    const musicListContainer = document.querySelector('.music-list');
    musicListContainer.innerHTML = '';

    const playlistSongs = playlist.songIds.map(id => songs.find(s => s.id === id)).filter(Boolean);

    if (playlistSongs.length === 0) {
        musicListContainer.insertAdjacentHTML('beforeend', '<div class="no-results"><p>This playlist is empty.</p></div>');
        return;
    }

    const songsHtml = playlistSongs.map(song => `
        <div class="music-item ${song.id === currentSongId ? "active" : ""}" data-id="${song.id}">
            <div class="song-info">
                <img src="${song.albumArt}" class="album-thumbnail" style="width: 40px; height: 40px; border-radius: 8px; margin-right: 5px;">
                <div>
                    <div class="song-title" style="font-size: 1em; margin-bottom: 2px; white-space: normal;">${song.name}</div>
                    <div class="album-artist" style="font-size: 0.8em;">${sanitize(song.artist)}</div>
                    <button class="song-item-actions" data-id="${song.id}"><span class="material-symbols-rounded" style="font-size: 10px;">circle</span></button>
                </div>
                <button class="remove-from-queue-btn" onclick="removeSongFromPlaylist(${song.id}, ${playlist.id}, event)" style="margin-left: auto;">
                    <span class="material-symbols-rounded" style="font-size: 14px;">cancel</span>
                </button>
            </div>
        </div>
    `).join('');

    musicListContainer.insertAdjacentHTML('beforeend', songsHtml);
    
    musicListContainer.querySelectorAll('.music-item').forEach(item => {
        item.addEventListener('click', (e) => {
            if (e.target.closest('button')) return;
            const songId = parseFloat(item.dataset.id);
            const songToPlay = songs.find(s => s.id === songId);
            if (songToPlay) playSong(songToPlay);
        });
    });
}
        
async function deletePlaylist(playlistId, event) {
    event.stopPropagation(); 
    const playlist = playlists.find(p => p.id === playlistId);
    if (!playlist) return;

    if (confirm(`Are you sure you want to delete the playlist "${playlist.name}"?`)) {
        playlists = playlists.filter(p => p.id !== playlistId);

        const tx = db.transaction('playlists', 'readwrite');
        tx.objectStore('playlists').delete(playlistId);
        await tx.done;

        showPopupMessage(`Playlist "${playlist.name}" deleted`);
        renderPlaylists(); 
    }
}

async function removeSongFromPlaylist(songId, playlistId, event) {
    event.stopPropagation();
    const playlist = playlists.find(p => p.id === playlistId);
    const song = songs.find(s => s.id === songId);
    if (!playlist || !song) return;

    playlist.songIds = playlist.songIds.filter(id => id !== songId);

    const tx = db.transaction('playlists', 'readwrite');
    tx.objectStore('playlists').put(playlist);
    await tx.done;
    
    showPopupMessage(`Removed "${song.name}" from "${playlist.name}"`);
    renderPlaylistSongs(playlistId);
}
        
function renderSongs(albums, isArtistView = false) {
  const musicListContainer = document.querySelector('.music-list');
  
  if (!albums || albums.length === 0) {
    musicListContainer.innerHTML = '<div class="no-results"><span class="material-symbols-rounded">search_off</span><p>No songs found</p></div>';
    return;
  }
  
  musicListContainer.innerHTML = albums.map(album => `
    <div class="album-section" 
         data-album-artist="${album.artist}" 
         data-album-name="${album.originalAlbum}">
      <div class="album-header">
        <img src="${album.albumArt}" alt="${album.name}" class="album-thumbnail">
        <div class="album-info">
          <div class="album-name">${album.name}</div>
          ${isArtistView ? '' : `<div class="album-artist">${album.artist}</div>`}
          <div class="album-year">${album.year}</div>
        </div>
      </div>
      <div class="album-songs">
        ${album.songs.map(song => `
          <div class="music-item ${song.id === currentSongId ? "active" : ""}" data-id="${song.id}">
            <div class="song-info">
              <span class="track-number">${song.trackNumber ? song.trackNumber + "." : ""}</span>
              <span class="song-title">${song.name}</span>
            </div>
            <button class="song-actions" data-id="${song.id}">
                <span class="material-symbols-rounded" style="font-size: 10px;">circle</span>
            </button>
          </div>
        `).join("")}
      </div>
    </div>
  `).join("");
  
  attachSongAndAlbumEventListeners();
}

function renderSongsAsList(songsToRender) {
    const musicListContainer = document.querySelector('.music-list');
    musicListContainer.innerHTML = songsToRender.map(song => `
        <div class="music-item ${song.id === currentSongId ? "active" : ""}" data-id="${song.id}">
            <div class="song-info">
                <img src="${song.albumArt}" class="album-thumbnail" style="width: 40px; height: 40px; border-radius: 8px; margin-right: 5px;">
                <div>
                    <div class="song-title" style="font-size: 1em; margin-bottom: 2px;">${song.name}</div>
                    <div class="album-artist" style="font-size: 0.8em;">${sanitize(song.artist)}</div>
                </div>
            </div>
            <button class="song-actions" data-id="${song.id}">
                <span class="material-symbols-rounded" style="font-size: 10px;">circle</span>
            </button>
        </div>
    `).join('');
    attachSongAndAlbumEventListeners();
}
        
async function renderLyrics() {
    const lyricsQueuePanel = document.getElementById('lyrics-queue-panel');
    if (!lyricsQueuePanel) return;

    lyricsQueuePanel.innerHTML = `
        <div class="lyrics-container" id="lyrics-scroll-container"></div>
    `;

    const lyricsContainer = lyricsQueuePanel.querySelector('.lyrics-container');

    if (!currentSongId) {
        lyricsContainer.innerHTML = `<p style="opacity: 1; filter: none;">No song is currently playing.</p>`;
        return;
    }
    
    const song = currentlyPlayingSong;
    if (!song || !song.lyrics) {
        lyricsContainer.innerHTML = `<p style="opacity: 1; filter: none;">No lyrics found.</p>`;
        return;
    }

    if (song.lrcData && song.lrcData.length > 0) {
        lyricsContainer.innerHTML = song.lrcData.map((line, index) => 
            `<p id="lyric-line-${index}" data-time="${line.time}">${line.text || '  '}</p>`
        ).join('');

        lyricsContainer.querySelectorAll('p').forEach(lineEl => {
            lineEl.addEventListener('click', () => {
                const seekTime = parseFloat(lineEl.dataset.time);
                if (!isNaN(seekTime)) {
                    audioPlayer.currentTime = seekTime;
                }
            });
        });

    } else {
        // For plain text lyrics
        lyricsContainer.innerHTML = `<p style="opacity: 1; filter: none; white-space: pre-wrap;">${song.lyrics}</p>`;
    }
}
        
async function renderOfflineSoundcloudView() {
    const resultsGrid = document.getElementById('soundcloud-results-grid');
    const query = document.getElementById('soundcloudOfflineSearchInput').value.toLowerCase();
    resultsGrid.innerHTML = '';
    
    try {
        const tx = db.transaction('soundcloudCache', 'readonly');
        const store = tx.objectStore('soundcloudCache');
        const allCachedItems = await promiseIDBRequest(store.getAll());

        let filteredItems = allCachedItems;
        if (query) {
            filteredItems = allCachedItems.filter(item => 
                item.metadata.name.toLowerCase().includes(query) ||
                item.metadata.artist.toLowerCase().includes(query)
            );
        }
        
        if (filteredItems.length === 0) {
            if (query) {
                // If there was a search query, show a "no results" message.
                resultsGrid.innerHTML = `<div class="no-results" style="grid-column: 1 / -1;"><p>No cached songs match "${sanitize(query)}"</p></div>`;
            } else {
                // If there was no query, it means the cache is empty.
                resultsGrid.innerHTML = `<div class="no-results" style="grid-column: 1 / -1;"><p>No SoundCloud songs are cached</p></div>`;
            }
            return;
        }
        
        // Sort by most recently played
        filteredItems.sort((a, b) => b.timestamp - a.timestamp);

        const resultsHtml = filteredItems.map(entry => {
            const track = entry.metadata;
            return `
            <div class="music-item" data-cached-id="${track.id}" style="cursor: pointer;">
                 <div class="song-info">
                    <img src="${track.albumArt}" class="album-thumbnail" style="width: 40px; height: 40px; border-radius: 8px; margin-right: 6px;">
                    <div>
                        <div class="song-title" style="white-space: normal;">${sanitize(track.name)}</div>
                        <div class="album-artist" style="font-size: 0.8em;">${sanitize(track.artist)}</div>
                    </div>
                </div>
            </div>
            `;
        }).join('');
        resultsGrid.className = 'item-list';
        resultsGrid.innerHTML = resultsHtml;
    } catch (error) {
        console.error('Failed to render offline songs:', error);
        resultsGrid.innerHTML = `<div class="no-results" style="grid-column: 1 / -1;"><p>Error loading cached songs.</p></div>`;
    }
}

// This new function will control the view in the "New" tab
function renderSoundcloudPage() {
    const searchContainer = document.getElementById('soundcloud-search-container');
    const offlineSearchContainer = document.getElementById('soundcloud-offline-search-container');
    const filterContainer = document.getElementById('soundcloud-filter-container');
    
    if (isSoundcloudOfflineMode) {
        searchContainer.style.display = 'none';
        offlineSearchContainer.style.display = 'flex';
        filterContainer.style.display = 'none';
        document.getElementById('soundcloudOfflineToggle').classList.add('active');
        renderOfflineSoundcloudView();
    } else {
        searchContainer.style.display = 'block';
        offlineSearchContainer.style.display = 'none';
        filterContainer.style.display = 'flex';
        document.getElementById('soundcloudOfflineToggle').classList.remove('active');
        document.getElementById('soundcloudOfflineSearchInput').value = '';
        renderSoundcloudSearchResults();
    }
}
        
function renderQueue() {
    const lyricsQueuePanel = document.getElementById('lyrics-queue-panel');
    if (!lyricsQueuePanel) return;

    if (playQueue.length === 0) {
        lyricsQueuePanel.innerHTML = `
            <div class="no-results" style="flex-grow: 1; justify-content: center;">
                <span class="material-symbols-rounded">queue_music</span>
                <p>The queue is empty.</p>
            </div>
        `;
        return;
    }

    const queueHtml = playQueue.map((song, index) => `
        <div class="music-item queue-item ${song.id === currentSongId ? "active" : ""}" data-queue-index="${index}" data-id="${song.id}">
            <div class="song-info">
                <img src="${song.albumArt}" class="album-thumbnail" style="width: 40px; height: 40px; border-radius: 6px; margin: 0 5px;">
                <div class="song-title">${sanitize(song.name)}</div>
                <span class="song-artist-queue">${song.artist}</span>
                <button class="remove-from-queue-btn" data-queue-index="${index}">
                    <span class="material-symbols-rounded" style="font-size: 14px;">cancel</span>
                </button>
            </div>
        </div>
    `).join('');
    
    lyricsQueuePanel.innerHTML = `
        <h2 class="section-title" style="margin-bottom: 0; flex-shrink: 0;">Up Next</h2>
        <div class="queue-list-container">${queueHtml}</div>
    `;

    // Make sure to re-attach event listeners for the new elements
    makeQueueItemsDraggable();
    addQueueItemEventListeners();
}

function scrollToCurrentSongInQueue() {
    // Use a small timeout to ensure the DOM has updated
    setTimeout(() => {
        const activeSongEl = document.querySelector('#lyrics-queue-panel .queue-item.active');
        if (activeSongEl) {
            activeSongEl.scrollIntoView({
                behavior: 'smooth',
                block: 'center'
            });
        }
    }, 100);
}

function attachSongAndAlbumEventListeners() {
  document.querySelectorAll('.song-actions').forEach(button => {
      button.addEventListener('click', (e) => {
          const songId = parseFloat(button.dataset.id);
          openSongContextMenu(e, songId);
      });
  });
}

function rebuildQueueFromCurrentView() {
    const newQueue = [];
    let songItems;

    // Determine where to source the song list from based on the active view
    if (activeView === 'library') {
        songItems = document.querySelectorAll('#library-grid .item-card[data-album-id]');
    } else if (activeView === 'search') {
        // We will add search logic later, for now, it can be empty
        songItems = document.querySelectorAll('#search-view .item-card');
    } else {
        // Default or Home view, we can source from the entire song list for now
        playQueue = [...songs]; // Fallback to all songs
        console.log(`Queue rebuilt from all songs. ${playQueue.length} songs.`);
        isQueueUserModified = false;
        return;
    }

    if (songItems.length > 0) {
        // This part needs to be adapted based on what each view renders.
        // For the library's album view:
        if (activeView === 'library' && currentFilter === 'albums') {
            const albumSongs = [];
            songItems.forEach(card => {
                const [artist, albumName] = card.dataset.albumId.split('::');
                const songsFromAlbum = songs.filter(s => s.albumArtist === artist && s.album === albumName);
                albumSongs.push(...songsFromAlbum);
            });
            // Remove duplicates in case albums are shown multiple times
            const uniqueIds = new Set();
            playQueue = albumSongs.filter(song => {
                const isDuplicate = uniqueIds.has(song.id);
                uniqueIds.add(song.id);
                return !isDuplicate;
            });

        } else {
             // Fallback for other potential views (like song list view later)
             songItems.forEach(item => {
                const songId = parseFloat(item.dataset.id);
                const song = songs.find(s => s.id === songId);
                if (song && !newQueue.some(s => s.id === song.id)) {
                    newQueue.push(song);
                }
            });
            playQueue = newQueue;
        }

    } else {
        // If the view is empty, just use the full song list
        playQueue = [...songs];
    }
    
    console.log(`Queue rebuilt from ${activeView} view. ${playQueue.length} songs.`);
    isQueueUserModified = false; 
}

function addToQueue(songId, position = 'last') {
    isQueueUserModified = true; // Flag that the user is now manually curating the queue
    const song = songs.find(s => s.id === songId);
    if (!song) return;

    if (playQueue.length === 0) {
        rebuildQueueFromCurrentView();
        currentQueueIndex = playQueue.findIndex(s => s.id === currentSongId);
    }
    
    if (currentQueueIndex === -1) {
        currentQueueIndex = playQueue.length - 1;
    }
    
    if (position === 'next') {
        playQueue.splice(currentQueueIndex + 1, 0, song);
    } else { 
        playQueue.push(song);
    }

    Gurasuraisu.showPopup(`Added "${sanitize(song.name)}" to queue.`);
    
    if (isPanelVisible && panelContent === 'queue') {
        renderQueue();
    }
}

function openSongContextMenu(event, songId) {
    event.stopPropagation();
    const contextMenu = document.getElementById('songContextMenu');
    
    document.getElementById('menuAddToQueueNext').onclick = () => {
        addToQueue(songId, 'next');
        contextMenu.classList.remove('visible');
    };
    document.getElementById('menuAddToQueueLast').onclick = () => {
        addToQueue(songId, 'last');
        contextMenu.classList.remove('visible');
    };

    const rect = event.currentTarget.getBoundingClientRect();
    contextMenu.style.top = `${rect.bottom}px`;
    contextMenu.style.left = `${rect.left - contextMenu.offsetWidth + rect.width}px`;
    contextMenu.classList.add('visible');
}

async function playSong(song, playContext = null) {
    if (isPlayerLoading || !song) return;

    // --- NEW QUEUE LOGIC ---
    if (playContext && Array.isArray(playContext)) {
        // PRIORITY 1: A new context was explicitly provided. This ALWAYS overwrites the old queue.
        playQueue = [...playContext];
        isQueueUserModified = false; // This is a new, app-generated queue.
    } else if (isQueueUserModified) {
        // PRIORITY 2: No new context was given, and the user has a custom queue. We must protect it.
        if (!playQueue.some(s => s.id === song.id)) {
            // The song isn't in the custom queue, so add it to play next.
            playQueue.splice(currentQueueIndex + 1, 0, song);
        }
    } else {
        // PRIORITY 3 (FALLBACK): No context and no custom queue. Rebuild from the current view.
        rebuildQueueFromCurrentView();
    }
    
    isPlayerLoading = true;

    try {
        audioPlayer.pause();
        song.hasBeenLogged = false;
        currentlyPlayingSong = song;
        
        // Handle YouTube tracks differently
        if (song.storage === 'youtube') {
            // Check if offline and skip YouTube tracks
            if (handleOfflineYouTubeTrack()) {
                return;
            }
            
            // For YouTube tracks, we need to use the YouTube player
            if (song.videoId) {
                // This is a saved YouTube track from the library
                await playYouTubeTrack(song.videoId, playQueue);
                return; // Exit early as playYouTubeTrack handles everything
            } else {
                Gurasuraisu.showPopup(`Could not find video ID for "${song.name}"`);
                isPlayerLoading = false;
                playNextSong();
                return;
            }
        }
        
        let fileUrl;
        // This logic now cleanly handles all cases
        if (song.blobUrl) { // Case 1: Playing a cached SoundCloud song
            fileUrl = song.blobUrl;
            audioPlayer.removeAttribute('crossorigin');
            connectAudioGraph(); // Visualizer works!
        } else if (song.streamUrl) { // Case 2: Streaming a new SoundCloud song
            fileUrl = song.streamUrl;
            audioPlayer.crossOrigin = "anonymous";
            connectAudioGraph();
        } else { // Case 3: Playing a local file
            fileUrl = await getSongFileUrl(song);
            audioPlayer.removeAttribute('crossorigin');
            connectAudioGraph();
        }

        if (!fileUrl) {
            Gurasuraisu.showPopup(`Could not find file for "${song.name}"`);
            isPlayerLoading = false;
            playNextSong();
            return;
        }
        
        currentSongId = song.id;
        currentQueueIndex = playQueue.findIndex(s => s.id === currentSongId);

        // Revoke old blob URL if it exists
        if (audioPlayer.src && audioPlayer.src.startsWith('blob:')) {
            URL.revokeObjectURL(audioPlayer.src);
        }

        // Now set the source, which triggers the browser to fetch it using the attributes we just set.
        audioPlayer.src = fileUrl;
        audioPlayer.load(); // Explicitly call load() to ensure the new source is processed.
        
        // Update both the main player and the miniplayer
        updatePlayerUI(song);
        updateMiniplayerUI(song, 'paused'); // Initially show as paused
        updateMediaSessionMetadata(song);

        // Register media session
        Gurasuraisu.registerMediaSession(
            { title: song.name, artist: song.artist, artwork: [{ src: song.albumArt }] },
            ['playPause', 'next', 'prev']
        );

        if (isPanelVisible) {
            if (panelContent === 'lyrics') {
                renderLyrics();
            } else if (panelContent === 'queue') {
                renderQueue(); // Re-render queue to update the '.active' highlight
                scrollToCurrentSongInQueue(); // Scroll to new song
            }
        }

        await audioPlayer.play();

        proactivelyCacheNextInQueue();

        playPauseIcon.textContent = 'pause';
        playPauseBtn.classList.add('playing');
        Gurasuraisu.updatePlaybackState({ playbackState: 'playing' });
        updateMiniplayerUI(song, 'playing');

    } catch (error) {
        if (error.name !== 'AbortError') console.error("Failed to play song:", song.name, error);
        Gurasuraisu.updatePlaybackState({ playbackState: 'paused' });
        updateMiniplayerUI(song, 'paused');
    } finally {
        isPlayerLoading = false;
    }
}

function updateMiniplayerUI(song, state) {
    // If we are on the Now Playing screen, the miniplayer should ALWAYS be hidden.
    if (activeView === 'now-playing') {
        miniplayer.classList.add('hidden');
        return;
    }

    if (!song || !currentSongId) {
        miniplayer.classList.add('hidden');
        return;
    }

    miniplayer.classList.remove('hidden');
    miniplayerArt.src = song.albumArt;
    miniplayerTitle.textContent = sanitize(song.name);
    miniplayerArtist.textContent = sanitize(song.artist);
    miniplayerPlayBtn.innerHTML = `<span class="material-symbols-rounded">${state === 'playing' ? 'pause' : 'play_arrow'}</span>`;
}
        
async function getSongFileUrl(song) {
    if (!song) return null;

    if (song.storage === 'indexeddb') {
        try {
            const tx = db.transaction(['musicFiles'], 'readonly');
            const request = tx.objectStore('musicFiles').get(song.id);
            const result = await new Promise((resolve, reject) => {
                request.onsuccess = () => resolve(request.result);
                request.onerror = () => reject(request.error);
            });
            return result ? URL.createObjectURL(result.file) : null;
        } catch (e) {
             console.error(`Could not get blob for ${song.name}:`, e);
             return null;
        }
    }

    for (const handle of directoryHandles) {
        try {
            const fileHandle = await handle.getFileHandle(song.handleName);
            const file = await fileHandle.getFile();
            return URL.createObjectURL(file);
        } catch (e) {
            if (e.name === 'NotFoundError') continue;
            console.error(`Error accessing handle for ${song.name} in directory ${handle.name}:`, e);
        }
    }

    console.warn(`Could not find "${song.handleName}" in any connected directories.`);
    return null;
}

async function logSongPlay(songId) {
    try {
        const songTx = db.transaction('songs', 'readwrite');
        const songStore = songTx.objectStore('songs');
        const songReq = songStore.get(songId);

        songReq.onsuccess = () => {
            const songData = songReq.result;
            if (songData) {
                songData.playCount = (songData.playCount || 0) + 1;
                songStore.put(songData);
            }
        };
        
        const historyTx = db.transaction('playHistory', 'readwrite');
        const historyStore = historyTx.objectStore('playHistory');
        historyStore.put({ timestamp: Date.now(), songId: songId });

        await Promise.all([songTx.done, historyTx.done]);

        // Also update the in-memory version
        const inMemorySong = songs.find(s => s.id === songId);
        if (inMemorySong) {
            inMemorySong.playCount = (inMemorySong.playCount || 0) + 1;
        }

    } catch (error) {
        console.error("Failed to log song play:", error);
    }
}
        
function initModalVariables() {
    editModal = document.getElementById('editModal');
    editSongId = document.getElementById('editSongId');
    editTitle = document.getElementById('editTitle');
    editArtist = document.getElementById('editArtist');
    editAlbum = document.getElementById('editAlbum');
    saveEdit = document.getElementById('saveEdit');
    cancelEdit = document.getElementById('cancelEdit');
    saveEdit.addEventListener('click', saveMetadataChanges);
    cancelEdit.addEventListener('click', () => closeModal(editModal));

    sleepTimerModal = document.getElementById('sleepTimerModal');
    document.getElementById('cancelSleepTimer').addEventListener('click', () => setSleepTimer(0));

    playlistModal = document.getElementById('playlistModal');
    document.getElementById('closePlaylistModal').addEventListener('click', () => closeModal(playlistModal));
    document.getElementById('createPlaylistBtn').addEventListener('click', createPlaylistAndAddSong);

    equalizerModal = document.getElementById('equalizerModal');
    document.getElementById('closeEqModal').addEventListener('click', () => closeModal(equalizerModal));
    document.getElementById('resetEq').addEventListener('click', () => {
        ['bass-slider', 'mid-slider', 'treble-slider'].forEach(id => {
            const slider = document.getElementById(id);
            slider.value = 0;
            slider.dispatchEvent(new Event('input')); 
        });
    });
    document.getElementById('bass-slider').addEventListener('input', (e) => { if(eqBass) eqBass.gain.value = e.target.value; });
    document.getElementById('mid-slider').addEventListener('input', (e) => { if(eqMid) eqMid.gain.value = e.target.value; });
    document.getElementById('treble-slider').addEventListener('input', (e) => { if(eqTreble) eqTreble.gain.value = e.target.value; });
    
    manageFoldersModal = document.getElementById('manageFoldersModal');
    document.getElementById('closeFoldersModal').addEventListener('click', () => closeModal(manageFoldersModal));
}

function openManageFoldersModal() {
    const folderList = document.getElementById('folderList');
    folderList.innerHTML = '';

    if (directoryHandles.length === 0) {
        folderList.innerHTML = '<p style="color: var(--secondary-text-color); text-align: center;">No folders have been added yet.</p>';
    } else {
        directoryHandles.forEach(handle => {
            const item = document.createElement('div');
            item.style.cssText = 'display:flex; align-items:center; justify-content:space-between; padding:8px; border-radius:8px; margin-bottom:5px; background-color:var(--search-background)';
            item.innerHTML = `<span><span class="material-symbols-rounded" style="vertical-align: middle; margin-right: 8px;">folder</span>${handle.name}</span>
                              <button class="remove-folder-btn" data-name="${handle.name}" style="background: none; border: none; color: #ff6b6b; cursor: pointer;"><span class="material-symbols-rounded">delete</span></button>`;
            folderList.appendChild(item);
        });
        
        document.querySelectorAll('.remove-folder-btn').forEach(btn => {
            btn.onclick = (e) => removeFolder(e.currentTarget.dataset.name);
        });
    }
    
    // Populate integration settings
    document.getElementById('soundcloudClientId').value = soundcloudClientId;
    document.getElementById('soundcloudToggle').checked = isSoundcloudEnabled;
    document.getElementById('youtubeApiKey').value = youtubeApiKey;
    document.getElementById('youtubeToggle').checked = isYoutubeEnabled;
    openModal(manageFoldersModal);
}

async function saveIntegrationsSettings() {
    soundcloudClientId = document.getElementById('soundcloudClientId').value.trim();
    isSoundcloudEnabled = document.getElementById('soundcloudToggle').checked;
    youtubeApiKey = document.getElementById('youtubeApiKey').value.trim();
    isYoutubeEnabled = document.getElementById('youtubeToggle').checked;

    const tx = db.transaction('config', 'readwrite');
    await Promise.all([
        tx.objectStore('config').put({ key: 'soundcloudClientId', value: soundcloudClientId }),
        tx.objectStore('config').put({ key: 'isSoundcloudEnabled', value: isSoundcloudEnabled }),
        tx.objectStore('config').put({ key: 'youtubeApiKey', value: youtubeApiKey }),
        tx.objectStore('config').put({ key: 'isYoutubeEnabled', value: isYoutubeEnabled })
    ]);
    
    toggleIntegrationsTab();
}

function toggleIntegrationsTab() {
    const tab = document.getElementById('integrations-tab');
    if (tab) {
        // Show tab if either integration is enabled
        tab.style.display = (isSoundcloudEnabled || isYoutubeEnabled) ? 'flex' : 'none';
    }
}

async function searchSoundCloud(skipRender = false) {
    const query = document.getElementById('soundcloudSearchInput').value.trim();
    const resultsGrid = document.getElementById('soundcloud-results-grid');
    if (!query) {
        resultsGrid.innerHTML = '';
        lastSoundcloudSearchResults = [];
        return;
    }
    if (!soundcloudClientId) {
        resultsGrid.innerHTML = `<div class="no-results" style="grid-column: 1 / -1;"><p>SoundCloud Client ID is not set</p></div>`;
        return;
    }

    if (!skipRender) {
        resultsGrid.innerHTML = `<div class="loading-message"><svg width="24" height="24" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg" style="color: var(--text-color);"><style>.spinner_V8m1{transform-origin:center;animation:spinner_zKoa 2s linear infinite}.spinner_V8m1 circle{stroke-linecap:round;animation:spinner_YpZS 1.5s ease-in-out infinite}@keyframes spinner_zKoa{100%{transform:rotate(360deg)}}@keyframes spinner_YpZS{0%{stroke-dasharray:0 150;stroke-dashoffset:-16}47.5%{stroke-dasharray:42 150;stroke-dashoffset:-59}}</style><g class="spinner_V8m1"><circle cx="12" cy="12" r="9.5" fill="none" stroke-width="3"></circle></g></svg></div>`;
    }

    try {
        const response = await fetch(`https://api-v2.soundcloud.com/search/tracks?q=${encodeURIComponent(query)}&client_id=${soundcloudClientId}&limit=100`);
        if (!response.ok) throw new Error(`API request failed: ${response.statusText}`);
        
        const data = await response.json();
        lastSoundcloudSearchResults = data.collection;
        
        if (!skipRender) {
            renderSoundcloudSearchResults(); // Only render if not called from integrations search
        }

    } catch (error) {
        console.error('SoundCloud Search Error:', error);
        if (!skipRender) {
            resultsGrid.innerHTML = `<div class="no-results" style="grid-column: 1 / -1;"><p>Error searching SoundCloud</p></div>`;
        }
    }
}

async function searchYouTube(query) {
    if (!query || !youtubeApiKey) {
        return [];
    }
    
    try {
        const response = await fetch(`https://www.googleapis.com/youtube/v3/search?part=snippet&maxResults=50&q=${encodeURIComponent(query)}&type=video&key=${youtubeApiKey}`);
        if (!response.ok) throw new Error(`YouTube API request failed: ${response.statusText}`);
        
        const data = await response.json();
        return data.items || [];
    } catch (error) {
        console.error('YouTube Search Error:', error);
        return [];
    }
}

// Function to check if a track is already saved in the library
function isTrackSavedInLibrary(trackId, source) {
    if (source === 'youtube') {
        return songs.some(s => s.storage === 'youtube' && s.videoId === trackId);
    } else if (source === 'soundcloud') {
        return songs.some(s => s.storage === 'soundcloud' && s.id === trackId);
    }
    return false;
}

// Function to check if user is offline
function isOffline() {
    return !navigator.onLine;
}

// Function to handle offline YouTube tracks in playlists
function handleOfflineYouTubeTrack() {
    if (isOffline()) {
        Gurasuraisu.showPopup('Skipped offline track');
        playNextSong();
        return true;
    }
    return false;
}

async function searchIntegrations() {
    const query = document.getElementById('soundcloudSearchInput').value.trim();
    const resultsGrid = document.getElementById('soundcloud-results-grid');
    
    if (!query) {
        lastSoundcloudSearchResults = [];
        lastYoutubeSearchResults = [];
        renderIntegrationsSearchResults();
        return;
    }

    // Show loading message
    resultsGrid.innerHTML = `<div class="loading-message"><svg width="24" height="24" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg" style="color: var(--text-color);"><style>.spinner_V8m1{transform-origin:center;animation:spinner_zKoa 2s linear infinite}.spinner_V8m1 circle{stroke-linecap:round;animation:spinner_YpZS 1.5s ease-in-out infinite}@keyframes spinner_zKoa{100%{transform:rotate(360deg)}}@keyframes spinner_YpZS{0%{stroke-dasharray:0 150;stroke-dashoffset:-16}47.5%{stroke-dasharray:42 150;stroke-dashoffset:-59}}</style><g class="spinner_V8m1"><circle cx="12" cy="12" r="9.5" fill="none" stroke-width="3"></circle></g></svg></div>`;

    // Search both platforms simultaneously
    if (isSoundcloudEnabled) {
        // SoundCloud search will update lastSoundcloudSearchResults but skip rendering
        await searchSoundCloud(true);
    }
    
    if (isYoutubeEnabled) {
        const youtubeResults = await searchYouTube(query);
        lastYoutubeSearchResults = youtubeResults;
    }
    
    // Render unified results
    renderIntegrationsSearchResults();
}

// This is a new helper function to manage the cache size
async function manageCacheSize() {
    const tx = db.transaction('soundcloudCache', 'readwrite');
    const store = tx.objectStore('soundcloudCache');
    const index = store.index('timestamp');
    const allEntriesReq = index.getAll();

    allEntriesReq.onsuccess = async () => {
        const entries = allEntriesReq.result;
        let totalSize = entries.reduce((acc, entry) => acc + entry.size, 0);

        if (totalSize > SOUNDCLOUD_CACHE_LIMIT) {
            console.log(`Cache size (${(totalSize / 1024 / 1024).toFixed(2)}MB) exceeds limit. Pruning...`);
            entries.sort((a, b) => a.timestamp - b.timestamp); // Sort oldest first

            for (const entry of entries) {
                if (totalSize <= SOUNDCLOUD_CACHE_LIMIT) break;
                await store.delete(entry.id);
                totalSize -= entry.size;
                console.log(`Removed ${entry.metadata.name} from cache.`);
            }
        }
    };
    await tx.done;
}

// This is a new function to handle background caching
async function cacheSoundcloudTrack(songObject, streamUrl) {
    try {
        const audioResponse = await fetch(streamUrl);
        if (!audioResponse.ok) throw new Error('Could not download audio file for caching.');
        const audioBlob = await audioResponse.blob();

        const cacheEntry = {
            id: songObject.id,
            metadata: songObject,
            blob: audioBlob,
            timestamp: Date.now(),
            size: audioBlob.size
        };

        const tx = db.transaction('soundcloudCache', 'readwrite');
        tx.objectStore('soundcloudCache').put(cacheEntry);
        await tx.done;

        console.log(`Successfully cached "${songObject.name}"`);
        await manageCacheSize();

    } catch (error) {
        console.error(`Failed to cache ${songObject.name}:`, error);
    }
}

// This is a NEW function for proactive background caching
async function proactivelyCacheNextInQueue() {
    if (playQueue.length === 0 || currentQueueIndex < 0) return;

    // Look ahead 2 songs in the queue
    for (let i = 1; i <= 2; i++) {
        const nextIndex = currentQueueIndex + i;
        if (nextIndex >= playQueue.length) break;

        const nextSong = playQueue[nextIndex];
        if (nextSong.storage === 'soundcloud') {
            const tx = db.transaction('soundcloudCache', 'readonly');
            const store = tx.objectStore('soundcloudCache');
            const checkReq = store.get(nextSong.id);
            checkReq.onsuccess = () => {
                if (!checkReq.result) {
                    console.log(`Proactively caching next song: ${nextSong.name}`);
                    // Fetch stream URL and cache without awaiting, so it runs in the background
                    fetch(`https://api-v2.soundcloud.com/tracks/${nextSong.id}?client_id=${soundcloudClientId}`)
                        .then(res => res.json())
                        .then(trackData => {
                            const stream = trackData.media.transcodings.find(t => t.format.protocol === 'progressive');
                            return fetch(`${stream.url}?client_id=${soundcloudClientId}`);
                        })
                        .then(res => res.json())
                        .then(streamData => cacheSoundcloudTrack(nextSong, streamData.url))
                        .catch(err => console.error(`Failed to proactively cache ${nextSong.name}:`, err));
                }
            };
        }
    }
}

// This is a NEW function to save a SoundCloud track to the local library
async function saveSoundcloudTrackToLibrary() {
    if (!currentlyPlayingSong || currentlyPlayingSong.storage !== 'soundcloud') return;
    const songToSave = currentlyPlayingSong;

    try {
        let audioBlob;
        // Check if the song is already cached
        const tx = db.transaction('soundcloudCache', 'readonly');
        const cacheReq = await promiseIDBRequest(tx.objectStore('soundcloudCache').get(songToSave.id));
        
        if (cacheReq && cacheReq.blob) {
            audioBlob = cacheReq.blob;
        } else {
            // If not cached, we must fetch the audio data first
            if (!songToSave.streamUrl) throw new Error("Stream URL is missing.");
            const audioResponse = await fetch(songToSave.streamUrl);
            if (!audioResponse.ok) throw new Error("Could not download audio.");
            audioBlob = await audioResponse.blob();
        }

        const newLocalId = Date.now() + Math.random();
        const newLocalSong = {
            id: newLocalId,
            name: songToSave.name,
            artist: songToSave.artist,
            album: songToSave.name,
            albumArtist: songToSave.artist, // Assume artist is album artist for SC
            storage: 'indexeddb',
            handleName: `${songToSave.name}.mp3`,
            dateAdded: Date.now(),
            year: new Date().getFullYear().toString(),
            albumArt: songToSave.albumArt,
            trackNumber: null,
            discNumber: null,
            lyrics: null,
            lrcData: null,
            playCount: 0
        };

        // Save to the main 'songs' store and the 'musicFiles' store
        const songTx = db.transaction(['songs', 'musicFiles'], 'readwrite');
        songTx.objectStore('songs').put(newLocalSong);
        songTx.objectStore('musicFiles').put({ id: newLocalId, file: audioBlob });
        await songTx.done;
        
        songs.push(newLocalSong); // Add to in-memory library
        processAndSortSongs();
        Gurasuraisu.showPopup(`Saved "${songToSave.name}" to Library`);

    } catch (error) {
        console.error("Failed to save SoundCloud track to library:", error);
        Gurasuraisu.showPopup("Could not save song");
    }
}

// This is a NEW function to save a YouTube track to the local library
async function saveYouTubeTrackToLibrary() {
    if (!currentlyPlayingSong || currentlyPlayingSong.storage !== 'youtube') return;
    const songToSave = currentlyPlayingSong;

    try {
        const newLocalId = Date.now() + Math.random();
        const newLocalSong = {
            id: newLocalId,
            name: songToSave.name,
            artist: songToSave.artist,
            album: songToSave.album, // Use video title as album
            albumArtist: songToSave.artist,
            storage: 'youtube', // Keep as YouTube for metadata purposes
            handleName: `${songToSave.name}.youtube`,
            dateAdded: Date.now(),
            year: songToSave.year || new Date().getFullYear().toString(),
            albumArt: songToSave.albumArt,
            trackNumber: null,
            discNumber: null,
            lyrics: null,
            lrcData: null,
            playCount: 0,
            videoId: songToSave.videoId, // Store YouTube video ID for future playback
            duration: songToSave.duration
        };

        // Save to the main 'songs' store only (no audio file for YouTube)
        const songTx = db.transaction(['songs'], 'readwrite');
        songTx.objectStore('songs').put(newLocalSong);
        await songTx.done;
        
        songs.push(newLocalSong); // Add to in-memory library
        processAndSortSongs();
        Gurasuraisu.showPopup(`Saved "${songToSave.name}" to Library`);

    } catch (error) {
        console.error("Failed to save YouTube track to library:", error);
        Gurasuraisu.showPopup("Could not save song");
    }
}

async function playSoundcloudTrack(trackId, playContext) {
    const numericTrackId = Number(trackId);
    
    try {
        const tx = db.transaction('soundcloudCache', 'readwrite');
        const store = tx.objectStore('soundcloudCache');
        const cachedEntry = await promiseIDBRequest(store.get(numericTrackId));

        let songToPlay;

        if (cachedEntry) {
            console.log("Playing from cache:", cachedEntry.metadata.name);
            songToPlay = cachedEntry.metadata;
            songToPlay.blobUrl = URL.createObjectURL(cachedEntry.blob);
            
            // Update timestamp to mark as recently used
            cachedEntry.timestamp = Date.now();
            store.put(cachedEntry);
        } else {
            console.log("Not in cache, streaming from SoundCloud...");
            const trackResponse = await fetch(`https://api-v2.soundcloud.com/tracks/${numericTrackId}?client_id=${soundcloudClientId}`);
            if (!trackResponse.ok) throw new Error('Could not fetch track details.');
            const trackData = await trackResponse.json();

            const progressiveStream = trackData.media.transcodings.find(t => t.format.protocol === 'progressive');
            if (!progressiveStream || !progressiveStream.url) throw new Error('No streamable URL found.');
            
            const streamResponse = await fetch(`${progressiveStream.url}?client_id=${soundcloudClientId}`);
            if (!streamResponse.ok) throw new Error('Could not fetch stream URL.');
            const streamData = await streamResponse.json();
            const finalStreamUrl = streamData.url;

            songToPlay = {
                id: trackData.id,
                name: trackData.title,
                artist: trackData.user.username,
                album: trackData.title,
                albumArt: getHighResArtwork(trackData.artwork_url),
                storage: 'soundcloud',
                streamUrl: finalStreamUrl
            };
            
            // Start caching in the background *after* initiating playback logic
            cacheSoundcloudTrack(songToPlay, finalStreamUrl);
        }

        playSong(songToPlay, playContext);
        await tx.done;
    } catch (error) {
        console.error('Error playing or fetching SoundCloud track:', error);
        Gurasuraisu.showPopup('Could not play the selected track');
    }
}

// YouTube Player Functions
function initYouTubePlayer() {
    if (youtubePlayer || !isYoutubeEnabled) return;
    
    // Load YouTube IFrame API
    const tag = document.createElement('script');
    tag.src = 'https://www.youtube.com/iframe_api';
    const firstScriptTag = document.getElementsByTagName('script')[0];
    firstScriptTag.parentNode.insertBefore(tag, firstScriptTag);
    
    // YouTube API will call this function when ready
    window.onYouTubeIframeAPIReady = function() {
        youtubePlayer = new YT.Player('youtube-player', {
            height: '1',
            width: '1',
            videoId: '',
            playerVars: {
                'playsinline': 1,
                'controls': 0,
                'disablekb': 1,
                'fs': 0,
                'modestbranding': 1,
                'rel': 0,
                'showinfo': 0
            },
            events: {
                'onReady': onPlayerReady,
                'onStateChange': onPlayerStateChange,
                'onError': onPlayerError
            }
        });
    };
}

function onPlayerReady(event) {
    isYoutubePlayerReady = true;
    console.log('YouTube player ready');
}

function onPlayerStateChange(event) {
    if (event.data === YT.PlayerState.ENDED) {
        playNextSong();
    } else if (event.data === YT.PlayerState.PLAYING) {
        // Update player state
        if (currentlyPlayingSong && currentlyPlayingSong.storage === 'youtube') {
            playPauseIcon.textContent = 'pause';
            playPauseBtn.classList.add('playing');
            Gurasuraisu.updatePlaybackState({ playbackState: 'playing' });
        }
    } else if (event.data === YT.PlayerState.PAUSED) {
        if (currentlyPlayingSong && currentlyPlayingSong.storage === 'youtube') {
            playPauseIcon.textContent = 'play_arrow';
            playPauseBtn.classList.remove('playing');
            Gurasuraisu.updatePlaybackState({ playbackState: 'paused' });
        }
    }
}

function onPlayerError(event) {
    console.error('YouTube player error:', event.data);
    Gurasuraisu.showPopup('This track cannot be played.');
    playNextSong();
}

async function playYouTubeTrack(videoId, playContext) {
    if (!youtubePlayer || !isYoutubePlayerReady) {
        initYouTubePlayer();
        // Wait for player to be ready
        await new Promise(resolve => {
            const checkReady = () => {
                if (isYoutubePlayerReady) resolve();
                else setTimeout(checkReady, 100);
            };
            checkReady();
        });
    }
    
    try {
        // Get video details from YouTube API
        const response = await fetch(`https://www.googleapis.com/youtube/v3/videos?part=snippet,contentDetails&id=${videoId}&key=${youtubeApiKey}`);
        if (!response.ok) throw new Error('Could not fetch video details');
        
        const data = await response.json();
        if (!data.items || data.items.length === 0) throw new Error('Video not found');
        
        const video = data.items[0];
        const songToPlay = {
            id: video.id,
            name: parseYouTubeTitle(video.snippet.title),
            artist: video.snippet.channelTitle,
            album: video.snippet.title, // Use video title as album
            albumArt: video.snippet.thumbnails.high.url,
            storage: 'youtube',
            videoId: video.id,
            duration: parseYouTubeDuration(video.contentDetails.duration),
            year: new Date(video.snippet.publishedAt).getFullYear().toString()
        };
        
        // Load and play the video
        youtubePlayer.loadVideoById(videoId);
        youtubePlayer.playVideo();
        
        // Update player UI
        playSong(songToPlay, playContext);
        
    } catch (error) {
        console.error('Error playing YouTube track:', error);
        Gurasuraisu.showPopup('Could not play the selected track');
    }
}

function parseYouTubeTitle(title) {
    // Clean up YouTube titles by removing common suffixes
    return title
        .replace(/\s*\(Official\s+(?:Music\s+)?Video\)/gi, '')
        .replace(/\s*\[Official\s+(?:Music\s+)?Video\]/gi, '')
        .replace(/\s*\(Official\s+Audio\)/gi, '')
        .replace(/\s*\[Official\s+Audio\]/gi, '')
        .replace(/\s*\(Lyrics\)/gi, '')
        .replace(/\s*\[Lyrics\]/gi, '')
        .replace(/\s*\(Audio\)/gi, '')
        .replace(/\s*\[Audio\]/gi, '')
        .trim();
}

function parseYouTubeDuration(duration) {
    // Parse ISO 8601 duration format (PT4M13S)
    const match = duration.match(/PT(?:(\d+)H)?(?:(\d+)M)?(?:(\d+)S)?/);
    if (!match) return 0;
    
    const hours = parseInt(match[1] || 0);
    const minutes = parseInt(match[2] || 0);
    const seconds = parseInt(match[3] || 0);
    
    return hours * 3600 + minutes * 60 + seconds;
}

function connectAudioGraph() {
    if (source && audioContext && eqBass) {
        try {
            source.disconnect(); // Disconnect everything first to ensure a clean state
        } catch(e) { /* Fails if not connected, which is fine */ }
        // Reconnect the full chain: source -> EQ -> analyser -> output
        source.connect(eqBass);
        document.getElementById('visualizerCanvas').style.visibility = 'visible';
        console.log("Audio graph connected for visualizer and EQ.");
    }
}

function disconnectAudioGraph() {
    if (source) {
        try {
            // Disconnect the source from the processing graph (EQ/analyser).
            // The HTMLAudioElement will now play directly to the speakers by default.
            source.disconnect();
        } catch(e) { /* Fails if not connected, which is fine */ }
        document.getElementById('visualizerCanvas').style.visibility = 'hidden';
        console.log("Audio graph disconnected for CORS track. Visualizer/EQ disabled.");
    }
}
        
async function removeFolder(folderName) {
    if (!confirm(`Are you sure you want to remove the folder "${folderName}"? All songs from this folder will be removed from your library.`)) {
        return;
    }

    directoryHandles = directoryHandles.filter(h => h.name !== folderName);
    
    const findableSongIds = new Set();
    for (const song of songs) {
        if (song.storage === 'indexeddb') {
             findableSongIds.add(song.id);
             continue;
        }
        let found = false;
        for (const handle of directoryHandles) {
             try {
                 await handle.getFileHandle(song.handleName);
                 findableSongIds.add(song.id);
                 found = true;
                 break; 
             } catch (e) { /* Not in this handle */ }
        }
    }
    
    songs = songs.filter(s => findableSongIds.has(s.id));

    const tx = db.transaction('config', 'readwrite');
    tx.objectStore('config').put({ key: 'directoryHandles', value: directoryHandles });
    await tx.done;
    
    await saveSongs();
    openManageFoldersModal(); 
}

        async function deleteSong(songIdToDelete) {
            const songIndex = songs.findIndex(s => s.id === songIdToDelete);
            if (songIndex === -1) return;
        
            const songToDelete = songs[songIndex];
            if (songToDelete.storage === 'indexeddb') {
                const tx = db.transaction('musicFiles', 'readwrite');
                tx.objectStore('musicFiles').delete(songIdToDelete);
                await tx.done;
            }
        
            songs.splice(songIndex, 1);
            await saveSongs();
        
            if (songIdToDelete === currentSongId) {
                playNextSong(); 
            } else {
                updatePlayQueue();
            }
        }
        
        function openEditModal(songId) {
            const song = songs.find(s => s.id === songId);
            if (!song) return;
        
            editSongId.value = song.id;
            editTitle.value = song.name;
            editArtist.value = song.artist;
            editAlbum.value = song.album;
            openModal(editModal);
        }

        async function saveMetadataChanges() {
            const songId = parseFloat(editSongId.value);
            const song = songs.find(s => s.id === songId);
            if (!song) return;

            song.name = editTitle.value;
            song.artist = editArtist.value;
            song.album = editAlbum.value;

            if (song.id === currentSongId) {
                musicTitle.textContent = sanitize(song.name);
                musicArtist.textContent = song.artist;
                document.title = `${song.name} by ${song.artist}`;
                updateMediaSessionMetadata(song);
            }

            await saveSongs();
            closeModal(editModal);
        }

        function openPlaylistModal() {
            const playlistList = document.getElementById('playlistList');
            playlistList.innerHTML = '';
            if (playlists.length > 0) {
                 playlists.forEach(p => {
                    const item = document.createElement('div');
                    item.className = 'menu-item';
                    item.textContent = p.name;
                    item.onclick = () => addSongToPlaylist(p.id);
                    playlistList.appendChild(item);
                });
            } else {
                playlistList.innerHTML = '<p style="color: var(--secondary-text-color); text-align: center;">No playlists to add to</p>';
            }
            openModal(playlistModal);
        }
    
async function fetchLyrics(songId) {
    const song = songs.find(s => s.id === songId);
    return song ? song.lyrics : null;
}

function addQueueItemEventListeners() {
    document.querySelectorAll('.queue-item').forEach(item => {
        item.addEventListener('click', (e) => {
            // Prevent click from propagating to the remove button
            if (e.target.closest('.remove-from-queue-btn')) return;

            const songId = parseFloat(item.dataset.id);
            const song = playQueue.find(s => s.id === songId);
            if (song) {
                playSong(song, playQueue);
            }
        });
    });

    document.querySelectorAll('.remove-from-queue-btn').forEach(btn => {
        btn.addEventListener('click', (e) => {
            e.stopPropagation();
            isQueueUserModified = true; // <-- ADD THIS LINE: Removing a song is a manual edit.
            const indexToRemove = parseInt(e.currentTarget.dataset.queueIndex, 10);
            
            if (playQueue[indexToRemove].id === currentSongId) {
                playQueue.splice(indexToRemove, 1);
                if (playQueue.length > 0) {
                    let nextIndex = indexToRemove >= playQueue.length ? 0 : indexToRemove;
                    currentQueueIndex = nextIndex - 1;
                    playNextSong();
                } else {
                    resetPlayer();
                }
            } else {
                playQueue.splice(indexToRemove, 1);
                if (indexToRemove < currentQueueIndex) currentQueueIndex--;
            }
            renderQueue();
        });
    });
}

function makeQueueItemsDraggable() {
    const container = document.querySelector('.queue-list-container');
    if (!container) return;
    let draggedQueueItem = null;

    container.querySelectorAll('.queue-item').forEach(item => {
        item.setAttribute('draggable', 'true');
        item.addEventListener('dragstart', () => {
            draggedQueueItem = item;
            setTimeout(() => item.classList.add('dragging'), 0);
        });
        item.addEventListener('dragend', () => {
            if (draggedQueueItem) {
                draggedQueueItem.classList.remove('dragging');
                draggedQueueItem = null;
                updateQueueFromDOM();
            }
        });
    });

    container.addEventListener('dragover', e => {
        e.preventDefault();
        const afterElement = getDragAfterElement(container, e.clientY);
        if (afterElement == null) {
            container.appendChild(draggedQueueItem);
        } else {
            container.insertBefore(draggedQueueItem, afterElement);
        }
    });
}

function getDragAfterElement(container, y) {
    const draggableElements = [...container.querySelectorAll('.queue-item:not(.dragging)')];
    return draggableElements.reduce((closest, child) => {
        const box = child.getBoundingClientRect();
        const offset = y - box.top - box.height / 2;
        if (offset < 0 && offset > closest.offset) {
            return { offset, element: child };
        } else {
            return closest;
        }
    }, { offset: Number.NEGATIVE_INFINITY }).element;
}

function updateQueueFromDOM() {
    isQueueUserModified = true; // Flag that the user has manually reordered the queue
    const newQueueOrder = [];
    document.querySelectorAll('.queue-item').forEach(item => {
        const songId = parseFloat(item.dataset.id);
        const song = songs.find(s => s.id === songId);
        if (song) newQueueOrder.push(song);
    });

    playQueue = newQueueOrder;
    currentQueueIndex = playQueue.findIndex(s => s.id === currentSongId);

    isShuffleEnabled = false;
    updateShuffleButtonState();
    
    renderQueue();
}
        
function playNextSong({ userInitiated = false, isTransition = false } = {}) {
    if (userInitiated && repeatMode === 'one') toggleRepeat();
    if (!userInitiated && !isTransition && repeatMode === 'one') {
        audioPlayer.currentTime = 0;
        audioPlayer.play().catch(e => console.error("Repeat-one playback failed", e));
        return;
    }
    if (!playQueue || playQueue.length === 0) return;
    currentQueueIndex++;
    if (currentQueueIndex >= playQueue.length) {
        if (repeatMode === 'all') currentQueueIndex = 0;
        else {
            resetPlayer();
            return;
        }
    }

    const nextSong = playQueue[currentQueueIndex];
    if (nextSong) {
        // Check song type and call the correct function
        if (nextSong.storage === 'soundcloud') {
            playSoundcloudTrack(nextSong.id, playQueue);
        } else if (nextSong.storage === 'youtube') {
            // Check if offline and skip YouTube tracks
            if (handleOfflineYouTubeTrack()) {
                return;
            }
            playYouTubeTrack(nextSong.videoId || nextSong.id, playQueue);
        } else {
            playSong(nextSong, playQueue, { isTransition });
        }
        proactivelyCacheNextInQueue();
    }
}
        
function playPreviousSong() {
    if (repeatMode === 'one') toggleRepeat();
    if (!playQueue.length) return;
    if (audioPlayer.currentTime > 5) {
        audioPlayer.currentTime = 0;
        audioPlayer.play().catch(e => console.error("Restart playback failed", e));
        return;
    }
    currentQueueIndex--;
    if (currentQueueIndex < 0) {
        currentQueueIndex = (repeatMode === 'all') ? playQueue.length - 1 : 0;
    }

    const prevSong = playQueue[currentQueueIndex];
    if (prevSong) {
        // Check song type and call the correct function
        if (prevSong.storage === 'soundcloud') {
            playSoundcloudTrack(prevSong.id, playQueue);
        } else if (prevSong.storage === 'youtube') {
            // Check if offline and skip YouTube tracks
            if (handleOfflineYouTubeTrack()) {
                return;
            }
            playYouTubeTrack(prevSong.videoId || prevSong.id, playQueue);
        } else {
            playSong(prevSong, playQueue, { isTransition: false });
        }
        proactivelyCacheNextInQueue();
    }
}

function cleanupBlobs() {
    songs.forEach(song => {
        if (song.url) URL.revokeObjectURL(song.url);
    });
}
   
function toggleShuffle() {
    isShuffleEnabled = !isShuffleEnabled;
    document.getElementById("shuffleBtn").classList.toggle("active", isShuffleEnabled);
    isQueueUserModified = false;
    updatePlayQueue();
}

function updateShuffleButtonState() {
    document.getElementById("shuffleBtn").classList.toggle("active", isShuffleEnabled);
}
        
function toggleRepeat() {
    const repeatBtn = document.getElementById('repeatBtn');
    switch(repeatMode) {
        case 'none':
            repeatMode = 'all';
            repeatBtn.innerHTML = '<span class="material-symbols-rounded">repeat</span>';
            repeatBtn.classList.add('active');
            break;
        case 'all':
            repeatMode = 'one';
            repeatBtn.innerHTML = '<span class="material-symbols-rounded">repeat_one</span>';
            break;
        case 'one':
            repeatMode = 'none';
            repeatBtn.innerHTML = '<span class="material-symbols-rounded">repeat</span>';
            repeatBtn.classList.remove('active');
            break;
    }
}
    
function updatePlayQueue() {
    if (isQueueUserModified) {
        currentQueueIndex = playQueue.findIndex(s => s.id === currentSongId);
        // Corrected check: if the queue panel is visible, re-render it
        if (isPanelVisible && panelContent === 'queue') {
            renderQueue();
        }
        return;
    }

    if (isShuffleEnabled) {
        let availableSongs = [...songs];
        let currentSong = currentSongId ? availableSongs.find(s => s.id === currentSongId) : null;
        if (currentSong) availableSongs = availableSongs.filter(s => s.id !== currentSongId);
        
        for (let i = availableSongs.length - 1; i > 0; i--) {
            const j = Math.floor(Math.random() * (i + 1));
            [availableSongs[i], availableSongs[j]] = [availableSongs[j], availableSongs[i]];
        }
        playQueue = currentSong ? [currentSong, ...availableSongs] : availableSongs;
    } else {
        const sortedSongs = [...songs].sort((a, b) => {
            const albumCompare = (a.albumArtist || '').localeCompare(b.albumArtist || '') 
                            || (a.album || '').localeCompare(b.album || '');
            if (albumCompare !== 0) return albumCompare;
            const discCompare = (a.effectiveDiscNumber || 1) - (b.effectiveDiscNumber || 1);
            if (discCompare !== 0) return discCompare;
            return (a.trackNumber || 0) - (b.trackNumber || 0);
        });
        playQueue = sortedSongs;
    }
    
    currentQueueIndex = playQueue.findIndex(s => s.id === currentSongId);
    // Corrected check: if the queue panel is visible, re-render it
    if (isPanelVisible && panelContent === 'queue') {
        renderQueue();
    }
}
        
function groupSongsByAlbum(songsToRender) {
  const albums = {};
  
  songsToRender.forEach(song => {
    const albumArtistName = song.albumArtist || song.artist || 'Unknown Artist';
    const albumName = song.album || 'Unknown Album';
    const albumKey = `${albumArtistName}::${albumName}::${song.effectiveDiscNumber}`;

    if (!albums[albumKey]) {
      const albumDisplayName = song.effectiveDiscNumber > 1 ? `${albumName} (Disc ${song.effectiveDiscNumber})` : albumName;
      albums[albumKey] = {
        name: albumDisplayName,
        artist: albumArtistName,
        year: song.year,
        albumArt: song.albumArt,
        songs: [],
        originalAlbum: albumName,
        originalAlbumArtist: albumArtistName,
        effectiveDiscNumber: song.effectiveDiscNumber,
        dateAdded: 0 
      };
    }
    albums[albumKey].songs.push(song);
  });
  
  for (let key in albums) {
      albums[key].dateAdded = Math.max(...albums[key].songs.map(s => s.dateAdded || 0));
      albums[key].songs.sort((a, b) => (a.trackNumber || 0) - (b.trackNumber || 0));
  }
  
  let albumArray = Object.values(albums);
  
  if (currentSortMode === 'dateAdded') {
      albumArray.sort((a, b) => b.dateAdded - a.dateAdded);
  } else { // 'alpha'
      albumArray.sort((a, b) => {
         const artistCompare = a.originalAlbumArtist.localeCompare(b.originalAlbumArtist);
         if (artistCompare !== 0) return artistCompare;
         const albumCompare = a.originalAlbum.localeCompare(b.originalAlbum);
         if (albumCompare !== 0) return albumCompare;
         return a.effectiveDiscNumber - b.effectiveDiscNumber;
      });
  }
  return albumArray;
}

async function updateMediaSessionMetadata(song) {
    if (!('mediaSession' in navigator) || !song || !song.albumArt) return;

    if (currentMediaSessionArtBlobUrl) {
        URL.revokeObjectURL(currentMediaSessionArtBlobUrl);
        currentMediaSessionArtBlobUrl = null;
    }

    let artworkSrc = song.albumArt;

    if (song.albumArt.startsWith('data:')) {
        try {
            const response = await fetch(song.albumArt);
            const blob = await response.blob();
            artworkSrc = URL.createObjectURL(blob);
            currentMediaSessionArtBlobUrl = artworkSrc;
        } catch (e) {
            console.error("Failed to create blob URL for media session artwork", e);
        }
    }

    navigator.mediaSession.metadata = new MediaMetadata({
        title: song.name,
        artist: song.artist,
        album: song.album,
        artwork: [
            { src: artworkSrc, sizes: '96x96', type: 'image/png' },
            { src: artworkSrc, sizes: '128x128', type: 'image/png' },
            { src: artworkSrc, sizes: '192x192', type: 'image/png' },
            { src: artworkSrc, sizes: '256x256', type: 'image/png' },
            { src: artworkSrc, sizes: '384x384', type: 'image/png' },
            { src: artworkSrc, sizes: '512x512', type: 'image/png' },
        ]
    });
}

function updateMediaSessionPlaybackState(state) {
    if ('mediaSession' in navigator) navigator.mediaSession.playbackState = state;
}

function updateMediaSessionPositionState() {
    if (!('mediaSession' in navigator) || isNaN(audioPlayer.duration)) return;
    navigator.mediaSession.setPositionState({
        duration: audioPlayer.duration,
        playbackRate: audioPlayer.playbackRate,
        position: audioPlayer.currentTime,
    });
}

function setupMediaSessionActions() {
    if (!('mediaSession' in navigator)) return;

    navigator.mediaSession.setActionHandler('play', () => playPauseBtn.click());
    navigator.mediaSession.setActionHandler('pause', () => playPauseBtn.click());
    navigator.mediaSession.setActionHandler('nexttrack', () => playNextSong({ userInitiated: true }));
    navigator.mediaSession.setActionHandler('previoustrack', () => playPreviousSong());
    navigator.mediaSession.setActionHandler('stop', () => resetPlayer());

    navigator.mediaSession.setActionHandler('seekforward', (d) => { audioPlayer.currentTime = Math.min(audioPlayer.currentTime + (d.seekOffset || 10), audioPlayer.duration); });
    navigator.mediaSession.setActionHandler('seekbackward', (d) => { audioPlayer.currentTime = Math.max(audioPlayer.currentTime - (d.seekOffset || 10), 0); });
    navigator.mediaSession.setActionHandler('seekto', (d) => { audioPlayer.currentTime = d.seekTime; });
}
        
window.addEventListener("beforeunload", () => {
    if (currentSongId !== null) {
        localStorage.setItem("currentSong", JSON.stringify({
            id: currentSongId,
            progress: audioPlayer.currentTime
        }));
    } else {
        localStorage.removeItem("currentSong");
    }
});

window.addEventListener("load", async () => {
    try {
        if (isMobile) {
            document.body.classList.add('is-mobile');
        }
        
        await initDB();
        initModalVariables();

        if ('showDirectoryPicker' in window) {
            const tx = db.transaction('config', 'readonly');
            const handleReq = tx.objectStore('config').get('directoryHandles');
            const configResult = await new Promise(r => { handleReq.onsuccess = () => r(handleReq.result) });
            
            if (configResult && Array.isArray(configResult.value)) {
                const verifiedHandles = [];
                for (const handle of configResult.value) {
                    if (await verifyPermission(handle, false)) { // Don't prompt on load
                        verifiedHandles.push(handle);
                    }
                }
                directoryHandles = verifiedHandles;
                console.log(`Restored and verified ${directoryHandles.length} folder handles.`);
            }
        }

        // --- Load Integration Settings ---
        const configTx = db.transaction('config', 'readonly');
        const scIdReq = configTx.objectStore('config').get('soundcloudClientId');
        const scEnabledReq = configTx.objectStore('config').get('isSoundcloudEnabled');
        const ytKeyReq = configTx.objectStore('config').get('youtubeApiKey');
        const ytEnabledReq = configTx.objectStore('config').get('isYoutubeEnabled');
        
        const scIdResult = await new Promise(r => { scIdReq.onsuccess = () => r(scIdReq.result) });
        const scEnabledResult = await new Promise(r => { scEnabledReq.onsuccess = () => r(scEnabledReq.result) });
        const ytKeyResult = await new Promise(r => { ytKeyReq.onsuccess = () => r(ytKeyReq.result) });
        const ytEnabledResult = await new Promise(r => { ytEnabledReq.onsuccess = () => r(ytEnabledReq.result) });
        
        soundcloudClientId = scIdResult ? scIdResult.value : '';
        isSoundcloudEnabled = scEnabledResult ? scEnabledResult.value : false;
        youtubeApiKey = ytKeyResult ? ytKeyResult.value : '';
        isYoutubeEnabled = ytEnabledResult ? ytEnabledResult.value : false;
        toggleIntegrationsTab();
        
        // Initialize YouTube player if enabled
        if (isYoutubeEnabled) {
            initYouTubePlayer();
        }

        await loadSongsAndPlaylists();
        await scanForNewSongs();
        await migrateToFSA();

        const savedData = localStorage.getItem("currentSong");
        if (savedData) {
            const { id, progress } = JSON.parse(savedData);
            const song = songs.find(s => s.id === id);
            if (song) {
                updatePlayerUI(song);
                updateMiniplayerUI(song, 'paused');
                playPauseIcon.textContent = 'play_arrow';
                playPauseBtn.classList.remove('playing');
                currentSongId = song.id;
                isQueueUserModified = false;
                updatePlayQueue();
                const fileUrl = await getSongFileUrl(song);
                if (fileUrl) {
                    audioPlayer.src = fileUrl;
                    audioPlayer.load();
                    audioPlayer.onloadedmetadata = () => {
                         audioPlayer.currentTime = progress || 0;
                         updateTimeDisplays();
                         audioPlayer.onloadedmetadata = null;
                    };
                }
            }
        }
        
        setView('home');
    } catch (error) {
        console.error('Critical error on application load:', error);
    }
});

async function verifyPermission(handle, shouldRequest = false) {
    const options = { mode: 'read' };
    if (await handle.queryPermission(options) === 'granted') return true;
    if (shouldRequest && await handle.requestPermission(options) === 'granted') return true;
    console.warn(`Permission not granted for folder: ${handle.name}`);
    return false;
}

        function updatePlayerUI(song, progress = 0) {
            musicTitle.textContent = sanitize(song.name);
            musicArtist.textContent = song.artist;
            albumArtImg.src = song.albumArt;
            albumArtImg.classList.remove('fade-out');
            updateAllBackgrounds(song.albumArt);
            updateFavicon(song.albumArt);
            updateTimeDisplays(progress, audioPlayer.duration);
            
            // Hide lyrics button for online tracks (SoundCloud/YouTube)
            const lyricsButton = document.querySelector('.lyrics-button');
            if (song.storage === 'soundcloud' || song.storage === 'youtube') {
                lyricsButton.style.display = 'none';
                // If the lyrics panel is open, close it as it's no longer relevant
                if (isPanelVisible && panelContent === 'lyrics') {
                    closePanel();
                }
            } else {
                // Use an empty string to revert to the stylesheet's default display property
                lyricsButton.style.display = ''; 
            }
        }

        function updateTimeDisplays(current = 0, duration = 0) {
            currentTimeDisplay.textContent = formatTime(current);
            durationDisplay.textContent = formatTime(duration);
        }

let currentLrcLineIndex = -1;

audioPlayer.addEventListener('timeupdate', async () => {
    if (currentSongId) {
        const song = currentlyPlayingSong;
        const percentage = (audioPlayer.currentTime / audioPlayer.duration) * 100;
        progress.style.width = `${percentage}%`;
        const scaledPercentage = (percentage / 100) * 93;
        miniplayerProgress.style.width = `${scaledPercentage}%`;
        updateTimeDisplays(audioPlayer.currentTime, audioPlayer.duration);
        updatePageTitle();

        // Only log plays for local songs
        if (song && song.storage !== 'soundcloud' && song.storage !== 'youtube' && !song.hasBeenLogged && audioPlayer.currentTime > 30) {
            song.hasBeenLogged = true;
            await logSongPlay(song.id);
        }

        if (audioPlayer.duration) Gurasuraisu.updateMediaProgress({ currentTime: audioPlayer.currentTime, duration: audioPlayer.duration });
        if ('mediaSession' in navigator) updateMediaSessionPositionState();
        if (crossfadeEnabled && audioPlayer.duration > 0 && audioPlayer.duration - audioPlayer.currentTime < 3 && !audioPlayer.isFading) {
             audioPlayer.isFading = true;
             playNextSong({ isTransition: true });
        }

        if (song && song.lrcData && isPanelVisible && panelContent === 'lyrics') {
            const currentTime = audioPlayer.currentTime;
            let newLrcLineIndex = -1;

            for (let i = 0; i < song.lrcData.length; i++) {
                if (song.lrcData[i].time <= currentTime) newLrcLineIndex = i;
                else break;
            }
            
            if (newLrcLineIndex !== currentLrcLineIndex) {
                const allLyricElements = document.querySelectorAll('#lyrics-scroll-container p');
                if(allLyricElements.length === 0) return;

                const MAX_BLUR = 5.0, BLUR_STEP = 1.5, MIN_OPACITY = 0.4, OPACITY_STEP = 0.2;
                
                allLyricElements.forEach((el, index) => {
                    const distance = Math.abs(index - newLrcLineIndex);
                    const blurValue = (distance === 0) ? 0 : Math.min(MAX_BLUR, distance * BLUR_STEP);
                    const opacityValue = (distance === 0) ? 1 : Math.max(MIN_OPACITY, 1 - distance * OPACITY_STEP);
                    el.style.filter = `blur(${blurValue}px)`;
                    el.style.opacity = opacityValue;
                });

                const newLine = document.getElementById(`lyric-line-${newLrcLineIndex}`);
                if (newLine) newLine.scrollIntoView({ behavior: 'smooth', block: 'start' });

                currentLrcLineIndex = newLrcLineIndex;
            }
        }
    }
});

playPauseBtn.addEventListener('click', () => {
    if (audioContext && audioContext.state === 'suspended') audioContext.resume();
    if (!currentSongId) return;

    if (!isVisualizerInitialized) initVisualizer();

    if (audioPlayer.paused) {
        if ('mediaSession' in navigator && navigator.mediaSession.metadata === null) {
            const song = currentlyPlayingSong;
            if (song) {
                updateMediaSessionMetadata(song);
                Gurasuraisu.registerMediaSession(
                    { title: song.name, artist: song.artist, album: song.album, artwork: [{ src: song.albumArt }] },
                    ['playPause', 'next', 'prev']
                );
            }
        }
        
        // Handle YouTube tracks differently
        if (currentlyPlayingSong && currentlyPlayingSong.storage === 'youtube') {
            if (youtubePlayer && isYoutubePlayerReady) {
                youtubePlayer.playVideo();
                playPauseIcon.textContent = 'pause';
                playPauseBtn.classList.add('playing');
                updateMiniplayerUI(currentlyPlayingSong, 'playing');
                if (!document.body.classList.contains('reduce-animations')) {
                    document.querySelector('.background-blur').classList.add('rotating');
                }
                updateMediaSessionPlaybackState('playing');
                Gurasuraisu.updatePlaybackState({ playbackState: 'playing' });
            }
        } else {
            // Handle local and SoundCloud tracks
            audioPlayer.play().then(() => {
                playPauseIcon.textContent = 'pause';
                playPauseBtn.classList.add('playing');
                updateMiniplayerUI(currentlyPlayingSong, 'playing');
                if (!document.body.classList.contains('reduce-animations')) {
                    document.querySelector('.background-blur').classList.add('rotating');
                }
                updateMediaSessionPlaybackState('playing');
                Gurasuraisu.updatePlaybackState({ playbackState: 'playing' });
            }).catch(error => console.error("Play failed:", error));
        }
    } else {
        // Handle YouTube tracks differently
        if (currentlyPlayingSong && currentlyPlayingSong.storage === 'youtube') {
            if (youtubePlayer && isYoutubePlayerReady) {
                youtubePlayer.pauseVideo();
                playPauseIcon.textContent = 'play_arrow';
                playPauseBtn.classList.remove('playing');
                updateMiniplayerUI(currentlyPlayingSong, 'paused');
                updateMediaSessionPlaybackState('paused');
                Gurasuraisu.updatePlaybackState({ playbackState: 'paused' });
            }
        } else {
            // Handle local and SoundCloud tracks
            audioPlayer.pause();
            playPauseIcon.textContent = 'play_arrow';
            playPauseBtn.classList.remove('playing');
            updateMiniplayerUI(currentlyPlayingSong, 'paused');
            updateMediaSessionPlaybackState('paused');
            Gurasuraisu.updatePlaybackState({ playbackState: 'paused' });
        }
    }
});
        
nextBtn.addEventListener('click', () => playNextSong({ userInitiated: true }));
prevBtn.addEventListener('click', () => playPreviousSong());

function seekAudio(e) {
    if(isNaN(audioPlayer.duration)) return;
    const rect = progressBar.getBoundingClientRect();
    const clickX = Math.max(0, Math.min(e.clientX, rect.right)) - rect.left;
    const percent = Math.max(0, Math.min(1, clickX / rect.width));
    audioPlayer.currentTime = percent * audioPlayer.duration;
}

function handleProgressDrag(e) { if (isDragging) seekAudio(e.touches ? e.touches[0] : e); }

function closePanel() {
    if (!isPanelVisible) return;
    isPanelVisible = false;
    document.getElementById('lyrics-queue-panel').classList.remove('visible');
    document.querySelector('.lyrics-button').classList.remove('active');
    document.querySelector('.queue-button').classList.remove('active');
}
        
progressBar.addEventListener("click", e => seekAudio(e));
progressBar.addEventListener("mousedown", () => { isDragging = true; });
document.addEventListener("mouseup", () => { isDragging = false; });
document.addEventListener("mousemove", e => handleProgressDrag(e));
progressBar.addEventListener("touchstart", () => { isDragging = true; }, { passive: true });
document.addEventListener("touchend", () => { isDragging = false; });
document.addEventListener("touchmove", e => handleProgressDrag(e), { passive: true });


volumeSlider.addEventListener('input', (e) => {
    const volume = e.target.value / 100;
    audioPlayer.volume = volume;
    if (volume === 0) volumeIcon.textContent = 'volume_mute';
    else if (volume < 0.5) volumeIcon.textContent = 'volume_down';
    else volumeIcon.textContent = 'volume_up';
});

audioPlayer.addEventListener('play', () => {
    if (!document.body.classList.contains('reduce-animations')) {
        document.querySelector('.background-blur').classList.add('rotating');
    }
});

audioPlayer.addEventListener('ended', () => {
    audioPlayer.isFading = false;
    playNextSong(); 
});

document.addEventListener('DOMContentLoaded', async () => {
    try {
        await initDB();
        searchInput = document.getElementById('searchInput');
        const musicUploadInput = document.getElementById('musicUpload');
        const libraryGrid = document.getElementById('library-grid');
        
        searchInput.addEventListener('input', () => {
            clearTimeout(searchTimeout);
            searchTimeout = setTimeout(() => {
                if (activeView === 'search') {
                    renderSearchResults();
                }
            }, 300);
        });

        document.getElementById('search-results-grid').addEventListener('click', (e) => {
            const songItem = e.target.closest('.music-item[data-id]');
            if (songItem) {
                const songId = parseFloat(songItem.dataset.id);
                const song = songs.find(s => s.id === songId);
                if (song) {
                    // Get context from the search results
                    const contextSongs = Array.from(document.querySelectorAll('#search-results-grid .music-item[data-id]'))
                        .map(item => songs.find(s => s.id === parseFloat(item.dataset.id)))
                        .filter(Boolean);

                    isShuffleEnabled = false; 
                    updateShuffleButtonState();
                    
                    playSong(song, contextSongs);
                }
            }
        });
        
        document.getElementById('home-view').addEventListener('click', (e) => {
            const highlightCard = e.target.closest('.highlight-card[data-id]');
            const albumCard = e.target.closest('.item-card[data-album-id]');
    
            if (highlightCard) {
                const songId = parseFloat(highlightCard.dataset.id);
                const song = songs.find(s => s.id === songId);
                if (song) {
                    // Play this single song as its own context
                    playSong(song, [song]);
                }
            } else if (albumCard) {
                const albumId = albumCard.dataset.albumId;
                const [artist, albumName] = albumId.split('::');
                // When playing from a "Recently Played" album card, play the first song of that album
                const songToPlay = songs.find(s => s.albumArtist === artist && s.album === albumName);
                if(songToPlay) {
                    // The context is all songs from that album
                    const albumContext = songs.filter(s => s.albumArtist === artist && s.album === albumName);
                    playSong(songToPlay, albumContext);
                }
            }
        });

        libraryGrid.addEventListener('click', (e) => {
            const songItem = e.target.closest('.music-item[data-id]');
            const albumCard = e.target.closest('.item-card[data-album-id]');
            const artistCard = e.target.closest('.item-card[data-artist-name]');
            const playlistCard = e.target.closest('.item-card[data-playlist-id]');

            if (songItem) {
                const songId = parseFloat(songItem.dataset.id);
                const song = songs.find(s => s.id === songId);
                if (song) {
                    // Get the context from the currently displayed list
                    const contextSongs = Array.from(libraryGrid.querySelectorAll('.music-item[data-id]'))
                        .map(item => songs.find(s => s.id === parseFloat(item.dataset.id)))
                        .filter(Boolean);
                    isShuffleEnabled = false; 
                    updateShuffleButtonState();
                    playSong(song, contextSongs);
                }
            } else if (albumCard) {
                const albumId = albumCard.dataset.albumId;
                const [artist, albumName] = albumId.split('::');
                const albumSongs = songs.filter(s => s.albumArtist === artist && s.album === albumName).sort((a,b) => (a.trackNumber || 0) - (b.trackNumber || 0));
                const contentHtml = `<div class="item-list">${albumSongs.map(song => `
                    <div class="music-item" data-id="${song.id}" style="cursor: pointer; position: relative;">
                        <div class="song-info">
                            <span class="track-number">${song.trackNumber || ''}</span>
                            <div class="song-title">${sanitize(song.name)}</div>
                            <button class="song-item-actions" data-id="${song.id}"><span class="material-symbols-rounded" style="font-size: 10px;">circle</span></button>
                        </div>
                        ${(song.storage === 'soundcloud' || song.storage === 'youtube') ? '<div class="cloud-indicator"><span class="material-symbols-rounded">cloud</span></div>' : ''}
                    </div>`).join('')}</div>`;
                openDrawer(albumName, artist, contentHtml);
            } else if (artistCard) {
                const artistName = artistCard.dataset.artistName;
                const artistAlbums = groupSongsByAlbum(songs.filter(s => s.artist === artistName));
                const contentHtml = `<div class="item-grid">${artistAlbums.map(album => `
                    <div class="item-card" data-album-id="${album.artist}::${album.originalAlbum}">
                        <img src="${album.albumArt}" alt="${album.name}" class="item-card-art">
                        <div class="item-card-info">
                            <div class="item-card-title">${sanitize(album.name)}</div>
                        </div>
                    </div>`).join('')}</div>`;
                openDrawer(artistName, `${artistAlbums.length} albums`, contentHtml); // Pass details
            } else if (playlistCard) {
                 const playlistId = parseInt(playlistCard.dataset.playlistId, 10);
                 const playlist = playlists.find(p => p.id === playlistId);
                 const playlistSongs = playlist.songIds.map(id => songs.find(s => s.id === id)).filter(Boolean);
                 const contentHtml = `<div class="item-list">${playlistSongs.map(song => `
                    <div class="music-item" data-id="${song.id}" style="cursor: pointer; position: relative;">
                         <div class="song-info">
                            <img src="${song.albumArt}" class="album-thumbnail" style="width: 40px; height: 40px; border-radius: 8px; margin-right: 6px;">
                            <div>
                                <div class="song-title">${sanitize(song.name)}</div>
                                <div class="album-artist" style="font-size: 0.8em;">${sanitize(song.artist)}</div>
                            </div>
                        </div>
                        ${(song.storage === 'soundcloud' || song.storage === 'youtube') ? '<div class="cloud-indicator"><span class="material-symbols-rounded">cloud</span></div>' : ''}
                    </div>`).join('')}</div>`;
                openDrawer(playlist.name, `${playlistSongs.length} songs`, contentHtml); // Pass details
            }
        });

        drawerContent.addEventListener('click', (e) => {
            const localSongItem = e.target.closest('.music-item[data-id]');
            const soundcloudSongItem = e.target.closest('.music-item[data-track-id]');
            const songItem = e.target.closest('.music-item[data-id]');
            const albumCard = e.target.closest('.item-card[data-album-id]');
            const backButton = e.target.closest('.drawer-back-btn'); // Correctly find the button

            if (backButton) {
                const artistName = backButton.dataset.artistName;
                const artistAlbums = groupSongsByAlbum(songs.filter(s => s.artist === artistName));
                const contentHtml = `<div class="item-grid">${artistAlbums.map(album => {
                    const albumId = `${album.artist}::${album.originalAlbum}`;
                    return `
                    <div class="item-card" data-album-id="${sanitize(albumId)}">
                        <img src="${album.albumArt}" alt="${sanitize(album.name)}" class="item-card-art">
                        <div class="item-card-info">
                            <div class="item-card-title">${sanitize(album.name)}</div>
                        </div>
                    </div>`;
                }).join('')}</div>`;
                openDrawer(sanitize(artistName), `${artistAlbums.length} albums`, contentHtml);
            } else if (localSongItem) {
                // Logic for playing a local song from the library
                const songId = parseFloat(localSongItem.dataset.id);
                const song = songs.find(s => s.id === songId);
                if (song) {
                    const contextSongs = Array.from(drawerContent.querySelectorAll('.music-item[data-id]'))
                        .map(item => songs.find(s => s.id === parseFloat(item.dataset.id)))
                        .filter(Boolean);
                    playSong(song, contextSongs);
                    closeDrawer();
                }
            } else if (soundcloudSongItem) {
                // Build the context from all SoundCloud songs currently in the drawer
                const trackId = soundcloudSongItem.dataset.trackId;
                const contextNodes = drawerContent.querySelectorAll('.music-item[data-track-id]');
                const playContext = Array.from(contextNodes).map(node => ({
                    id: Number(node.dataset.trackId),
                    name: node.querySelector('.song-title').textContent,
                    artist: node.querySelector('.album-artist').textContent,
                    albumArt: node.querySelector('img').src,
                    storage: 'soundcloud'
                }));
                playSoundcloudTrack(trackId, playContext);
                closeDrawer();
            } else if (albumCard) {
                const albumId = albumCard.dataset.albumId;
                const [artist, albumName] = albumId.split('::');
                const albumSongs = songs.filter(s => s.albumArtist === artist && s.album === albumName).sort((a,b) => (a.trackNumber || 0) - (b.trackNumber || 0));
                
                // This now includes the back button in the generated HTML
                const contentHtml = `
                    <button class="action-btn drawer-back-btn" data-artist-name="${sanitize(artist)}"><span class="material-symbols-rounded">arrow_back</span> Back</button>
                    <div class="item-list" style="margin-top: 15px;">
                        ${albumSongs.map(song => `
                        <div class="music-item" data-id="${song.id}" style="cursor: pointer; position: relative;">
                            <div class="song-info">
                                <span class="track-number">${song.trackNumber || ''}</span>
                                <div class="song-title">${sanitize(song.name)}</div>
                            </div>
                            ${(song.storage === 'soundcloud' || song.storage === 'youtube') ? '<div class="cloud-indicator"><span class="material-symbols-rounded">cloud</span></div>' : ''}
                        </div>`).join('')}
                    </div>`;
                
                document.getElementById('drawer-title').textContent = sanitize(albumName);
                document.getElementById('drawer-subtitle').textContent = sanitize(artist);
                drawerContent.innerHTML = contentHtml;
            }
        });

        document.getElementById('uploadBtn').addEventListener('click', async () => {
            if ('showDirectoryPicker' in window) {
                try {
                    const handle = await window.showDirectoryPicker();
                    if (await verifyPermission(handle, true)) {
                        directoryHandles.push(handle);
                        const tx = db.transaction('config', 'readwrite');
                        tx.objectStore('config').put({ key: 'directoryHandles', value: directoryHandles });
                        await tx.done;
                        await processDirectory(handle);
                    }
                } catch (err) {
                    if (err.name !== 'AbortError') console.error('Error picking directory:', err);
                }
            } else {
                musicUploadInput.click();
            }
        });

        musicUploadInput.addEventListener('change', (e) => {
            if (e.target.files.length > 0) addSongs(e.target.files, 'indexeddb');
        });
        
        document.querySelectorAll('.filter-container .filter-btn').forEach(btn => {
            btn.addEventListener('click', () => {
                document.querySelector('.filter-container .filter-btn.active').classList.remove('active');
                btn.classList.add('active');
                currentFilter = btn.dataset.filter;
                if (activeView === 'library') renderLibraryPage();
            });
        });

        const sortBtn = document.getElementById('sortBtn');
        const sortModeDisplay = document.getElementById('sort-mode-display');

        sortBtn.addEventListener('click', () => {
            // Toggle the sort mode
            currentSortMode = currentSortMode === 'alpha' ? 'dateAdded' : 'alpha';
            
            // Update the button's appearance
            if (currentSortMode === 'alpha') {
                sortBtn.innerHTML = `<span class="material-symbols-rounded">sort_by_alpha</span><span id="sort-mode-display"></span>`;
            } else {
                sortBtn.innerHTML = `<span class="material-symbols-rounded">history</span><span id="sort-mode-display"></span>`;
            }
            
            // Re-render the library with the new sorting
            renderLibraryPage();
        });
        
        const handleSongActionsClick = (e) => {
            const actionButton = e.target.closest('.song-item-actions');
            if (actionButton) {
                e.stopPropagation(); // Prevent the song from playing
                const songId = parseFloat(actionButton.dataset.id);
                openSongContextMenu(e, songId);
            }
        };

        // ADD listener for the new "Save to Library" button
        document.getElementById('menuSaveToLibrary').addEventListener('click', () => {
            if (currentlyPlayingSong) {
                if (currentlyPlayingSong.storage === 'soundcloud') {
                    saveSoundcloudTrackToLibrary();
                } else if (currentlyPlayingSong.storage === 'youtube') {
                    saveYouTubeTrackToLibrary();
                }
            }
            moreOptionsMenu.classList.remove('visible');
        });
    
        // ADD listener for the offline search input
        document.getElementById('soundcloudOfflineSearchInput').addEventListener('input', renderOfflineSoundcloudView);
    
        // ADD listeners for the new filter buttons
        document.getElementById('soundcloud-filter-container').addEventListener('click', (e) => {
            const btn = e.target.closest('.filter-btn-sc');
            if (btn) {
                document.querySelector('#soundcloud-filter-container .filter-btn-sc.active').classList.remove('active');
                btn.classList.add('active');
                soundcloudFilter = btn.dataset.filter;
                renderSoundcloudSearchResults();
            }
        });
        
        document.getElementById('library-grid').addEventListener('click', handleSongActionsClick);
        document.getElementById('search-results-grid').addEventListener('click', handleSongActionsClick);
        drawerContent.addEventListener('click', handleSongActionsClick);

        shardContainer = document.getElementById('distortion-container');
        initializeShards(); 
        initVisualizer();
        // YouTube player will be initialized after settings are loaded
        setupMediaSessionActions();

        document.getElementById('shuffleBtn').addEventListener('click', toggleShuffle);
        document.getElementById('repeatBtn').addEventListener('click', toggleRepeat);

        const lyricsQueuePanel = document.getElementById('lyrics-queue-panel');
        isPanelVisible = false;
        panelContent = null; // 'lyrics' or 'queue'

        const togglePanel = (newContent) => {
            if (isPanelVisible && panelContent === newContent) {
                closePanel();
            } else {
                // Show or switch the panel
                isPanelVisible = true;
                panelContent = newContent;
                if (panelContent === 'lyrics') {
                    renderLyrics();
                } else {
                    renderQueue();
                    scrollToCurrentSongInQueue();
                }
                lyricsQueuePanel.classList.add('visible');
            }
            document.querySelector('.lyrics-button').classList.toggle('active', isPanelVisible && panelContent === 'lyrics');
            document.querySelector('.queue-button').classList.toggle('active', isPanelVisible && panelContent === 'queue');
        };

        document.querySelector('.lyrics-button').addEventListener('click', () => togglePanel('lyrics'));
        document.querySelector('.queue-button').addEventListener('click', () => togglePanel('queue'));
                
        tabBtns.forEach(btn => {
            btn.addEventListener('click', () => {
                if (isDrawerOpen) {
                    closeDrawer();
                    return; 
                }
                const viewName = btn.dataset.view;
                const currentViewElement = document.getElementById(`${activeView}-view`);
                if (currentViewElement) {
                    scrollPositions[activeView] = currentViewElement.scrollTop;
                }
                setView(viewName);
            });
        });
    
        miniplayer.addEventListener('click', (e) => {
            if (e.target.closest('.mini-control-btn')) return;
        
            const currentViewElement = document.getElementById(`${activeView}-view`);
            if (currentViewElement) {
                scrollPositions[activeView] = currentViewElement.scrollTop;
            }
        
            setView('now-playing');
        });
        
        // Wire up miniplayer controls
        miniplayerPlayBtn.addEventListener('click', (e) => {
            e.stopPropagation();
            playPauseBtn.click();
        });
        document.getElementById('miniplayer-next-btn').addEventListener('click', (e) => {
            e.stopPropagation();
            nextBtn.click();
        });
        document.getElementById('miniplayer-prev-btn').addEventListener('click', (e) => {
            e.stopPropagation();
            prevBtn.click();
        });

        const nowPlayingView = document.getElementById('now-playing-view');
        const moreButton = nowPlayingView.querySelector('.more-button');
        const moreOptionsMenu = document.getElementById('moreOptionsMenu');

        moreButton.addEventListener('click', (e) => {
            e.stopPropagation();
            if (!currentSongId || !currentlyPlayingSong) {
                Gurasuraisu.showPopup('No song is currently playing');
                return;
            }
            
            const isLocal = currentlyPlayingSong.storage !== 'soundcloud' && currentlyPlayingSong.storage !== 'youtube';
            const isOnline = currentlyPlayingSong.storage === 'soundcloud' || currentlyPlayingSong.storage === 'youtube';
        
            // Show/hide menu items based on song type
            document.getElementById('menuEditMetadata').style.display = isLocal ? 'flex' : 'none';
            document.getElementById('menuDeleteSong').style.display = isLocal ? 'flex' : 'none';
            document.getElementById('menuAddToPlaylist').style.display = isLocal ? 'flex' : 'none';

            // Show "Save to Library" for online songs (SoundCloud/YouTube).
            document.getElementById('menuSaveToLibrary').style.display = isOnline ? 'flex' : 'none';
                    
            moreOptionsMenu.classList.toggle('visible');
        });

        document.addEventListener('click', (e) => {
            // Close menu if clicking outside of it or its trigger button
            if (!e.target.closest('#moreOptionsMenu') && !e.target.closest('.more-button')) {
                moreOptionsMenu.classList.remove('visible');
            }
        });

        document.getElementById('menuDeleteSong').addEventListener('click', async () => {
            if (currentSongId && confirm('Delete this song? This is permanent.')) await deleteSong(currentSongId);
            moreOptionsMenu.classList.remove('visible');
        });

        document.getElementById('menuFullscreenBtn').addEventListener('click', () => {
            isFullscreen = !isFullscreen; // Toggle the state
            toolbar.classList.toggle('hidden', isFullscreen); // Update toolbar based on new state
        });
        
        document.getElementById('menuEditMetadata').addEventListener('click', () => { if (currentSongId) openEditModal(currentSongId); moreOptionsMenu.classList.remove('visible'); });
        document.getElementById('menuCrossfade').addEventListener('click', toggleCrossfade);
        document.getElementById('menuSleepTimer').addEventListener('click', () => { openModal(sleepTimerModal); moreOptionsMenu.classList.remove('visible'); });
        document.getElementById('menuAddToPlaylist').addEventListener('click', () => { if (currentSongId) openPlaylistModal(); moreOptionsMenu.classList.remove('visible'); });
        document.getElementById('menuEqualizer').addEventListener('click', () => { openModal(equalizerModal); moreOptionsMenu.classList.remove('visible'); });

        document.getElementById('shuffleBtn').addEventListener('click', toggleShuffle);
        document.getElementById('repeatBtn').addEventListener('click', toggleRepeat);

        document.getElementById('manageFoldersBtn').addEventListener('click', openManageFoldersModal);
        document.getElementById('saveIntegrations').addEventListener('click', saveIntegrationsSettings);

        const soundcloudSearchInput = document.getElementById('soundcloudSearchInput');
        soundcloudSearchInput.addEventListener('input', () => {
            clearTimeout(soundcloudSearchTimeout);
            soundcloudSearchTimeout = setTimeout(searchIntegrations, 300);
        });
        
        document.getElementById('soundcloud-results-grid').addEventListener('click', e => {
            const trackCard = e.target.closest('.item-card[data-track-id]');
            const videoCard = e.target.closest('.item-card[data-video-id]');
            const cachedCard = e.target.closest('.music-item[data-cached-id]');
            const artistCard = e.target.closest('.item-card[data-artist-name]');
            const albumCard = e.target.closest('.item-card[data-album-name]');
        
            if (trackCard) {
                // Build the context from the current search results
                if (lastSoundcloudSearchResults && lastSoundcloudSearchResults.length > 0) {
                    const playContext = lastSoundcloudSearchResults.map(track => ({
                        id: track.id,
                        name: track.title,
                        artist: track.user.username,
                        album: 'SoundCloud',
                        albumArt: getHighResArtwork(track.artwork_url),
                        storage: 'soundcloud'
                    }));
                    playSoundcloudTrack(trackCard.dataset.trackId, playContext);
                }
            } else if (videoCard) {
                // Build the context from the current search results
                if (lastYoutubeSearchResults && lastYoutubeSearchResults.length > 0) {
                    const playContext = lastYoutubeSearchResults.map(video => ({
                        id: video.id,
                        name: parseYouTubeTitle(video.snippet.title),
                        artist: video.snippet.channelTitle,
                        album: video.snippet.title,
                        albumArt: video.snippet.thumbnails.high.url,
                        storage: 'youtube'
                    }));
                    playYouTubeTrack(videoCard.dataset.videoId, playContext);
                }
            } else if (cachedCard) {
                const trackId = parseFloat(cachedCard.dataset.cachedId);
                // When playing from offline view, the context is all other visible offline songs
                const contextNodes = document.querySelectorAll('#soundcloud-results-grid .music-item[data-cached-id]');
                const playContext = Array.from(contextNodes).map(node => {
                    return {
                        id: parseFloat(node.dataset.cachedId),
                        name: node.querySelector('.song-title').textContent,
                        artist: node.querySelector('.album-artist').textContent,
                        albumArt: node.querySelector('img').src,
                        storage: 'soundcloud'
                    };
                });
                playSoundcloudTrack(trackId, playContext);
            } else if (artistCard) {
                // An artist was clicked in the online search view
                const artistName = artistCard.dataset.artistName;
                if (lastSoundcloudSearchResults && lastSoundcloudSearchResults.length > 0) {
                    const artistTracks = lastSoundcloudSearchResults.filter(t => t.user.username === artistName);
                
                const contentHtml = `<div class="item-list">${artistTracks.map(track => { // <-- track is defined here
                    // **THE FIX:** Use the 'track' object from the map, not 'songObject'.
                    const artwork = getHighResArtwork(track.artwork_url);
                    return `
                    <div class="music-item" data-track-id="${track.id}" style="cursor: pointer;">
                         <div class="song-info">
                            <img src="${artwork}" class="album-thumbnail" style="width: 40px; height: 40px; border-radius: 8px; margin-right: 6px;">
                            <div>
                                <div class="song-title">${sanitize(track.title)}</div>
                                <div class="album-artist" style="font-size: 0.8em;">${sanitize(track.user.username)}</div>
                            </div>
                        </div>
                    </div>
                    `}).join('')}</div>`;
                
                openDrawer(artistName, `${artistTracks.length} tracks found`, contentHtml);
                }
            } else if (albumCard) {
                // An album was clicked in the online search view
                const albumName = albumCard.dataset.albumName;
                if (lastSoundcloudSearchResults && lastSoundcloudSearchResults.length > 0) {
                    const albumTracks = lastSoundcloudSearchResults.filter(t => t.title.split('-')[0].trim() === albumName);
                    const representativeArtist = albumTracks.length > 0 ? albumTracks[0].user.username : '';
            
                    const contentHtml = `<div class="item-list">${albumTracks.map(track => { // <-- track is defined here
                        // **THE FIX:** Use the 'track' object from the map, not 'songObject'.
                        const artwork = getHighResArtwork(track.artwork_url);
                        return `
                        <div class="music-item" data-track-id="${track.id}" style="cursor: pointer;">
                             <div class="song-info">
                                <img src="${artwork}" class="album-thumbnail" style="width: 40px; height: 40px; border-radius: 8px; margin-right: 6px;">
                                <div>
                                    <div class="song-title">${sanitize(track.title)}</div>
                                    <div class="album-artist" style="font-size: 0.8em;">${sanitize(track.user.username)}</div>
                                </div>
                            </div>
                        </div>
                        `}).join('')}</div>`;
            
                    openDrawer(albumName, representativeArtist, contentHtml);
                }
            }
        });
    
        // Add the new listener for the offline toggle
        document.getElementById('soundcloudOfflineToggle').addEventListener('click', () => {
            isSoundcloudOfflineMode = !isSoundcloudOfflineMode;
            renderSoundcloudPage();
        });

        setupDrawerInteractions();
    } catch (error) {
        console.error('Failed to initialize application:', error);
    }
});

document.getElementById('uploadBtn').addEventListener('click', async () => {
    if ('showDirectoryPicker' in window) {
        try {
            const handle = await window.showDirectoryPicker();
            
            for (const existingHandle of directoryHandles) {
                if (await handle.isSameEntry(existingHandle)) {
                    Gurasuraisu.showPopup("This folder has already been added.");
                    return;
                }
            }

            if (await verifyPermission(handle, true)) {
                directoryHandles.push(handle);
                const tx = db.transaction('config', 'readwrite');
                tx.objectStore('config').put({ key: 'directoryHandles', value: directoryHandles });
                await tx.done;
                await processDirectory(handle);
            }
        } catch (err) {
            if (err.name !== 'AbortError') console.error('Error picking directory:', err);
        }
    } else {
        document.getElementById('musicUpload').click();
    }
});

        musicUpload.addEventListener('change', (e) => {
            if (e.target.files.length > 0) addSongs(e.target.files, 'indexeddb');
        });
        
        async function processDirectory(handle) {
            const filesToAdd = [];
            const existingSongNames = new Set(songs.map(s => s.handleName));

            for await (const entry of handle.values()) {
                if (entry.kind === 'file' && isAudioFile({ name: entry.name }) && !existingSongNames.has(entry.name)) {
                    filesToAdd.push(entry);
                }
            }

            if (filesToAdd.length > 0) {
                Gurasuraisu.showPopup(`${filesToAdd.length} new songs added to Library`);
                await addSongs(filesToAdd, 'filesystem');
            } else {
                Gurasuraisu.showPopup('No new songs found in the selected directory.');
            }
        }

        function toggleCrossfade() {
            crossfadeEnabled = !crossfadeEnabled;
            document.getElementById('crossfadeStatus').textContent = crossfadeEnabled ? 'On' : 'Off';
        }

        function setSleepTimer(minutes) {
            clearTimeout(sleepTimerId);
            if (minutes > 0) {
                sleepTimerId = setTimeout(() => {
                    audioPlayer.pause();
                    playPauseIcon.textContent = 'play_arrow';
                    playPauseBtn.classList.remove('playing');
                }, minutes * 60 * 1000);
                Gurasuraisu.showPopup(`Sleep timer set for ${minutes} minutes.`);
            } else {
                Gurasuraisu.showPopup('Sleep timer cancelled.');
            }
            closeModal(sleepTimerModal);
        }
        
async function loadSongsAndPlaylists() {
    try {
        const songTx = db.transaction('songs', 'readonly');
        const songRequest = songTx.objectStore('songs').getAll();
        const loadedSongs = await new Promise((resolve, reject) => {
            songRequest.onsuccess = () => resolve(songRequest.result);
            songRequest.onerror = () => reject(songRequest.error);
        });
        
        songs = Array.isArray(loadedSongs) ? loadedSongs : [];
        songs.forEach(song => { if (!song.dateAdded) song.dateAdded = song.id; });
        processAndSortSongs();

        const playlistTx = db.transaction('playlists', 'readonly');
        const playlistRequest = playlistTx.objectStore('playlists').getAll();
        const loadedPlaylists = await new Promise((resolve, reject) => {
            playlistRequest.onsuccess = () => resolve(playlistRequest.result);
            playlistRequest.onerror = () => reject(playlistRequest.error);
        });
        playlists = Array.isArray(loadedPlaylists) ? loadedPlaylists : [];
        
        console.log(`Loaded ${songs.length} songs and ${playlists.length} playlists.`);

    } catch (error) {
        console.error("Failed to load data from IndexedDB:", error);
        songs = []; playlists = [];
    }
}

        async function createPlaylistAndAddSong() {
            const newName = document.getElementById('newPlaylistName').value.trim();
            if (!newName) return;
            if (!currentSongId) return Gurasuraisu.showPopup("Please play a song first.");
        
            const newPlaylist = { name: newName, songIds: [currentSongId] };
            
            try {
                const tx = db.transaction('playlists', 'readwrite');
                const request = tx.objectStore('playlists').add(newPlaylist);
                await new Promise((resolve, reject) => {
                    request.onerror = () => reject(request.error);
                    tx.oncomplete = () => {
                        newPlaylist.id = request.result;
                        resolve();
                    };
                });
        
                playlists.push(newPlaylist);
                document.getElementById('newPlaylistName').value = '';
                closeModal(playlistModal);
                Gurasuraisu.showPopup(`Added song to new playlist "${newName}"`);
            } catch (error) {
                console.error("Failed to create playlist:", error);
            }
        }

        async function addSongToPlaylist(playlistId) {
            const playlist = playlists.find(p => p.id === playlistId);
            if (!playlist || !currentlyPlayingSong) return;
        
            const songToAdd = currentlyPlayingSong;
            
            if (!playlist.songIds.includes(songToAdd.id)) {
                playlist.songIds.push(songToAdd.id);
                
                // If it's a SC song, ensure it's cached so we have its metadata for later
                if (songToAdd.storage === 'soundcloud') {
                    const tx = db.transaction('soundcloudCache', 'readonly');
                    const checkReq = await promiseIDBRequest(tx.objectStore('soundcloudCache').get(songToAdd.id));
                    if (!checkReq) {
                        // If not cached, cache it now.
                        await cacheSoundcloudTrack(songToAdd, songToAdd.streamUrl);
                    }
                }
                
                const writeTx = db.transaction('playlists', 'readwrite');
                writeTx.objectStore('playlists').put(playlist);
                await writeTx.done;
                Gurasuraisu.showPopup(`Added to "${playlist.name}"`);
            } else {
                Gurasuraisu.showPopup(`Song is already in "${playlist.name}"`);
            }
            closeModal(playlistModal);
        }

        Gurasuraisu.onMediaControl({
            playPause: () => playPauseBtn.click(),
            next: () => nextBtn.click(),
            prev: () => prevBtn.click()
        });
    </script>
</body>
</html>
