<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
    <title>Streams</title>
    <link id="favicon" rel="icon" type="image/png" href="favicon.png">
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Material+Symbols+Rounded:opsz,wght,FILL,GRAD@24,700,1,0">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jsmediatags/3.9.5/jsmediatags.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/hls.js@latest"></script>
    <script src="https://polygol.github.io/assets/gurapp/api/gurasuraisu-api.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>
    <style>
        :root {
            --edge-refraction-filter: url('#edge-refraction-only');
            --sun-shadow: 0 0 0 0 transparent;
            
            /* Dark Theme (Default) Variables */
            --background-color-dark: #1c1c1c;
            --background-color-dark-tr: rgba(28, 28, 28, 0.7);
            --text-color-dark: #f9f9f9;
            --secondary-text-color-dark: rgba(255, 255, 255, 0.7);
            --modal-background-dark: rgba(51, 51, 51, 0.8);
            --modal-transparent-dark: rgba(51, 51, 51, 0.7);
            --search-background-dark: rgba(51, 51, 51, 0.5);
            --dark-overlay: rgba(51, 51, 51, 0.2);
            --dark-transparent: rgba(255, 255, 255, 0.1); 
            --glass-border-dark: rgba(100, 100, 100, 0.2);
            
            /* Light Theme Variables */
            --background-color-light: #f0f0f0;
        	--background-color-light-tr: rgba(240, 240, 240, 0.7);
            --text-color-light: #333333;
            --secondary-text-color-light: rgba(0, 0, 0, 0.7);
            --modal-background-light: rgba(220, 220, 220, 0.8);
            --modal-transparent-light: rgba(240, 240, 240, 0.7);
            --search-background-light: rgba(220, 220, 220, 0.5);
            --light-overlay: rgba(220, 220, 220, 0.2);
            --light-transparent: rgba(255, 255, 255, 0.1);
            --glass-border-light: rgba(200, 200, 200, 0.2);
            
            /* Default to Dark Theme */
            --background-color: var(--background-color-dark);
            --background-color-tr: var(--background-color-dark-tr);
            --text-color: var(--text-color-dark);
            --secondary-text-color: var(--secondary-text-color-dark);
            --modal-background: var(--modal-background-dark);
            --modal-transparent: var(--modal-transparent-dark);
            --search-background: var(--search-background-dark);
            --overlay-color: var(--dark-overlay);
            --transparent-color: var(--dark-transparent);
            --glass-border: var(--glass-border-dark);
        }
        
        body.light-theme {
            --background-color: var(--background-color-light);
            --background-color-tr: var(--background-color-light-tr);
            --text-color: var(--text-color-light);
            --secondary-text-color: var(--secondary-text-color-light);
            --modal-background: var(--modal-background-light);
            --modal-transparent: var(--modal-transparent-light);
            --search-background: var(--search-background-light);
            --overlay-color: var(--light-overlay);
            --transparent-color: var(--light-transparent);
            --glass-border: var(--glass-border-light);
        }
        
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: 'Inter', sans-serif;
            -webkit-tap-highlight-color: transparent;
        }
        
        body {
            background-color: var(--background-color-tr);
            min-height: 100vh;
            display: flex;
            user-select: none;
            position: relative;
            overflow: hidden;
            transition: background-color 0.3s, color 0.3s, background-image 0.5s;
            color: var(--text-color);
        }

        .toolbar {
            display: flex;
            justify-content: center;
            align-content: center;
            flex-direction: row;
            gap: 12px;
            padding: 15px 20px;
            background-color: transparent;
            border: none;
            position: fixed;
            top: 0px;
            left: 50%;
            transform: translateX(-50%);
            z-index: 1000;
            transition: top 0.3s ease;
            width: 100%;
            flex-wrap: wrap;
            height: 80px;
        }

        .toolbar.hidden {
            display: none;
        }

        .toolbar::before {
            content: "";
            position: absolute;
            inset: 0;
            z-index: -1;
        }

        .toolbar::after {
            content: "";
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: -2;
            backdrop-filter: blur(2.5px);
            mask-image: linear-gradient(to bottom, rgba(0, 0, 0, 1) 0%, rgba(0, 0, 0, 1) 50%, rgba(0, 0, 0, 0) 100%);
            -webkit-mask-image: linear-gradient(to bottom, rgba(0, 0, 0, 1) 0%, rgba(0, 0, 0, 1) 50%, rgba(0, 0, 0, 0) 100%);
        }

        .tab-btn {
            background-color: var(--search-background);
            color: transparent;
            border-radius: 35px;
            padding: 12px 16px;
            font-size: 0;
            cursor: pointer;
            transition: all 0.3s cubic-bezier(.3, 1.2, .64, 1) ! IMPORTANT;
            display: flex;
            align-items: center;
            backdrop-filter: var(--edge-refraction-filter) saturate(2) blur(2.5px);
            box-shadow: var(--sun-shadow);
            border: 1px solid var(--glass-border);
        }

        .tab-btn.active {
            background-color: var(--secondary-text-color);
            color: var(--background-color);
            border-radius: 35px;
            corner-shape: superellipse(1.5);
            font-family: 'Open Runde';
            font-weight: 500;
            padding: 10px 18px 10px 16px;
            font-size: revert;
            gap: 12px;
        }

        .toolbar .tab-btn .material-symbols-rounded {
            transition: color 0.3s;
            color: var(--text-color);
            font-size: 20px;
        }

        .toolbar .tab-btn.active .material-symbols-rounded {
            color: var(--background-color) !important;
        }

        .view-container {
            flex-grow: 1;
            width: 100%;
            padding: 80px 20px 0 20px;
            overflow-y: auto;
            overflow-x: hidden;
            min-height: 0;
        }

        .view-container::-webkit-scrollbar { width: 8px; }
        .view-container::-webkit-scrollbar-track { background: transparent; }
        .view-container::-webkit-scrollbar-thumb { background-color: var(--search-background); border-radius: 50px; }

        #now-playing-view {
            padding-top: 0;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        #bottom-miniplayer {
            position: fixed;
            bottom: 25px;
            left: 50%;
            transform: translateX(-50%);
            width: 95%;
            max-width: 528px;
            height: 64px;
            background-color: var(--search-background);
            border: 1px solid var(--glass-border);
            border-radius: 35px;
            corner-shape: superellipse(1.5);
            backdrop-filter: var(--edge-refraction-filter) saturate(2) blur(2.5px);
            display: flex;
            align-items: center;
            padding: 8px;
            gap: 12px;
            z-index: 1001;
            cursor: pointer;
            overflow: hidden;
            transition: all 0.3s cubic-bezier(.3,1.2,.64,1);
            box-shadow: var(--sun-shadow), 0 0 50px rgba(0, 0, 0, 0.2);
        }
        #bottom-miniplayer:active {
            transform: translateX(-50%) scale(1.05);
            transition: all 0.1s cubic-bezier(0.2, 0, 0.38, 0.9);
            filter: brightness(1.5);
        }
        #bottom-miniplayer.hidden {
            bottom: -100px;
            opacity: 0;
            pointer-events: none;
        }
        #miniplayer-art {
            width: 48px;
            height: 48px;
            border-radius: 20px;
            corner-shape: superellipse(1.5);
            box-shadow: 0 0 0 1px var(--glass-border);
            flex-shrink: 0;
        }
        .miniplayer-info {
            display: flex;
            flex-direction: column;
            gap: 2px;
            flex-grow: 1;
            min-width: 0;
            color: var(--text-color);
        }
        #miniplayer-title, #miniplayer-artist {
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }
        #miniplayer-title { font-weight: bold; font-size: 16px; font-family: 'Open Runde'; }
        #miniplayer-artist { font-size: 16px; color: var(--secondary-text-color); }

        .miniplayer-controls { display: flex; align-items: center; gap: 4px; padding-right: 8px; }
        .mini-control-btn {
            background: none;
            border: none;
            color: var(--text-color);
            width: 40px;
            height: 40px;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        .miniplayer-progress {
            position: absolute;
            bottom: 0;
            left: 3.5%;
            max-width: 93%;
            height: 2px;
            background-color: var(--secondary-text-color);
            width: 0%; /* JS will control this */
            transition: width 0.25s ease;
            border-radius: 5px;
        }

        /* Responsive miniplayer */
        #miniplayer-prev-btn, #miniplayer-next-btn { display: none; }
        @media (min-width: 500px) {
            #miniplayer-prev-btn, #miniplayer-next-btn { display: flex; }
        }

        /* Generic Grid for Home/Library/Search */
        .page-content-wrapper {
            width: 100%;
            max-width: 1400px;
            margin: 0 auto;
            display: flex;
            flex-direction: column;
            height: 0;
        }
        .section-title-fy {
            font-size: 1.5rem;
            font-weight: 600;
            margin-bottom: 10px;
        }
        .section-subtitle {
            font-size: 14px;
            padding: 8px 12px;
            background: var(--search-background);
            border: 1px solid var(--glass-border);
            width: fit-content;
            border-radius: 24px;
            margin-bottom: 20px;
        }
        .item-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(200px, 1fr));
            gap: 20px;
            padding-bottom: 125px;
        }
        @media (max-width: 480px) {
            .item-grid {
                grid-template-columns: repeat(auto-fill, minmax(150px, 1fr));
            }
        }
        .item-card {
            background-color: transparent; /* Cards will be minimal */
            border-radius: 12px;
            transition: all 0.2s ease;
            cursor: pointer;
            display: flex;
            flex-direction: column;
            gap: 10px;
            cursor: pointer;
            transform: scale(1);
            transition: all 0.15s cubic-bezier(0.2, 0, 0.38, 0.9);
        }
        .item-card-art {
            width: 100%;
            aspect-ratio: 1 / 1;
            box-shadow: 0 0 0 1px var(--glass-border);
            border-radius: 16px;
            corner-shape: superellipse(1.5);
            object-fit: cover;
        }
        .item-card-info { padding: 0 0 4px 0; }
        .item-card-title { font-weight: 500; font-family: 'Open Runde'; }
        .item-card-subtitle { font-size: 14px; color: var(--secondary-text-color); }
        .section-title {
            font-size: 1.5rem;
            font-weight: 600;
            margin-bottom: 20px;
        }
        .item-card:active {
            transform: scale(0.96);
            transition: all 0.1s cubic-bezier(0.2, 0, 0.38, 0.9);
            filter: brightness(1.5);
        }

        .library-controls {
            display: flex;
            flex-wrap: nowrap;
            gap: 10px;
            flex-direction: row;
            justify-content: center;
            align-content: center;
            position: fixed;
            left: 50%;
            transform: translateX(-50%);
            z-index: 1002;
            background-color: var(--search-background);
            backdrop-filter: var(--edge-refraction-filter) saturate(2) blur(2.5px);
            padding: 10px 12px;
            border-radius: 32px;
            border: 1px solid var(--glass-border);
            box-shadow: var(--sun-shadow), 0 0 15px rgba(0, 0, 0, 0.05);
            bottom: 100px;
        }

        @media (max-width: 560px) {
            #library-controls {
                flex-wrap: wrap;
            }
        }

        @media (max-width: 340px) {
            #tidal-controls {
                flex-wrap: wrap;
            }
        }

        .search-container {
            position: relative;
            flex-grow: 1;
            min-width: 200px;
            margin-bottom: 10px;
        }

        .library-search-input {
            width: 100%;
            padding: 10px 15px 10px 40px;
            border-radius: 25px;
            border: 1px solid var(--glass-border);
            background: var(--search-background);
            color: var(--text-color);
            backdrop-filter: var(--edge-refraction-filter) saturate(2) blur(2.5px);
            box-shadow: var(--sun-shadow);
            font-size: 14px;
            outline: none;
        }
        
        .search-icon {
            font-size: 22px;
            position: absolute;
            left: 15px;
            top: 50%;
            transform: translateY(-50%);
            color: var(--secondary-text-color);
            pointer-events: none;
        }

        .filter-container, .view-controls, .library-actions {
            display: flex;
            gap: 10px;
        }

        .filter-container .filter-btn, .filter-container .filter-btn-sc {
            padding: 8px 16px;
            height: 42px;
            border-radius: 10px;
            text-wrap-mode: nowrap;
        }

        .filter-container .filter-btn:active, .filter-container .filter-btn-sc:active {
            transform: scale(1);
            padding: 8px 20px;
            filter: brightness(1.5);
        }

        .filter-container .filter-btn.active, .filter-container .filter-btn-sc.active {
            background: var(--secondary-text-color);
            color: var(--background-color);
            border-radius: 25px !important;
            font-family: 'Open Runde';
            font-weight: 500;
        }
        
        .filter-container .filter-btn .material-symbols-rounded, .filter-container .filter-btn-sc .material-symbols-rounded{
            font-size: 22px;
        }
        
        .action-btn {
            background-color: var(--search-background);
            color: var(--text-color);
            border: none;
            border-radius: 50px;
            padding: 12px 18px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            backdrop-filter: var(--edge-refraction-filter) saturate(2) blur(2.5px);
            box-shadow: var(--sun-shadow);
            border: 1px solid var(--glass-border);
            font-weight: 500;
        }

        .library-action-btn {
            background-color: transparent;
            color: var(--text-color);
            border: none;
            border-radius: 50px;
            padding: 10px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            height: 42px;
        }

        .library-action-btn.active {
            background-color: var(--secondary-text-color);
            color: var(--background-color);
        }

          @keyframes fadeInOut {
            0% { opacity: 0; transform: translate(-50%, 20px); }
            10% { opacity: 1; transform: translate(-50%, 0); }
            90% { opacity: 1; transform: translate(-50%, 0); }
            100% { opacity: 0; transform: translate(-50%, -20px); }
          }
        
        .music-list::-webkit-scrollbar,
        #lyrics-queue-panel::-webkit-scrollbar,
        .lyrics-container::-webkit-scrollbar {
            width: 4px;
        }
                
        .music-list::-webkit-scrollbar-track,
        #lyrics-queue-panel::-webkit-scrollbar-track,
        .lyrics-container::-webkit-scrollbar-track {
            background: rgba(255, 255, 255, .0);
        }
        
        .music-list::-webkit-scrollbar-thumb,
        #lyrics-queue-panel::-webkit-scrollbar-thumb,
        .lyrics-container::-webkit-scrollbar-thumb {
            background: var(--modal-transparent);
            border-radius: 4px;
        } 

        #queue-list-container {
            gap: 10px;
            display: flex;
            flex-direction: column;
        }
        
        .upload-btn {
            background-color: var(--search-background);
            color: var(--text-color);
            backdrop-filter: var(--edge-refraction-filter) saturate(2) blur(2.5px);
            box-shadow: var(--sun-shadow);
            border-radius: 25px;
            padding: 10px 16px;
            cursor: pointer;
            transition: background-color 0.2s;
            display: flex; 
            align-items: center;
            border: 1px solid var(--glass-border);
            gap: 6px;
        }
        
        .music-list {
            display: flex;
            flex-direction: column;
            gap: 10px;
            overflow-y: auto;
            flex-grow: 1;
            border-radius: 10px;
        }

        .music-item.dragging, .album-section.dragging, .queue-item.dragging {
          opacity: 0.5;
          background-color: var(--modal-background);
          box-shadow: 0 0 15px rgba(0, 0, 0, 0.3);
          position: relative;
          z-index: 1000;
          transition: transform 0.1s ease;
          border-radius: 12px;
        }
        
        .music-item {
            box-shadow: var(--sun-shadow);
            padding: 8px 12px;
            background-color: var(--search-background);
            border: none;
            border-radius: 20px;
            corner-shape: superellipse(1.5);
            color: var(--text-color);
            cursor: pointer;
            transition: all 0.3s ease;
            border: 1px solid var(--glass-border);
            cursor: grab;
            touch-action: pan-y;
            overflow: hidden;
            min-height: fit-content;
            position: relative;
        }

        .queue-item {
            padding: 8px 1px;
            background-color: transparent;
            border: none;
            border-radius: 0;
            color: var(--text-color);
            cursor: pointer;
            transition: all 0.3s ease;
            cursor: grab;
            touch-action: pan-y;
            overflow: hidden;
            min-height: fit-content;
            position: relative;
            box-shadow: none;
        }
        
        .music-item.active {
            background-color: var(--background-color) !important;
            font-weight: bold;
            border-radius: 40px;
            transition: all 0.3s ease;
        }

        .queue-item.active {
            background-color: var(--search-background) !important;
            font-weight: bold;
            border-radius: 16px;
            transition: all 0.3s ease;
            padding: 5px 1px;
            border: 1px solid var(--glass-border);
            margin: 3px 0;
            backdrop-filter: var(--edge-refraction-filter) saturate(2) blur(2.5px);
            box-shadow: var(--sun-shadow);
        }

        .queue-item.active .song-title {
            font-family: 'Open Runde';
        }
            
        .album-art {
            border-radius: 12px;
            corner-shape: superellipse(1.5);
            background-color: var(--modal-transparent);
            display: flex;
            align-items: center;
            justify-content: center;
            overflow: hidden;
            transition: transform 0.3s cubic-bezier(.3,1.2,.64,1), opacity 0.3s ease;
            max-width: 600px;
            max-height: 600px;
            aspect-ratio: 1 / 1;
            box-shadow: 0 0 15px rgba(0, 0, 0, 0.05);
            margin-top: 80px;
            outline: 1px solid var(--glass-border);
            transform: scale(1);
        }

        #now-playing-view.paused .album-art {
            transform: scale(0.8);
        }

        .album-art.fade-out {
            opacity: 0;
            transform: scale(0.95);
        }
        
        .album-art img {
            width: 100%;
            height: 100%;
            object-fit: cover;
            border-radius: 12px;
            corner-shape: superellipse(1.5);
        }

        /* Generic Modal Styling */
        .modal-overlay {
            position: fixed;
            inset: 0;
            background-color: var(--overlay-color);
            z-index: 1003;
            display: flex;
            align-items: center;
            justify-content: center;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.3s ease;
        }

        .modal-overlay.visible {
            opacity: 1;
            pointer-events: auto;
        }
        
        .music-info {
            display: flex;
            justify-content: space-between;
            align-items: center;
            color: var(--text-color);
            text-align: left;
            max-width: 600px;
            width: 100%;
            transition: opacity 0.3s ease;
        }
        
        .music-text {
            display: flex;
            flex-direction: column;
            flex-grow: 1;
            gap: 8px;
            min-width: 0;
            padding-right: 16px;
            width: 0
        }
        
        .music-title {
            font-size: 1.3rem;
            word-wrap: break-word;
            font-weight: bold;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            line-height: 1.3;
            font-family: 'Open Runde';
        }
        
        .music-artist {
            color: var(--text-color);
            font-size: 0.9em;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            line-height: 1.3;
        }
        
        .more-button {
            background: var(--overlay-color);
            border: 1px solid var(--glass-border);
            cursor: pointer;
            color: var(--text-color);
            padding: 8px;
            border-radius: 50%;
            transition: background 0.2s ease;
            backdrop-filter: var(--edge-refraction-filter) saturate(2) blur(2.5px);
            box-shadow: var(--sun-shadow);
        }
        
        .quality-badge {
            display: inline-block;
            padding: 4px 12px;
            border-radius: 12px;
            font-size: 0.8em;
            font-weight: 500;
            margin-top: 5px;
            background: var(--search-background);
            color: var(--text-color);
        }
        
        .quality-lossless {
            background: rgba(189, 214, 255, .2);
            color: #bdd6ff;
        }
        
        .quality-enhanced {
            background: rgba(144, 238, 144, .2);
            color: #90ee90;
        }
        
        .quality-normal {
            background: rgba(255, 255, 255, .2);
            color: var(--text-color);
        }
                
        .player-controls {
            display: flex;
            align-items: center;
            justify-content: center;
            max-width: 600px;
            box-sizing: border-box;
            width: 100%;
            justify-content: space-between;
            margin-bottom: 80px;
            transition: opacity 0.3s ease;
        }
        
        .player-controls button:nth-child(2),
        .player-controls button:nth-child(3),
        .player-controls button:nth-child(4) {
            order: 1; /* Middle group gets priority */
        }
        
        .player-controls button:nth-child(1) {
            order: 0; /* Shuffle on the left */
        }
        
        .player-controls button:nth-child(5) {
            order: 2; /* Repeat on the right */
        }
                
        .control-btn {
            background: transparent;
            border: none;
            color: var(--text-color);
            width: 50px;
            height: 50px;
            border-radius: 35px;
            cursor: pointer;
            font-size: 1.2rem;
            transition: all 0.2s;
            display: flex;
            justify-content: center;
            align-items: center;
            line-height: 0;
        }
        
        .control-btn.play-pause {
            background-color: transparent;
            font-size: 1.5rem;
            transition: all 0.3s ease;
            border-radius: 35px;
            display: flex;
            justify-content: center;
            align-items: center;
            line-height: 0;
        }
        
        .control-btn.play-pause.playing {
            border-radius: 35px;
            corner-shape: superellipse(1.5);
        }
        
        .progress-container {
            display: flex;
            flex-direction: column;
            gap: 12px;
            width: 100%;
            max-width: 600px;
            transition: opacity 0.3s ease;
        }
        
        .progress-bar {
            width: 100%;
            height: 8px;
            background: var(--search-background);
            border-radius: 25px;
            cursor: pointer;
            transition: all 0.25s ease;
            backdrop-filter: var(--edge-refraction-filter) saturate(2) blur(2.5px);
            box-shadow: var(--sun-shadow), 0 0 0 1px var(--glass-border);
            overflow: hidden;
        }
        
        .progress {
            height: 100%;
            background: var(--secondary-text-color);
            border-radius: 25px;
            width: 0%;
            transition: all 0.25s ease;
            border: 1px solid var(--glass-border);
        }
        
        .time-info {
            display: flex;
            justify-content: space-between;
            color: var(--text-color);
            font-variant-numeric: tabular-nums;
            font-size: 0.9rem;
        }
        
        .controls-container {
            display: flex;
            align-items: center;
            gap: 12px;
            position: fixed;
            bottom: 30px;
            z-index: 10;
        }
        
        .controls-container span {
            color: var(--text-color);
            font-size: 18px;
        }

        #visualizerCanvas {
            width: 28px;
            height: 28px;
            vertical-align: middle;
        }

        .lyrics-button, .queue-button, .more-button {
            background: var(--search-background);
            border: 1px solid var(--glass-border);
            cursor: pointer;
            width: 37px;
            height: 37px;
            color: var(--text-color);
            border-radius: 50%;
            transition: all 0.2s;
            backdrop-filter: var(--edge-refraction-filter) saturate(2) blur(2.5px);
            box-shadow: var(--sun-shadow);
        }

        .goto-btn {
            background: var(--search-background);
            border: 1px solid var(--glass-border);
            cursor: pointer;
            padding: 10px 16px;
            color: var(--text-color);
            border-radius: 25px;
            transition: background 0.2s ease;
            backdrop-filter: var(--edge-refraction-filter) saturate(2) blur(2.5px);
            box-shadow: var(--sun-shadow);
        }

        .lyrics-button.active, .queue-button.active {
            background: var(--secondary-text-color);
            color: var(--background-color);
            border-radius: 25px;
            corner-shape: superellipse(1.5);
        }

        .lyrics-button.active .material-symbols-rounded, .queue-button.active .material-symbols-rounded {
            color: var(--background-color);
        }

        .volume-control {
            display: flex;
            align-items: center;
            gap: 10px;
            background: var(--search-background);
            border-radius: 25px;
            padding: 5px 10px 5px 10px;
            backdrop-filter: var(--edge-refraction-filter) saturate(2) blur(2.5px);
            box-shadow: var(--sun-shadow);
            border: 1px solid var(--glass-border);
            height: 37px;
            width: 100px;
        }
        
        .volume-control span {
            color: var(--text-color);
            font-size: 20px;
        }
        
        .volume-slider {
            width: 100%;
            height: 25px;
            -webkit-appearance: none;
            background: rgba(0, 0, 0, .0);
            outline: none;
        }
        
        .volume-slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 15px;
            height: 15px;
            background: var(--text-color);
            border-radius: 50%;
            cursor: pointer;
            border: 1px solid var(--glass-border);
            transition: width 0.3s, height 0.3s, transform 0.3s;
        }

        .volume-slider::-webkit-slider-thumb:active {
            width: 21px;
            height: 21px;
            transform: scale(1.1);
        }

        .volume-slider::-moz-range-thumb {
            width: 15px;
            height: 15px;
            border-radius: 50%;
            background: var(--text-color);
            cursor: pointer;
            border: 1px solid var(--glass-border);
            transition: width 0.3s, height 0.3s, transform 0.3s;
        }

        .volume-slider::-moz-range-thumb:active {
            width: 21px;
            height: 21px;
            transform: scale(1.1);
        }
        
        .album-section {
            padding: 20px 0 10px;
            border-top: 1.5px solid var(--glass-border);
        }

        .album-section::after {
          content: '';
          position: absolute;
          left: 0;
          right: 0;
          height: 2px;
          background: transparent;
          transition: background 0.3s;
        }
        
        .album-section.drag-over::after {
          background: var(--text-color);
        }
        
        .album-header {
            display: flex;
            align-items: center;
            gap: 15px;
            margin-bottom: 15px;
            cursor: grab;
            position: relative;
        }
        
        .album-thumbnail {
            width: 60px;
            height: 60px;
            border-radius: 25px;
            corner-shape: superellipse(1.5);
            object-fit: cover;
            box-shadow: 0 0 0 1px var(--glass-border);
        }
        
        .album-info {
            color: var(--text-color);
        }
        
        .album-name {
            font-weight: 600;
            font-size: 1.1em;
        }
        
        .album-artist, .album-year {
            color: var(--text-color);
            font-size: 0.9em;
        }
        
        .album-songs {
            display: flex;
            flex-direction: column;
            gap: 5px;
        }
        
        .song-info {
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        .track-number {
            color: var(--secondary-text-color);
            min-width: 25px;
            text-align: center;
            font-variant-numeric: tabular-nums;
        }
        
        .album-actions {
            position: absolute;
            right: 10px;
            top: 10px;
        }
        
        .delete-album {
            background: rgba(255, 0, 0, 0.8);
            color: white;
            border: none;
            border-radius: 50%;
            width: 36px;
            height: 36px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: background 0.2s;
        }
        
        .song-title {
            flex-grow: 1;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .drag-placeholder {
          height: 2px;
          background-color: var(--text-color);
          transition: all 0.2s ease;
        }
        
        @keyframes pulse {
          0% { box-shadow: 0 0 0 0 rgba(255, 255, 255, 0.4); }
          70% { box-shadow: 0 0 0 10px rgba(255, 255, 255, 0); }
          100% { box-shadow: 0 0 0 0 rgba(255, 255, 255, 0); }
        }
        
        .music-item.dragging, .album-section.dragging, .queue-item.dragging {
          animation: pulse 1.5s infinite;
        }
        
        .background-container {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            overflow: hidden;
            z-index: -9999;
        }
                        
        #distortion-container {
            position: fixed;
            inset: 0;
            overflow: hidden;
            z-index: -9998;
            filter: blur(clamp(25px, 2.5vw, 100px)) saturate(2) brightness(0.6);
            scale: 1.3;
            opacity: 1;
        }

        body.light-theme #distortion-container {
            opacity: 0.6; /* 60% opacity for light theme */
            filter: blur(clamp(25px, 2.5vw, 100px)) saturate(3) brightness(1);
        }

        html.gurasuraisu-high-contrast #distortion-container {
            opacity: 0.2 !important; /* 20% opacity for high contrast */
        }

        #distortionCanvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
        }
        
        @keyframes rotate {
            from {
                transform: scale(1.42) rotate(0deg);
            }
            to {
                transform: scale(1.42) rotate(360deg);
            }
        }
        
        .search-container {
            position: relative;
        }
        
        .search-input {
            width: 100%;
            padding: 10px 15px 10px 40px;
            border-radius: 25px;
            border: 1px solid var(--glass-border);
            background: var(--search-background);
            color: var(--text-color);
            backdrop-filter: var(--edge-refraction-filter) saturate(2) blur(2.5px);
            box-shadow: var(--sun-shadow);
            font-size: 14px;
            outline: none;
            transition: border-color 0.2s;
            flex-grow: 1;
        }
        
        .search-input:focus {
            border-color: var(--modal-background);
        }
        
        .search-input::placeholder {
            color: var(--secondary-text-color);
        }
        
        .search-icon {
            font-size: 20px;
            position: absolute;
            left: 12px;
            top: 50%;
            transform: translateY(-50%);
            color: var(--secondary-text-color);
            pointer-events: none;
            z-index: 1;
        }

        .filter-container {
            display: flex;
            gap: 6px;
            justify-content: center;
        }
        
        .filter-btn, .filter-btn-sc {
            flex: 1;
            padding: 8px 10px;
            border-radius: 20px;
            border: 1px solid var(--glass-border);
            background: var(--search-background);
            color: var(--secondary-text-color);
            font-size: 14px;
            cursor: pointer;
            transition: all 0.2s ease;
            backdrop-filter: var(--edge-refraction-filter) saturate(2) blur(2.5px);
            box-shadow: var(--sun-shadow);
        }
        
        .filter-btn.active, .filter-btn-sc.active {
            background: var(--secondary-text-color);
            color: var(--background-color);
        }

        .filter-separator {
            width: 3px;
            background: var(--search-background);
            border-radius: 5px;
            margin: 10px 5px;
        }
        
        #shuffleBtn, #repeatBtn {
            background: transparent;
            border: none;
            color: var(--text-color);
            width: 50px;
            height: 50px;
            border-radius: 50%;
            cursor: pointer;
            font-size: 1.2rem;
            transition: all 0.3s ease;
            display: flex;
            justify-content: center;
            align-items: center;
            line-height: 0;
            backdrop-filter: none;
            border: 1px solid transparent;
            box-shadow: none;
        }
        
        #shuffleBtn.active, #repeatBtn.active {
            backdrop-filter: var(--edge-refraction-filter) saturate(2) blur(2.5px);
            box-shadow: var(--sun-shadow);
            background: var(--search-background);
            border: 1px solid var(--glass-border);
        }
                
        .material-symbols-rounded {
          font-variation-settings:
          'FILL' 1,
          'wght' 700,
          'GRAD' 0,
          'opsz' 24;
          vertical-align: middle;
        }
        
        .no-results {
            color: var(--text-color);
            text-align: center;
            padding: 20px;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 10px;
        }
        
        .no-results .material-symbols-rounded {
            font-size: 48px;
        }
        
        .no-results p {
            font-size: 14px;
        }
        
        /* For all clickable elements */
        [onclick], 
        button, 
        a, 
        input[type="button"], 
        input[type="submit"],
        .clickable {
          cursor: pointer;
          transform: scale(1);
          transition: all 0.15s cubic-bezier(0.2, 0, 0.38, 0.9);
        }
        
        /* Active effect (when clicking down) */
        [onclick]:active, 
        button:active, 
        a:active, 
        input[type="button"]:active, 
        input[type="submit"]:active,
        .clickable:active {
          transform: scale(0.96);
          transition: all 0.1s cubic-bezier(0.2, 0, 0.38, 0.9);
          filter: brightness(1.5);
        }

        #tidalToggle, #lrclibToggle, #corsProxyToggle {
            appearance: none;
            width: 50px;
            height: 32px;
            background-color: rgba(0, 0, 0, 0.1);
            border-radius: 16px;
            position: relative;
            cursor: pointer;
            transition: background-color 0.3s;
            border: 1px solid var(--glass-border);
            cursor: pointer;
        }
        
        #tidalToggle::before, #lrclibToggle::before, #corsProxyToggle::before {
            content: '';
            position: absolute;
            width: 18px;
            height: 18px;
            background-color: var(--secondary-text-color);
            border-radius: 50%;
            top: 50%;
            left: 6px;
            transform: translateY(-50%);
            transition: transform 0.3s, background-color 0.3s, width 0.3s, height 0.3s, left 0.3s, right 0.3s;
            border: 1px solid var(--glass-border);
        }
        
        #tidalToggle:checked, #lrclibToggle:checked, #corsProxyToggle:checked {
            background-color: var(--secondary-text-color);
        }
        
        #tidalToggle:checked::before, #lrclibToggle:checked::before, #corsProxyToggle:checked::before {
            width: 22px;
            height: 22px;
            background-color: var(--background-color);
            left: 21px;
            transform: translateY(-50%);
        }

        @media (min-width: 560px) {
            .controls-container {
                position: fixed;
                bottom: 30px;
                right: 30px;
            }

            #lyrics-queue-panel {
                transform-origin: right bottom !important;
            }
        }
        
        @media (max-width: 800px) {
            .player-controls {
                gap: 15px;
            }
        }

        @media (min-width: 600px) {
            .drawer {
                left: 5vw !important;
                width: 90vw !important;
                border: 1px solid var(--glass-border);
            }
        }

        @media (min-width: 800px) {
            .drawer {
                left: 15vw !important;
                width: 70vw !important;
                border: 1px solid var(--glass-border);
            }
        }

        @media (min-width: 1000px) {
            .drawer {
                left: 25vw !important;
                width: 50vw !important;
                border: 1px solid var(--glass-border);
            }
        }

        @media (max-width: 560px) {
            #now-playing-view {
                padding: 0 10px 0 10px;
            }

            .music-info, .progress-container, .player-controls {
                padding: 0 10px !important;
            }
            
            .now-playing-wrapper {
                gap: 4vh !important;
            }

            #shuffleBtn, #repeatBtn {
                width: 30px;
                height: 30px;
                border-radius: 15px;
                corner-shape: superellipse(1.5);
            }
            
            .drawer {
                height: calc(100% - 80px); /* Full height minus top toolbar */
            }

            .player-controls {
                margin-bottom: 110px;
            }

            .controls-container {
                gap: 5px;
                bottom: 40px;
                width: 90%;
                justify-content: space-evenly;
                padding: 0 10px;
                max-width: 600px;
                width: 100%;
                transform: translateX(-50%);
                left: 50%;
            }

            .lyrics-button, .queue-button, .more-button {
                background: none;
                border: 1px solid transparent;
                backdrop-filter: none;
                box-shadow: none;
            }

            .volume-control {
                background: none;
                border: 1px solid transparent;
                backdrop-filter: none;
                box-shadow: none;
                padding: 0;
            }
            
            @media (max-height: 900px) {
                .now-playing-wrapper {
                    gap: 2vh !important;
                }

                .player-controls {
                    margin-bottom: 95px;
                }
            }
        }

        @media (max-width: 590px) {
            .toolbar {
                justify-content: flex-start;
            }

            .tab-btn {
                font-size: 0;
                padding: 12px 16px;
                gap: 0 !important;
            }
        
            .tab-btn.active {
                font-size: 0;
                padding: 12px 24px;
            }
        }
        
        /* When animations are disabled */
        .reduce-animations * {
            /* Disable all animations */
            animation: none !important;
        
            /* Disable all transitions except opacity */
            transition: opacity 0.3s ease !important;
            transition-property: opacity !important;
        }
        
        /* Special handling for clickable elements */
        .reduce-animations [onclick],
        .reduce-animations button,
        .reduce-animations a,
        .reduce-animations input[type="button"],
        .reduce-animations input[type="submit"],
        .reduce-animations .clickable {
            /* Keep initial state but remove transition */
            transform: scale(1) !important;
            transition: opacity 0.3s ease !important;
        }
        
        /* Keep active state functional but without animation */
        .reduce-animations [onclick]:active,
        .reduce-animations button:active,
        .reduce-animations a:active,
        .reduce-animations input[type="button"]:active,
        .reduce-animations input[type="submit"]:active,
        .reduce-animations .clickable:active {
            /* Apply scale instantly without transition */
            transform: scale(0.98) !important;
            transition: none !important;
            filter: brightness(1.5) !important;
        }
        
        /* Adjust for background image with light/dark theme */
        body[style*="background-image"] .music-title,
        body[style*="background-image"] .music-artist,
        body[style*="background-image"] .music-album,
        body[style*="background-image"] .time-info {
            text-shadow: 0 0 10px rgba(0, 0, 0, 0.5);
        }
        
        body.light-theme[style*="background-image"] .music-title,
        body.light-theme[style*="background-image"] .music-artist,
        body.light-theme[style*="background-image"] .music-album,
        body.light-theme[style*="background-image"] .time-info {
            text-shadow: 0 0 10px rgba(255, 255, 255, 0.5);
        }

        /* Lyrics and Queue styles */
        .sidebar-back-btn {
            background: var(--search-background);
            border: 1px solid var(--glass-border);
            backdrop-filter: var(--edge-refraction-filter) saturate(2) blur(2.5px);
            box-shadow: var(--sun-shadow);
            color: var(--text-color);
            cursor: pointer;
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 14px;
            padding: 8px 15px;
            border-radius: 25px;
            width: fit-content;
        }

        .lyrics-container {
            height: 100%;
            overflow-y: auto;
            scroll-behavior: smooth;
            scroll-padding-top: 30vh;
            padding-bottom: 70vh; /* Ensures last line can also scroll to the sweet spot */
        }

        .lyrics-container p {
            white-space: pre-wrap;
            transition: all 0.4s ease-out; /* Smooth transition for filter and opacity */
            margin: 18px 0;
            padding: 0 10px;
            border-radius: 14px;
            corner-shape: superellipse(1.5);
            cursor: pointer;
            font-size: 2rem;
            font-weight: 600;
            line-height: 1.4; /* Improves readability */
            font-family: 'Open Runde';
        }

        .lyrics-container p.lyric-aside {
            font-size: 1.25rem;
            font-weight: normal;
            color: var(--secondary-text-color);
            margin: -10px 0 18px 0;
            opacity: 0.8;
            cursor: default;
        }

        .lyrics-container #lyric-line-0 {
            padding-top: 30vh;
        }

        .lyrics-container p.active {
            background: var(--search-background);
            scale: 0.96;
        }
 
        .queue-item .song-info {
            display: flex;
            align-items: center;
            width: 100%;
            gap: 8px;
        }
        
        .queue-item .song-title {
            flex-grow: 1;
        }
        
        .queue-item .song-artist-queue {
            color: var(--secondary-text-color);
            font-size: 0.9em;
            flex-shrink: 0;
            max-width: 100px;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            box-shadow: none;
        }
        
        .remove-from-queue-btn {
            background: none;
            border: none;
            color: var(--secondary-text-color);
            cursor: pointer;
            padding: 10px 5px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            flex-shrink: 0;
            opacity: 0.5;
        }
        
        .queue-list-container {
            display: flex;
            flex-direction: column;
            gap: 10px; /* This adds the required space between queue items */
            padding-bottom: 50vh;
        }

        .more-options-menu {
            position: absolute;
            background-color: var(--search-background);
            border-radius: 35px;
            corner-shape: superellipse(1.5);
            padding: 8px 10px;
            backdrop-filter: var(--edge-refraction-filter) saturate(2) blur(2.5px);
            border: 1px solid var(--glass-border);
            z-index: 100;
            width: 200px;
            box-shadow: var(--sun-shadow), 0 4px 20px rgba(0,0,0,0.2);
            opacity: 0;
            transform: translateY(10px) scale(0.95) scaleY(0.9);
            pointer-events: none;
            transition: opacity 0.2s ease, transform 0.2s ease;
            transform-origin: bottom;
        }

        .more-options-menu.visible {
            opacity: 1;
            transform: translateY(0) scale(1);
            pointer-events: auto;
        }

        .context-menu {
            position: absolute;
            background-color: var(--search-background);
            border-radius: 35px;
            corner-shape: superellipse(1.5);
            padding: 8px 10px;
            backdrop-filter: var(--edge-refraction-filter) saturate(2) blur(2.5px);
            border: 1px solid var(--glass-border);
            z-index: 10001;
            width: auto;
            box-shadow: var(--sun-shadow), 0 4px 20px rgba(0,0,0,0.2);
            opacity: 0;
            transform: translateY(10px) scale(0.95) scaleY(0.9);
            pointer-events: none;
            transition: opacity 0.2s ease, transform 0.2s ease;
            transform-origin: top;
            margin: 10px;
        }

        .context-menu.visible {
            opacity: 1;
            transform: translateY(0) scale(1);
            pointer-events: auto;
        }

        .menu-item {
            display: flex;
            align-items: center;
            gap: 12px;
            padding: 10px;
            border-radius: 12px;
            corner-shape: superellipse(1.5);
            cursor: pointer;
            transition: background-color 0.2s ease;
        }

        .menu-item .material-symbols-rounded {
            font-size: 20px;
        }

        .menu-separator {
            height: 1px;
            background-color: var(--glass-border);
            margin: 8px 0;
        }

        .view-controls {
            display: flex;
            gap: 10px;
            align-items: center;
        }

        .now-playing-wrapper {
            flex-grow: 1;
            display: flex;
            flex-direction: column;
            gap: 2vh;
            justify-content: center;
            align-items: center;
            height: 100vh;
            width: 100%;
            max-width: 100vw;
            box-sizing: border-box;
            padding: 5px;
        }

        .player-column {
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            gap: 2vh;
            max-width: 600px;
            transition: max-width 0.4s ease;
        }
        
        #lyrics-queue-panel {
            height: 100%;
            max-height: 100vh;
            flex-shrink: 0;
            padding: 5px 5px 5px 20px;
            display: none;
            flex-direction: column;
            gap: 15px;
            opacity: 0;
            transform: translateX(20px);
            transition: all 0.3s cubic-bezier(.3,1.2,.64,1);
            pointer-events: none;
            overflow: auto;
            transform: translateX(20px) scale(0.9) scaleX(0.9);
            z-index: 5;
            width: 50%;
            transform-origin: right;
            filter: blur(1px);
            align-items: flex-start;
            justify-content: center;
        }
        
        #lyrics-queue-panel.visible {
            display: flex;
            opacity: 1;
            transform: translateX(0);
            pointer-events: auto;
            filter: none;
        }

        @media (min-width: 981px) {
            .lyrics-container {
                width: 100%;
                max-width: 600px;
                height: 70vh;
            }

            .now-queue {
                width: 100%;
                max-width: 600px;
                height: 70vh;
            }
        }

        @media (max-width: 980px) {
            #lyrics-queue-panel {
                height: calc(100vh - 160px);
                flex-shrink: 0;
                padding: 15px;
                display: flex;
                flex-direction: column;
                gap: 15px;
                opacity: 0;
                transform: translateX(20px);
                transition: all 0.3s cubic-bezier(.3,1.2,.64,1);
                pointer-events: none;
                overflow: auto;
                position: absolute;
                top: 50%;
                transform: translateY(-50%) scale(0.9) scaleY(0.9);
                z-index: 5;
                width: 100%;
                max-width: -webkit-fill-available;
                transform-origin: bottom;
                filter: blur(1px);
                margin: 0 2vw;
                align-items: center;
                justify-content: start;
            }

            #now-playing-view.panel-is-open .now-playing-wrapper > *:not(.controls-container):not(#moreOptionsMenu) {
                opacity: 0;
            }
            
            #lyrics-queue-panel.visible {
                opacity: 1;
                transform: translateY(-50%);
                pointer-events: auto;
                filter: none;
            }

            .lyrics-container {
                width: 100%;
                max-width: none;
            }

            .now-queue {
                width: 100%;
                max-width: none;
            }
        }

        /* --- Grid View Styles --- */
        .music-list.grid-view {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(140px, 1fr));
            gap: 15px;
            align-content: start;
        }

        .music-list.grid-view .music-item {
            height: max-content;
        }

        .music-list.grid-view .album-section {
            padding: 0;
            border-top: none; /* No dividers in grid view */
            display: flex;
            flex-direction: column;
            cursor: pointer; /* Albums are clickable in grid view */
        }
        
        .music-list.grid-view .album-header {
            margin-bottom: 8px;
            flex-direction: column;
            gap: 8px;
            cursor: default; /* No dragging albums in grid view */
        }

        .music-list.grid-view .album-thumbnail {
            width: 100%;
            height: auto;
            aspect-ratio: 1 / 1;
        }

        .music-list.grid-view .album-info {
            width: 100%;
            text-align: left;
        }

        .music-list.grid-view .album-name {
            font-size: 1em;
            white-space: normal;
        }
        
        .music-list.grid-view .album-artist {
            font-size: 0.85em;
        }
        
        .music-list.grid-view .album-year {
            display: none; /* Hide year in grid view for space */
        }

        .music-list.grid-view .album-songs {
            display: none; /* Hide individual songs in album grid view */
        }

        /* Song-level grid view */
        .music-list.grid-view.songs-mode .music-item,
        .music-list.grid-view.artists-mode .music-item {
             padding: 8px;
             display: flex;
             flex-direction: column;
             gap: 8px;
             align-items: center;
             text-align: center;
        }
        .music-list.grid-view.songs-mode .song-info,
        .music-list.grid-view.artists-mode .song-info {
            flex-direction: column;
            gap: 8px;
        }
        .music-list.grid-view.songs-mode .album-thumbnail,
        .music-list.grid-view.artists-mode .album-thumbnail {
            width: 100%;
            height: auto;
            aspect-ratio: 1 / 1;
            margin-right: 0;
        }
        .music-list.grid-view.songs-mode .song-title,
        .music-list.grid-view.artists-mode div[style*="font-size: 1em;"] {
            white-space: normal;
        }

        .item-list {
            display: flex;
            flex-direction: column;
            gap: 5px;
            padding-bottom: 125px;
        }
        .album-section-list {
            border-radius: 12px;
            cursor: pointer;
            padding: 10px;
        }
        .album-header-list {
            display: flex;
            align-items: center;
            gap: 15px;
        }

        /* --- Song Context Menu Styles --- */
        .music-item .song-actions,
        .album-header .song-actions {
            position: absolute;
            right: 8px;
            top: 50%;
            transform: translateY(-50%);
            color: var(--secondary-text-color);
            background: none;
            border: none;
            border-radius: 50%;
            width: 28px;
            height: 28px;
            display: flex;
            align-items: center;
            justify-content: center;
            opacity: 0.5;
            transition: opacity 0.2s, background-color 0.2s;
            z-index: 5;
            box-shadow: var(--sun-shadow);
        }

        /* App Drawer Styles */
        .drawer {
            position: fixed;
            bottom: -100%; /* Initially hidden */
            left: 0;
            width: 100%;
            background-color: var(--search-background); 
            z-index: 1004;
            overflow: hidden;
            touch-action: none;
            user-select: none;
            backdrop-filter: var(--edge-refraction-filter) saturate(2) blur(5px);
            box-shadow: var(--sun-shadow);
            border-top: 1px solid var(--glass-border);
            border-radius: 50px 50px 0 0;
            corner-shape: superellipse(1.5);
            transform-origin: bottom;
            will-change: transform, opacity, bottom;
            transition: all 0.3s cubic-bezier(.3,1.2,.64,1);
            max-height: calc(100% - 80px);
        }

        .drawer.open {
            bottom: 0;
        }

        .drawer-handle {
            width: 50px;
            height: 5px;
            background-color: var(--secondary-text-color);
            border-radius: 3px;
            position: absolute;
            top: 15px;
            left: 50%;
            transform: translateX(-50%);
            cursor: grab;
        }

        .drawer-content {
            max-height: calc(100vh - 150px);
            overflow-y: auto;
            user-select: none;
            padding: 20px 20px 0 20px;
        }
        
        .drawer-content::-webkit-scrollbar { width: 4px; }
        .drawer-content::-webkit-scrollbar-track { background: transparent; }
        .drawer-content::-webkit-scrollbar-thumb { background: var(--modal-transparent); border-radius: 4px; }
        
        .drawer-header {
            padding: 40px 20px 10px 20px;
            text-align: center;
        }
        #drawer-title { font-size: 1.5rem; }
        #drawer-subtitle { color: var(--secondary-text-color); }

        .highlight-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 20px;
            margin-bottom: 40px;
        }
        .highlight-card {
            background: linear-gradient(135deg, rgba(255,255,255,0.1), rgba(255,255,255,0));
            border: 1px solid var(--glass-border);
            border-radius: 35px;
            corner-shape: superellipse(1.5);
            padding: 10px 15px 10px 12px;
            display: flex;
            align-items: center;
            gap: 15px;
            cursor: pointer;
            transition: all 0.3s cubic-bezier(.3,1.2,.64,1);
            box-shadow: var(--sun-shadow);
        }
        .highlight-card:active {
            transform: scale(0.96);
            transition: all 0.1s cubic-bezier(0.2, 0, 0.38, 0.9);
            filter: brightness(1.5);
        }
        .highlight-card img {
            width: 80px;
            height: 80px;
            border-radius: 20px;
            corner-shape: superellipse(1.5);
            box-shadow: 0 0 0 1px var(--glass-border);
            flex-shrink: 0;
            transition: all 0.3s cubic-bezier(.3,1.2,.64,1);
        }
        .highlight-card-info {
            flex-grow: 1;
            min-width: 0;
            display: flex;
            flex-direction: column;
            justify-content: center;
            gap: 4px;
            transition: all 0.3s cubic-bezier(.3,1.2,.64,1);
        }
        .highlight-card-label {
            font-size: 12px;
            color: var(--secondary-text-color);
        }
        .highlight-card-title {
            font-size: 1.2rem;
            font-weight: 600;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            font-family: 'Open Runde';
        }
        .highlight-card-subtitle {
            color: var(--secondary-text-color);
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }
        .highlight-card-play {
            margin-left: auto;
            font-size: 36px;
            transition: all 0.3s cubic-bezier(.3,1.2,.64,1);
        }
        
        .song-item-actions {
            background: none;
            border: none;
            color: var(--secondary-text-color);
            margin-left: auto;
            padding: 5px;
            border-radius: 50%;
            cursor: pointer;
        }

        .loading-message {
            position: absolute;
            left: 50%;
            top: 50%;
        }

        #autoplayToggle {
            appearance: none;
            width: 38px;
            height: 24px;
            background-color: rgba(0, 0, 0, 0.1);
            border-radius: 12px;
            position: relative;
            cursor: pointer;
            transition: background-color 0.3s;
            border: 1px solid var(--glass-border);
        }
        
        #autoplayToggle::before {
            content: '';
            position: absolute;
            width: 15px;
            height: 15px;
            background-color: var(--secondary-text-color);
            border-radius: 50%;
            top: 50%;
            left: 3.5px;
            transform: translateY(-50%);
            transition: all 0.3s cubic-bezier(.3,1.2,.64,1);
        }
        
        #autoplayToggle:checked {
            background-color: var(--secondary-text-color);
        }
        
        #autoplayToggle:checked::before {
            background-color: var(--background-color);
            left: 16px;
            width: 18px;
            height: 18px;
        }

        #drawer-delete-playlist-btn {
            background: none;
            border: none;
            cursor: pointer;
            padding: 5px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: opacity 0.2s, background-color 0.2s;
            color: var(--text-color);
        }
    </style>
</head>
<body data-app-name="STREAMS">
    <svg style="position: absolute; width: 0; height: 0;">
        <filter id="albumArtDistortion">
            <feTurbulence 
                id="turbulence"
                type="turbulence" 
                baseFrequency="0.01 0.02" 
                numOctaves="1" 
                seed="0"
            />
            <feGaussianBlur stdDeviation="30" result="blurredTurbulence"/>
            <feDisplacementMap 
                id="displacement"
                in="SourceGraphic" 
                in2="blurredTurbulence" 
                scale="0" 
                xChannelSelector="R" 
                yChannelSelector="G"
            />
        </filter>
    </svg>

    <svg style="display: none">
        <filter id="edge-refraction-only" color-interpolation-filters="linearRGB">
            <!-- Part 1: Generate the edge turbulence pattern -->
            <feTurbulence type="fractalNoise" baseFrequency="0.04" numOctaves="2" result="turbulence"></feTurbulence>
            <feMorphology in="SourceGraphic" operator="erode" radius="4" result="eroded"></feMorphology>
            <feComposite in="SourceGraphic" in2="eroded" operator="out" result="border_mask"></feComposite>
            <feComposite in="turbulence" in2="border_mask" operator="in" result="edge_turbulence"></feComposite>
    
            <!-- Part 2: Create the two displacement passes -->
            <feDisplacementMap in="SourceGraphic" in2="edge_turbulence" scale="15" xChannelSelector="R" yChannelSelector="G" result="disp_positive"></feDisplacementMap>
            <feDisplacementMap in="SourceGraphic" in2="edge_turbulence" scale="-15" xChannelSelector="R" yChannelSelector="G" result="disp_negative"></feDisplacementMap>
    
            <!-- Part 3: Create masks to isolate the correct halves of each pass -->
            <!-- Mask for the Top-Left Half -->
            <feFlood flood-color="white" width="50%" height="50%" x="0" y="0" result="topLeftRect"></feFlood>
            <!-- Mask for the Bottom-Right Half -->
            <feFlood flood-color="white" width="50%" height="50%" x="50%" y="50%" result="bottomRightRect"></feFlood>
    
            <!-- Part 4: Apply the masks -->
            <!-- Isolate the correctly refracted top-left from the positive pass -->
            <feComposite in="disp_positive" in2="topLeftRect" operator="in" result="topLeft_part"></feComposite>
            <!-- Isolate the correctly refracted bottom-right from the negative pass -->
            <feComposite in="disp_negative" in2="bottomRightRect" operator="in" result="bottomRight_part"></feComposite>
    
            <!-- 
               Part 5: Merge the perfectly isolated parts.
               Because there is no overlap, 'lighten' works perfectly, but you could also use feMerge.
            -->
            <feBlend in="topLeft_part" in2="bottomRight_part" mode="lighten" result="blended_image"></feBlend>
            
            <!-- Part 6: Adjust final opacity -->
            <feComponentTransfer in="blended_image">
                <feFuncA type="linear" slope="0.95"></feFuncA>
            </feComponentTransfer>
        </filter>
    </svg>

    <div class="toolbar">
        <button class="tab-btn active" data-view="home">
            <span class="material-symbols-rounded">heart_smile</span>
            For You
        </button>
        <button class="tab-btn" data-view="library">
            <span class="material-symbols-rounded">backpack</span>
            Owned
        </button>
        <button class="tab-btn" data-view="tidal" id="tidal-tab" style="display: none;">
            <span class="material-symbols-rounded">explore</span>
            Discover
        </button>
        <button class="tab-btn" data-view="search">
            <span class="material-symbols-rounded">search</span>
            Search
        </button>
    </div>

    <div id="home-view" class="view-container">
        <!-- Home page content will be rendered here -->
        <div class="loading-message"><svg width="24" height="24" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg" style="color: var(--text-color);"><style>.spinner_V8m1{transform-origin:center;animation:spinner_zKoa 2s linear infinite}.spinner_V8m1 circle{stroke-linecap:round;animation:spinner_YpZS 1.5s ease-in-out infinite}@keyframes spinner_zKoa{100%{transform:rotate(360deg)}}@keyframes spinner_YpZS{0%{stroke-dasharray:0 150;stroke-dashoffset:0}47.5%{stroke-dasharray:42 150;stroke-dashoffset:-16}95%,100%{stroke-dasharray:42 150;stroke-dashoffset:-59}}</style><g class="spinner_V8m1"><circle cx="12" cy="12" r="9.5" fill="none" stroke-width="3"></circle></g></svg></div>
    </div>
    <div id="library-view" class="view-container" style="display: none;">
        <div class="page-content-wrapper">
            <div class="library-controls" id="library-controls">
                <div class="filter-container">
                    <button class="filter-btn active" data-filter="albums" style="border-radius: 25px 10px 10px 25px;">Albums</button>
                    <button class="filter-btn" data-filter="artists">Artists</button>
                    <button class="filter-btn" data-filter="songs">Songs</button>
                    <button class="filter-btn" data-filter="playlists" style="border-radius: 10px 25px 25px 10px;">Playlists</button>
                </div>
                <div class="view-controls">
                    <button id="sortBtn" class="library-action-btn"><span class="material-symbols-rounded">history</span><span id="sort-mode-display"></span></button>
                </div>
                 <div class="library-actions">
                    <button class="library-action-btn" id="uploadBtn" style="display: none"><span class="material-symbols-rounded">add</span></button>
                    <button class="library-action-btn" id="manageFoldersBtn"><span class="material-symbols-rounded">settings</span></button>
                </div>
            </div>
            <div id="library-grid" class="item-grid" style="padding-bottom: 240px;">
                <!-- Library content will be rendered here -->
            </div>
             <input type="file" accept="audio/*" style="display: none" id="musicUpload" multiple webkitdirectory>
        </div>
    </div>
    <div id="tidal-view" class="view-container" style="display: none;">
        <div class="page-content-wrapper">
            <div class="library-controls" id="tidal-controls">
                <div class="filter-container" id="tidal-filter-container">
                    <button class="filter-btn-sc" data-filter="albums" style="border-radius: 25px 10px 10px 25px;">Albums</button>
                    <button class="filter-btn-sc" data-filter="artists">Artists</button>
                    <button class="filter-btn-sc active" data-filter="tracks" style="border-radius: 10px 25px 25px 10px;">Songs</button>
                </div>
                <div class="search-container" id="tidal-offline-search-container" style="display: none; max-width: 246px; margin: 0px;">
                    <span class="material-symbols-rounded search-icon">search</span>
                    <input type="text" id="tidalOfflineSearchInput" placeholder="Search your history" class="library-search-input">
                </div>
                <div class="library-actions">
                    <button class="library-action-btn" id="tidalOfflineToggle">
                        <span class="material-symbols-rounded">history</span>
                    </button>
                </div>
            </div>

            <div class="search-container" id="tidal-search-container" style="position: absolute; width: 90%; z-index: 1; left: 50%; transform: translateX(-50%);">
                <span class="material-symbols-rounded search-icon" style="padding-left: 2px;">search</span>
                <input type="text" id="tidalSearchInput" placeholder="Search" class="library-search-input" style="box-shadow: var(--sun-shadow), 0 0 15px rgba(0, 0, 0, 0.05); padding: 12px 17px 12px 42px;">
            </div>
            
            <div id="tidal-results-grid" class="item-grid" style="padding-top: 60px; padding-bottom: 240px;">
                <!-- tidal search/offline results will be rendered here -->
            </div>
        </div>
    </div>
    <div id="search-view" class="view-container" style="display: none;">
        <div class="page-content-wrapper">
            <div class="search-container" style="position: absolute; width: 90%; z-index: 1; left: 50%; transform: translateX(-50%);">
                <span class="material-symbols-rounded search-icon" style="padding-left: 2px;">search</span>
                <input type="text" id="searchInput" placeholder="Search your owned items" class="library-search-input" style="box-shadow: var(--sun-shadow), 0 0 15px rgba(0, 0, 0, 0.05); padding: 12px 17px 12px 42px;">
            </div>
            <div id="search-results-grid" class="item-grid" style="padding-top: 60px;">
                <!-- Search results will be rendered here -->
            </div>
        </div>
    </div>
    <div id="now-playing-view" class="view-container" style="display: none;">
        <div id="distortion-container">
            <canvas id="distortionCanvas"></canvas>
        </div>
        <div class="now-playing-wrapper">
            <div class="album-art">
                <img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAfQAAAH0CAYAAADL1t+KAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsMAAA7DAcdvqGQAAAPgSURBVHhe7cEBAQAAAIIg/69uSEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACcqAFFFQAB8Dl/nAAAAABJRU5ErkJggg==" alt="Album Art" id="albumArtImg">
            </div>
            <div class="music-info">
                <div class="music-text">
                    <div class="music-title">No song playing</div>
                    <div class="music-artist">&nbsp;</div>
                </div>
                <canvas id="visualizerCanvas"></canvas>
            </div>
            <div class="progress-container">
                <div class="progress-bar">
                    <div class="progress"></div>
                </div>
                <div class="time-info">
                    <span id="currentTime">&nbsp;</span>
                    <span id="duration">&nbsp;</span>
                </div>
            </div>
            <div class="player-controls">
                <button class="control-btn" id="shuffleBtn">
                    <span class="material-symbols-rounded">shuffle</span>
                </button>
                <button class="control-btn" id="prevBtn">
                    <span class="material-symbols-rounded" style="font-size: 36px;">fast_rewind</span>
                </button>
                <button class="control-btn play-pause" id="playPauseBtn">
                    <span class="material-symbols-rounded" id="playPauseIcon" style="font-size: 50px;">play_arrow</span>
                </button>
                <button class="control-btn" id="nextBtn">
                    <span class="material-symbols-rounded" style="font-size: 36px;">fast_forward</span>
                </button>
                <button class="control-btn" id="repeatBtn">
                    <span class="material-symbols-rounded">repeat</span>
                </button>
            </div>
            <div class="controls-container">
                <button class="lyrics-button">
                    <span class="material-symbols-rounded" style="font-size: 18px;">tooltip_2</span>
                </button>
                <button class="queue-button">
                    <span class="material-symbols-rounded" style="font-size: 18px;">format_list_bulleted</span>
                </button>
                <button class="more-button">
                    <span class="material-symbols-rounded" style="font-size: 18px;">more_horiz</span>
                </button>
                <div class="volume-control">
                    <span class="material-symbols-rounded" id="volumeIcon">volume_up</span>
                    <input type="range" class="volume-slider" min="0" max="100" value="100">
                </div>
            </div>
            <div id="moreOptionsMenu" class="more-options-menu" style="right: 30px; bottom: 90px;">
                <div class="menu-item" id="menuFullscreenBtn">
                    <span class="material-symbols-rounded">expand_content</span>
                    <span>Fullscreen</span>
                </div>
                <div class="menu-separator"></div>
                <div class="menu-item" id="menuEditMetadata">
                    <span class="material-symbols-rounded">edit</span>
                    <span>Edit Info</span>
                </div>
                <div class="menu-item" id="menuSaveToLibrary">
                    <span class="material-symbols-rounded">arrow_circle_down</span>
                    <span>Own</span>
                </div>
                <div class="menu-item" id="menuAddToPlaylist">
                    <span class="material-symbols-rounded">playlist_add</span>
                    <span>Add to Playlist</span>
                </div>
                <div class="menu-separator"></div>
                <div class="menu-item" id="menuCrossfade">
                    <span class="material-symbols-rounded">swap_horiz</span>
                    <span>Crossfade</span>
                    <span id="crossfadeStatus" style="margin-left: auto; font-size: 0.8em; color: var(--secondary-text-color);">Off</span>
                </div>
                <div class="menu-item" id="menuEqualizer">
                    <span class="material-symbols-rounded">equalizer</span>
                    <span>Equalizer</span>
                </div>
                <div class="menu-item" id="menuSleepTimer">
                    <span class="material-symbols-rounded">timer</span>
                    <span>Sleep Timer</span>
                </div>
                <div class="menu-separator"></div>
                <div class="menu-item" id="menuDeleteSong" style="color: #ff6b6b;">
                    <span class="material-symbols-rounded">delete</span>
                    <span>Delete Song</span>
                </div>
            </div>
        </div>
        <div id="lyrics-queue-panel" class="hidden">
            <!-- Lyrics or Queue content will be rendered here by JS -->
        </div>
    </div>

    <div id="bottom-miniplayer" class="hidden">
        <div class="miniplayer-progress"></div>
        <img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAfQAAAH0CAYAAADL1t+KAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsMAAA7DAcdvqGQAAAPgSURBVHhe7cEBAQAAAIIg/69uSEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACcqAFFFQAB8Dl/nAAAAABJRU5ErkJggg==" alt="mini-art" id="miniplayer-art">
        <div class="miniplayer-info">
            <div id="miniplayer-title">No song playing</div>
            <div id="miniplayer-artist"></div>
        </div>
        <div class="miniplayer-controls">
            <button id="miniplayer-prev-btn" class="mini-control-btn"><span class="material-symbols-rounded">fast_rewind</span></button>
            <button id="miniplayer-play-btn" class="mini-control-btn"><span class="material-symbols-rounded" style="font-size: 28px;">play_arrow</span></button>
            <button id="miniplayer-next-btn" class="mini-control-btn"><span class="material-symbols-rounded">fast_forward</span></button>
        </div>
    </div>

    <!-- Manage Folders Modal -->
    <div id="manageFoldersModal" class="modal-overlay">
        <div style="background: var(--modal-background); padding: 25px; border-radius: 50px; corner-shape: superellipse(1.5); width: 90%; max-width: 450px; backdrop-filter: var(--edge-refraction-filter) saturate(2) blur(5px); border: 1px solid var(--glass-border);">
            <h2 style="margin-top: 20px; margin-bottom: 15px;">Settings</h2>
            If you enable a third-party service, you agree to the Terms of Service and other polices of that service.
            <div style="display: flex; flex-direction: column; gap: 15px; padding-top: 15px;">
                <div style="display: flex; align-items: center; justify-content: space-between;">
                    <label for="tidalToggle">Enable Streaming</label>
                    <input type="checkbox" id="tidalToggle">
                </div>
                
                <div style="display: flex; align-items: center; justify-content: space-between;">
                    <label for="lrclibToggle">Search LRCLIB for missing lyrics</label>
                    <input type="checkbox" id="lrclibToggle">
                </div>
            </div>

            <div style="display: flex; justify-content: flex-end; margin-top: 25px; gap: 10px;">
                <button id="saveIntegrations" class="filter-btn">Save</button>
                <button id="closeFoldersModal" class="filter-btn active">Close</button>
            </div>
        </div>
    </div>

    <!-- Edit Song Modal -->
    <div id="editModal" class="modal-overlay">
        <div id="editModalContent" style="background: var(--modal-background); padding: 25px; border-radius: 50px; corner-shape: superellipse(1.5); width: 90%; max-width: 400px; backdrop-filter: var(--edge-refraction-filter) saturate(2) blur(5px); border: 1px solid var(--glass-border);">
            <h2 style="margin-bottom: 20px;">Edit Song Info</h2>
            <input type="hidden" id="editSongId">
            <div style="display: flex; flex-direction: column; gap: 15px;">
                <input type="text" id="editTitle" placeholder="Title" class="search-input" style="padding-left: 15px;">
                <input type="text" id="editArtist" placeholder="Artist" class="search-input" style="padding-left: 15px;">
                <input type="text" id="editAlbum" placeholder="Album" class="search-input" style="padding-left: 15px;">
            </div>
            <div style="display: flex; justify-content: flex-end; gap: 10px; margin-top: 25px;">
                <button id="cancelEdit" class="filter-btn">Cancel</button>
                <button id="saveEdit" class="filter-btn active">Save</button>
            </div>
        </div>
    </div>

    <!-- Manual Lyrics Search Modal -->
    <div id="manualLyricsSearchModal" class="modal-overlay">
        <div style="background: var(--modal-background); padding: 25px; border-radius: 50px; corner-shape: superellipse(1.5); width: 90%; max-width: 450px; backdrop-filter: var(--edge-refraction-filter) saturate(2) blur(5px); border: 1px solid var(--glass-border);">
            <h2 style="margin-bottom: 20px;">Lyrics Search</h2>
            <div style="display: flex; gap: 10px; margin-bottom: 15px;">
                <input type="text" id="manualLyricsSearchInput" placeholder="Artist - Title" class="search-input" style="padding-left: 15px;">
                <button id="manualLyricsSearchBtn" class="filter-btn active" style="flex-shrink: 0;"><span class="material-symbols-rounded" style="font-size: 18px;">arrow_forward</span></button>
            </div>
            <div id="manualLyricsResults" style="max-height: 250px; overflow-y: auto;">
                <!-- Search results will be populated here -->
            </div>
            <div style="display: flex; justify-content: flex-end; margin-top: 25px;">
                <button id="closeManualLyricsModal" class="filter-btn">Close</button>
            </div>
        </div>
    </div>

    <!-- Sleep Timer Modal -->
    <div id="sleepTimerModal" class="modal-overlay">
        <div style="background: var(--modal-background); padding: 25px; border-radius: 50px; corner-shape: superellipse(1.5); width: 90%; max-width: 300px; backdrop-filter: var(--edge-refraction-filter) saturate(2) blur(5px); border: 1px solid var(--glass-border);">
            <h2 style="margin-bottom: 20px;">Sleep Timer</h2>
            <p style="margin-bottom: 15px; color: var(--secondary-text-color);">Playback will stop after:</p>
            <div style="display: flex; flex-direction: column; gap: 10px;">
                <button class="filter-btn" onclick="setSleepTimer(15)">15 Minutes</button>
                <button class="filter-btn" onclick="setSleepTimer(30)">30 Minutes</button>
                <button class="filter-btn" onclick="setSleepTimer(60)">1 Hour</button>
            </div>
            <div class="menu-separator"></div>
            <button id="cancelSleepTimer" class="filter-btn active" style="width: 100%;">Cancel Timer</button>
        </div>
    </div>

    <!-- Playlist Modal -->
    <div id="playlistModal" class="modal-overlay">
         <div style="background: var(--modal-background); padding: 25px; border-radius: 50px; corner-shape: superellipse(1.5); width: 90%; max-width: 400px; backdrop-filter: var(--edge-refraction-filter) saturate(2) blur(5px); border: 1px solid var(--glass-border);">
            <h2 style="margin-bottom: 20px;">Add to playlist</h2>
            <div id="playlistList" style="max-height: 200px; overflow-y: auto; margin-bottom: 15px;"></div>
            <div class="menu-separator"></div>
            <input type="text" id="newPlaylistName" placeholder="Create new playlist" class="search-input" style="padding-left: 15px; margin-bottom: 10px;">
            <div style="display: flex; justify-content: flex-end; gap: 10px;">
                <button id="closePlaylistModal" class="filter-btn">Cancel</button>
                <button id="createPlaylistBtn" class="filter-btn active">Create & Add</button>
            </div>
        </div>
    </div>
    
    <!-- Equalizer Modal -->
    <div id="equalizerModal" class="modal-overlay">
        <div style="background: var(--modal-background); padding: 25px; border-radius: 50px; corner-shape: superellipse(1.5); width: 90%; max-width: 400px; backdrop-filter: var(--edge-refraction-filter) saturate(2) blur(5px); border: 1px solid var(--glass-border);">
            <h2 style="margin-bottom: 20px;">Equalizer</h2>
            
            <div id="eq-bands-container" style="display: flex; flex-direction: column; gap: 20px; margin-bottom: 25px;">
                <!-- Bass Slider -->
                <div class="eq-band">
                    <label for="bass-slider" style="display: block; margin-bottom: 5px; color: var(--secondary-text-color);">Bass</label>
                    <input type="range" id="bass-slider" class="volume-slider" min="-10" max="10" value="0" step="1">
                </div>
                <!-- Mid Slider -->
                <div class="eq-band">
                    <label for="mid-slider" style="display: block; margin-bottom: 5px; color: var(--secondary-text-color);">Mid</label>
                    <input type="range" id="mid-slider" class="volume-slider" min="-10" max="10" value="0" step="1">
                </div>
                <!-- Treble Slider -->
                <div class="eq-band">
                    <label for="treble-slider" style="display: block; margin-bottom: 5px; color: var(--secondary-text-color);">Treble</label>
                    <input type="range" id="treble-slider" class="volume-slider" min="-10" max="10" value="0" step="1">
                </div>
            </div>

            <div style="display: flex; justify-content: space-between; gap: 10px;">
                <button id="resetEq" class="filter-btn">Reset</button>
                <button id="closeEqModal" class="filter-btn active">Close</button>
            </div>
        </div>
    </div>

    <div id="songContextMenu" class="context-menu">
        <div class="menu-item" id="menuAddToQueueNext">
            <span class="material-symbols-rounded">playlist_play</span>
            <span>Play Next</span>
        </div>
        <div class="menu-item" id="menuAddToQueueLast">
            <span class="material-symbols-rounded">playlist_add</span>
            <span>Add to Queue</span>
        </div>
    </div>

    <div id="drawer" class="drawer">
        <div class="drawer-handle"></div>
        <div class="drawer-header">
            <h2 id="drawer-title"></h2>
            <p id="drawer-subtitle"></p>
        </div>
        <div class="drawer-content" id="drawer-content">
            <!-- Content will be injected here -->
        </div>
    </div>
    <div id="drawer-overlay" class="modal-overlay"></div>

    <script>
        const musicList = document.querySelector('.music-list');
        const musicUpload = document.getElementById('musicUpload');
        const audioPlayer = new Audio();
        const playPauseBtn = document.getElementById('playPauseBtn');
        const prevBtn = document.getElementById('prevBtn');
        const nextBtn = document.getElementById('nextBtn');
        const progressBar = document.querySelector('.progress-bar');
        const progress = document.querySelector('.progress');
        const currentTimeDisplay = document.getElementById('currentTime');
        const durationDisplay = document.getElementById('duration');
        const volumeSlider = document.querySelector('.volume-slider');
        const musicTitle = document.querySelector('.music-title');
        const musicArtist = document.querySelector('.music-artist');
        const albumArtImg = document.getElementById('albumArtImg');
        const playPauseIcon = document.getElementById('playPauseIcon');
        const volumeIcon = document.getElementById('volumeIcon');
        const body = document.body;
        const menuBtn = document.createElement('button');
        const storedLightMode = localStorage.getItem('theme') || 'dark';
        const isMobile = /Mobi|Android/i.test(navigator.userAgent);

        let activeView = 'home'; // 'home', 'library', 'search', 'nowPlaying'
        let isPanelVisible = false;
        let panelContent = null; // 'lyrics' or 'queue'
        let libraryScrollPosition = 0;
        let isFullscreen = false;
        let lastMainView = 'home'; // To remember where to return after playback ends
        let lastScrollPosition = 0; // To remember scroll position when entering Now Playing
        let scrollPositions = { home: 0, library: 0, search: 0 };
        const viewContainers = document.querySelectorAll('.view-container');
        const tabBtns = document.querySelectorAll('.tab-btn');
        const miniplayer = document.getElementById('bottom-miniplayer');
        const miniplayerArt = document.getElementById('miniplayer-art');
        const miniplayerTitle = document.getElementById('miniplayer-title');
        const miniplayerArtist = document.getElementById('miniplayer-artist');
        const miniplayerPlayBtn = document.getElementById('miniplayer-play-btn');
        const miniplayerProgress = document.querySelector('.miniplayer-progress');
        const toolbar = document.querySelector('.toolbar');
        
        const drawer = document.getElementById('drawer');
        const drawerContent = document.getElementById('drawer-content');
        const drawerOverlay = document.getElementById('drawer-overlay');
        let isDrawerOpen = false;
        let closeDrawerTimeout = null;
        
        let listenAgainIndex = parseInt(localStorage.getItem('listenAgainIndex') || '0');
        let currentMediaSessionArtBlobUrl = null;
        let lastOriginalImageUrl = null;
        let lastResizedImageUrl = null;
        let distortionCanvas, ctx;
        let currentResizedArt = new Image();
        let oldResizedArt = new Image();
        let blobs = [];
        let animationFrameId;
        let backgroundRotation = 0;
        let currentBeatIntensity = 0; // The smoothly animated intensity used for rendering
        let noise; // This will hold our noise generator function
        let beatIntensity = 0;
        let isTransitioning = false;
        let transitionProgress = 0;
        const TRANSITION_DURATION = 15; // in frames (approx. 0.25 seconds)
        let visualizerFrameId = null;
        let visualizerDraw = () => {};
        let songs = [];
        let currentSongId = null;
        let isPlayerLoading = false;
        let db;
        let directoryHandles = []; // For File System Access API
        let isShuffleEnabled = false;
        let repeatMode = 'none'; // 'none', 'all', or 'one'
        let playQueue = [];
        let isQueueUserModified = false;
        let currentQueueIndex = -1;
        let isAutoplayEnabled = false;
        let autoplaySongIds = new Set(); // Use a Set for efficient add/delete/check operations
        let searchTimeout;
        let searchInput;
        let longPressTimer;
        let isLongPress = false;
        const LONG_PRESS_DURATION = 500;
        let isDragging = false;
        let draggedItem = null;
        let isDraggingAlbum = false;
        let touchStartY = 0;
        let initialY = 0;
        let touchTarget = null;
        let hls = null; // To hold the Hls.js instance
        let audioContext;
        let analyser;
        let isVisualizerInitialized = false;
        let source;
        let currentFilter = 'albums'; // 'albums', 'artists', 'songs'
        let editModal, editSongId, editTitle, editArtist, editAlbum, saveEdit, cancelEdit, equalizerModal, manageFoldersModal;
        let crossfadeEnabled = false;
        let sleepTimerId = null;
        let eqBass, eqMid, eqTreble; // Add these for the EQ
        let playlists = [];
        let playlistModal, sleepTimerModal;
        let currentSortMode = 'dateAdded'; // 'dateAdded', 'alpha'
        let activeAlbum = null; // Will store { artist, name } of the selected album

        // --- tidal variables ---
        let tidalClientId = '';
        let istidalEnabled = false;
        let tidalSearchTimeout;
        let tidalSearchAbortController = null;
        let tidalSearchOffset = 0;
        let currentlyPlayingSong = null;
        let istidalOfflineMode = false;
        let tidalFilter = 'tracks';
        let lasttidalSearchResults = []; // To store API results for filtering
        let currentDrawerContext = []; // To store full objects for drawer context
        const tidal_CACHE_LIMIT = 200 * 1024 * 1024; // 200MB
        let localSongLookup = new Map();
        let isrcToLocalSongMap = new Map();

        // --- LRCLIB variables ---
        let isLrclibEnabled = false;
        let lastLrclibSearchResults = [];
        
        function sanitize(str) {
            if (!str) return '';
            return str.toString().replace(/</g, "<").replace(/>/g, ">");
        }

        function openModal(modal) {
            if (modal) modal.classList.add('visible');
        }
        
        function closeModal(modal) {
            if (modal) modal.classList.remove('visible');
        }

        function shuffleArray(array) {
            for (let i = array.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [array[i], array[j]] = [array[j], array[i]];
            }
            return array;
        }

function openDrawer(title, subtitle, contentHtml, context = {}) {
    clearTimeout(closeDrawerTimeout);

    const drawerTitleEl = document.getElementById('drawer-title');
    const drawerSubtitleEl = document.getElementById('drawer-subtitle');

    drawerTitleEl.textContent = sanitize(title);
    
    // Check the context to see if we should add a delete button
    if (context.type === 'playlist' && context.id) {
        // If it's a playlist, add the subtitle and the delete button side-by-side
        drawerSubtitleEl.innerHTML = `
            <div style="display: flex; align-items: center; justify-content: center; gap: 10px;">
                <span>${sanitize(subtitle)}</span>
                <button id="drawer-delete-playlist-btn" data-playlist-id="${context.id}" title="Delete Playlist">
                    <span class="material-symbols-rounded">delete_forever</span>
                </button>
            </div>
        `;
    } else {
        // Otherwise, just show the normal subtitle
        drawerSubtitleEl.textContent = sanitize(subtitle);
    }

    drawerContent.innerHTML = contentHtml;
    drawer.classList.add('open');
    drawerOverlay.classList.add('visible');
    isDrawerOpen = true;
}

function closeDrawer() {
    drawer.classList.remove('open');
    drawerOverlay.classList.remove('visible');
    isDrawerOpen = false;
    // Clear content after animation
    closeDrawerTimeout = setTimeout(() => {
        drawer.style.transform = '';
        drawerContent.innerHTML = '';
    }, 400);
}
        
function setupDrawerInteractions() {
    let startY = 0;
    let currentY = 0;
    let isDragging = false;
    const handle = document.querySelector('.drawer-handle');
    const drawer = document.getElementById('drawer');

    const startDrag = (y) => {
        if (!isDrawerOpen) return;
        isDragging = true;
        startY = y;
        drawer.style.transition = 'none';
    };

    const moveDrag = (y) => {
        if (!isDragging) return;
        currentY = y;
        const deltaY = currentY - startY;
        if (deltaY > 0) { // Only allow dragging down
            drawer.style.transform = `translateY(${deltaY}px)`;
        }
    };

    const endDrag = () => {
        if (!isDragging) return;
        isDragging = false;
        drawer.style.transition = '';
        drawer.style.transform = ''; // Reset transform to allow CSS transition
        
        const deltaY = currentY - startY;
        if (deltaY > 100) { // Close threshold
            closeDrawer();
        } else {
            drawer.style.bottom = '0';
        }
    };

    handle.addEventListener('mousedown', (e) => startDrag(e.clientY));
    document.addEventListener('mousemove', (e) => moveDrag(e.clientY));
    document.addEventListener('mouseup', endDrag);
    document.addEventListener('mouseleave', endDrag);

    handle.addEventListener('touchstart', (e) => startDrag(e.touches[0].clientY), { passive: true });
    document.addEventListener('touchmove', (e) => moveDrag(e.touches[0].clientY), { passive: true });
    document.addEventListener('touchend', endDrag);

    document.getElementById('drawer-overlay').addEventListener('click', closeDrawer);
}

        function getLowResArtUrl(highResUrl) {
            if (!highResUrl || !highResUrl.includes('resources.tidal.com')) {
                return highResUrl;
            }
            return highResUrl.replace(/\/\d+x\d+\.jpg$/, '/80x80.jpg');
        }

        function getHighResArtwork(coverUuid, size = 640) {
            if (!coverUuid) {
                return generateRandomGradient();
            }
            const formattedUuid = coverUuid.replace(/-/g, '/');
            const imageUrl = `https://resources.tidal.com/images/${formattedUuid}/${size}x${size}.jpg`;
            return imageUrl;
        }
            
function renderSearchResults() {
    const searchGrid = document.getElementById('search-results-grid');
    const query = document.getElementById('searchInput').value.toLowerCase();
    if (!query) {
        searchGrid.innerHTML = '';
        return;
    }

    const results = songs.filter(s => 
        s.name.toLowerCase().includes(query) ||
        s.artist.toLowerCase().includes(query) ||
        s.album.toLowerCase().includes(query)
    );

    if (results.length === 0) {
        searchGrid.innerHTML = `<div class="no-results" style="grid-column: 1 / -1;"><p>No results found for "${query}"</p></div>`;
        return;
    }
    
    // For now, just show a list of matching songs
    const resultsHtml = results.map(song => `
        <div class="music-item" data-id="${song.id}" style="cursor: pointer;">
             <div class="song-info">
                <img src="${song.albumArt}" class="album-thumbnail" style="width: 40px; height: 40px; scale: 1.2; border-radius: 8px; margin-right: 10px;">
                <div>
                    <div class="song-title" style="white-space: normal;">${sanitize(song.name)}</div>
                    <div class="album-artist" style="font-size: 0.8em;">${sanitize(song.artist)}</div>
                </div>
            </div>
        </div>
    `).join('');
    searchGrid.className = 'item-list'; // Search results are a list
    searchGrid.innerHTML = resultsHtml;

    requestAnimationFrame(() => {
        const searchView = document.getElementById('search-view');
        searchView.scrollTop = scrollPositions.search;
    });
}

        function rendertidalSearchResults(totalItems = 0) {
            const resultsGrid = document.getElementById('tidal-results-grid');
            if (lasttidalSearchResults.length === 0) {
                resultsGrid.innerHTML = '<div class="no-results" style="grid-column: 1 / -1;"><p>No results found.</p></div>';
                return;
            }

            let resultsHtml = '';
            switch (tidalFilter) {
                case 'artists':
                    resultsGrid.className = 'item-grid';
                    resultsHtml = lasttidalSearchResults.map(artist => `
                        <div class="item-card" data-artist-id="${artist.id}" data-artist-name="${sanitize(artist.name)}">
                            <img src="${getHighResArtwork(artist.picture, 320)}" class="item-card-art" style="border-radius: 50%;">
                            <div class="item-card-info" style="text-align: center;"><div class="item-card-title">${sanitize(artist.name)}</div></div>
                        </div>`).join('');
                    break;
                case 'albums':
                    resultsGrid.className = 'item-grid';
                     resultsHtml = lasttidalSearchResults.map(album => `
                        <div class="item-card" data-album-id="${album.id}" data-album-name="${sanitize(album.title)}" data-album-artist-name="${sanitize(album.artists[0].name)}">
                            <img src="${getHighResArtwork(album.cover)}" class="item-card-art">
                            <div class="item-card-info"><div class="item-card-title">${sanitize(album.title)}</div><div class="item-card-subtitle">${sanitize(album.artists[0].name)}</div></div>
                        </div>`).join('');
                    break;
                case 'tracks':
                default:
                    resultsGrid.className = 'item-grid';
                    resultsHtml = lasttidalSearchResults.map(track => `
                        <div class="item-card" data-track-id="${track.id}">
                            <img src="${getHighResArtwork(track.album.cover)}" class="item-card-art">
                            <div class="item-card-info">
                                <div class="item-card-title">${sanitize(track.title)}</div>
                                <div class="item-card-subtitle">${sanitize(track.artist.name)}</div>
                            </div>
                        </div>`).join('');
                    break;
            }
            resultsGrid.innerHTML = resultsHtml;
            
            if (lasttidalSearchResults.length > 0 && lasttidalSearchResults.length < totalItems) {
                resultsGrid.insertAdjacentHTML('beforeend', `<div style="grid-column: 1 / -1; text-align: center; padding: 20px;">
                                              <button id="loadMoreBtn" class="action-btn">Load More</button>
                                          </div>`);
            }
        }

function setView(viewName) {
    activeView = viewName;
    const isNowPlaying = (viewName === 'now-playing');

    if (isNowPlaying) {
        body.style.backgroundColor = 'var(--background-color)';
        if (!animationFrameId) {
            animateCanvas();
        }
        // Much cleaner start logic:
        if (!visualizerFrameId && visualizerDraw) {
            visualizerDraw();
        }
    } else {
        if (animationFrameId) {
            cancelAnimationFrame(animationFrameId);
            animationFrameId = null;
        }
        if (visualizerFrameId) {
            cancelAnimationFrame(visualizerFrameId);
            visualizerFrameId = null;
        }
        body.style.backgroundColor = '';
    }
    
    tabBtns.forEach(btn => {
        btn.classList.toggle('active', btn.dataset.view === viewName);
    });

    viewContainers.forEach(container => {
        const isVisible = container.id === `${viewName}-view`;
        container.style.display = isVisible ? 'flex' : 'none';

        if (isVisible) {
            if (viewName === 'library') { renderLibraryPage(); } 
            else if (viewName === 'home') { renderHomePage(); } 
            else if (viewName === 'search') { renderSearchResults(); }
        }
    });
    
    if (isNowPlaying && currentSongId) {
        const song = currentlyPlayingSong; 
        if (song) updatePlayerUI(song);
    }

    if (viewName !== 'search') {
        document.getElementById('searchInput').value = '';
        if(activeView === 'search') renderSearchResults(); // Clear results visually
    }
    
    toolbar.classList.toggle('hidden', isNowPlaying && isFullscreen);
    updateMiniplayerUI(currentlyPlayingSong, audioPlayer.paused ? 'paused' : 'playing');

    document.getElementById('distortion-container').classList.toggle('active', isNowPlaying);
    if (isVisualizerInitialized && isNowPlaying && audioContext.state === 'suspended') {
        audioContext.resume();
    }
}
     
const initDB = () => {
    return new Promise((resolve, reject) => {
        // DB version bumped to 7
        const request = indexedDB.open('music-tidal-DB', 7);

        request.onerror = (event) => {
            console.error('IndexedDB error:', event.target.error);
            reject(event.target.error);
        };

        request.onupgradeneeded = (event) => {
            db = event.target.result;
            if (!db.objectStoreNames.contains('musicFiles')) {
                db.createObjectStore('musicFiles', { keyPath: 'id' });
            }
            if (!db.objectStoreNames.contains('songs')) {
                const songStore = db.createObjectStore('songs', { keyPath: 'id' });
                songStore.createIndex('albumArtist', 'albumArtist');
                // Add new index for play count
                songStore.createIndex('playCount', 'playCount');
            } else {
                // Ensure playCount index exists on existing stores
                const songStore = event.target.transaction.objectStore('songs');
                if (!songStore.indexNames.contains('playCount')) {
                    songStore.createIndex('playCount', 'playCount');
                }
            }
            if (!db.objectStoreNames.contains('playlists')) {
                db.createObjectStore('playlists', { keyPath: 'id', autoIncrement: true });
            }
            if (!db.objectStoreNames.contains('config')) {
                db.createObjectStore('config', { keyPath: 'key' });
            }
            // Create new store for play history
            if (!db.objectStoreNames.contains('playHistory')) {
                db.createObjectStore('playHistory', { keyPath: 'timestamp' });
            }
            if (!db.objectStoreNames.contains('tidalCache')) {
                const cacheStore = db.createObjectStore('tidalCache', { keyPath: 'id' });
                cacheStore.createIndex('timestamp', 'timestamp');
            }
        };

        request.onsuccess = (event) => {
            db = event.target.result;
            resolve();
        };
    });
};

function promiseIDBRequest(request) {
    return new Promise((resolve, reject) => {
        request.onsuccess = () => resolve(request.result);
        request.onerror = () => reject(request.error);
    });
}

function createPlayQueue() {
    if (isShuffleEnabled) {
        let availableSongs = [...songs];
        let currentSong = null;
        
        if (currentSongId) {
            currentSong = availableSongs.find(s => s.id === currentSongId);
            availableSongs = availableSongs.filter(s => s.id !== currentSongId);
        }
        
        for (let i = availableSongs.length - 1; i > 0; i--) {
            const j = Math.floor(Math.random() * (i + 1));
            [availableSongs[i], availableSongs[j]] = [availableSongs[j], availableSongs[i]];
        }
        
        return currentSong ? [currentSong, ...availableSongs] : availableSongs;
    }
    
    return [...songs];
}

function resetPlayer() {
    audioPlayer.pause();
    audioPlayer.currentTime = 0;
    currentSongId = null;
    currentlyPlayingSong = null; // Clear the currently playing song object
    updateMiniplayerUI(null);
    playQueue = [];
    currentQueueIndex = -1;

    isShuffleEnabled = false;
    updateShuffleButtonState();

    const defaultImage = "/music/favicon.png";
    const defaultImageBig = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAfQAAAH0CAYAAADL1t+KAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsMAAA7DAcdvqGQAAAPgSURBVHhe7cEBAQAAAIIg/69uSEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACcqAFFFQAB8Dl/nAAAAABJRU5ErkJggg==";

    albumArtImg.src = defaultImageBig;

    updateAllBackgrounds('');
    
    musicTitle.textContent = 'No song playing';
    musicArtist.innerHTML = '&nbsp;';
    
    updateTimeDisplays();
    playPauseIcon.textContent = 'play_arrow';
    playPauseBtn.classList.remove('playing');
    Gurasuraisu.updatePlaybackState({ playbackState: 'paused' });
    document.title = 'Streams';
    updateFavicon(defaultImage);

    Gurasuraisu.clearMediaSession();

    // Revoke any existing blob URL to prevent memory leaks
    if (currentMediaSessionArtBlobUrl) {
        URL.revokeObjectURL(currentMediaSessionArtBlobUrl);
        currentMediaSessionArtBlobUrl = null;
    }

    if ('mediaSession' in navigator) {
        navigator.mediaSession.metadata = null;
        navigator.mediaSession.playbackState = 'none';
    }

    connectAudioGraph();
    document.querySelector('.lyrics-button').style.display = ''; // Ensure lyrics button is visible on reset
    
    if (activeView === 'now-playing') {
        setView(lastMainView);
    }
}
    
        function formatTime(seconds) {
            if (isNaN(seconds) || seconds < 0) return "-:--";
            const minutes = Math.floor(seconds / 60);
            const remainingSeconds = Math.floor(seconds % 60);
            return `${minutes}:${remainingSeconds.toString().padStart(2, '0')}`;
        }
        
function makeElementsDraggable() {
      // This function is intentionally left blank to disable drag-and-drop for the library view.
      // Drag-and-drop for the queue is handled by a separate function.
}

// Function to update the songs array based on the DOM order
function updateSongsArrayFromDOM() {
  const newSongsOrder = [];
  const albumOrder = [];
  
  document.querySelectorAll('.album-section').forEach((albumSection, albumIndex) => {
    const albumName = albumSection.querySelector('.album-name').textContent;
    const albumArtist = albumSection.querySelector('.album-artist').textContent;
    
    albumOrder.push({
      name: albumName,
      index: albumIndex
    });
    
    albumSection.querySelectorAll('.music-item').forEach((musicItem, songIndex) => {
      const songId = parseFloat(musicItem.dataset.id);
      const song = songs.find(s => s.id === songId);
      
      if (song) {
        song.trackNumber = songIndex + 1;
        song.albumOrder = albumIndex;
        newSongsOrder.push(song);
      }
    });
  });
  
  songs = newSongsOrder;
  
  updatePlayQueue();
  
  saveSongs();
}

function loadAndPlaySong(song) {
    if (!song) return;
    playSong(song);
}
        
function updatePageTitle() {
    if (currentSongId) {
        const song = currentlyPlayingSong;
        if (song) {
            const currentTime = formatTime(audioPlayer.currentTime);
            document.title = `${currentTime} | ${sanitize(song.name)} • ${sanitize(song.artist)}`;
        }
    } else {
        document.title = 'Streams'; // Default title when no song is playing
    }
}

function setupLongPressListeners(container) {
    let longPressTimer;
    let isLongPress = false;
    let startX, startY;
    let moved = false; // Flag to track if the touch/mouse has moved significantly
    const LONG_PRESS_DURATION = 500;
    const MOVE_THRESHOLD = 10; // Pixels a user can move before it's considered a scroll

    const handlePressStart = (e) => {
        const musicItem = e.target.closest('.music-item[data-id], .item-card[data-id]');
        if (!musicItem) return;

        startX = e.touches ? e.touches[0].clientX : e.clientX;
        startY = e.touches ? e.touches[0].clientY : e.clientY;
        isLongPress = false;
        moved = false; // Reset on new touch start

        longPressTimer = setTimeout(() => {
            if (!moved) { // Only trigger long press if user hasn't scrolled
                isLongPress = true;
                const songId = parseFloat(musicItem.dataset.id);
                openSongContextMenu(musicItem, songId);
            }
        }, LONG_PRESS_DURATION);
    };

    const handlePressMove = (e) => {
        // If the timer has already been cleared (e.g., by a long press), we don't need to do anything
        if (!longPressTimer) return;

        const currentX = e.touches ? e.touches[0].clientX : e.clientX;
        const currentY = e.touches ? e.touches[0].clientY : e.clientY;

        // Check if the movement exceeds our threshold
        if (Math.abs(currentX - startX) > MOVE_THRESHOLD || Math.abs(currentY - startY) > MOVE_THRESHOLD) {
            moved = true; // It's a scroll
            clearTimeout(longPressTimer); // Cancel the long press timer
            longPressTimer = null;
        }
    };

    const handlePressEnd = (e) => {
        clearTimeout(longPressTimer);

        // If it was a long press, stop the event from bubbling up as a click
        if (isLongPress) {
            e.preventDefault();
            e.stopPropagation();
            return;
        }
        
        // If the touch moved, it was a scroll, not a click, so do nothing.
        if (moved) {
            return;
        }

        // This is a regular click/tap
        const musicItem = e.target.closest('.music-item[data-id], .item-card[data-id]');
        if (musicItem) {
            const songId = parseFloat(musicItem.dataset.id);
            const song = songs.find(s => s.id === songId);
            if (song) {
                const contextSongs = Array.from(container.querySelectorAll('.music-item[data-id], .item-card[data-id]'))
                    .map(item => songs.find(s => s.id === parseFloat(item.dataset.id)))
                    .filter(Boolean);
                playSong(song, contextSongs.length > 0 ? contextSongs : [song]);
            }
        }
    };
    
    // Remove old listeners to prevent duplicates if this function is called multiple times
    container.removeEventListener('mousedown', handlePressStart);
    container.removeEventListener('touchstart', handlePressStart, { passive: true });
    container.removeEventListener('mousemove', handlePressMove);
    container.removeEventListener('touchmove', handlePressMove, { passive: true });
    container.removeEventListener('mouseup', handlePressEnd);
    container.removeEventListener('touchend', handlePressEnd);
    container.removeEventListener('mouseleave', handlePressEnd); // Handle mouse leaving the element
    container.removeEventListener('touchcancel', handlePressEnd); // Handle cancelled touches

    // Add new listeners
    container.addEventListener('mousedown', handlePressStart);
    container.addEventListener('touchstart', handlePressStart, { passive: true });
    container.addEventListener('mousemove', handlePressMove);
    container.addEventListener('touchmove', handlePressMove, { passive: true });
    container.addEventListener('mouseup', handlePressEnd);
    container.addEventListener('touchend', handlePressEnd);
    container.addEventListener('mouseleave', handlePressEnd);
    container.addEventListener('touchcancel', handlePressEnd);
}
        
        function isAudioFile(file) {
            const allowedTypes = [
                'audio/mpeg', 'audio/wav', 'audio/wave', 'audio/x-wav', 'audio/flac', 
                'audio/ogg', 'audio/opus', 'audio/x-m4a', 'audio/aac', 'audio/webm', 'audio/x-flac'
            ];
            const allowedExtensions = /\.(mp3|wav|flac|ogg|opus|m4a|aac)$/i;
            
            return allowedTypes.includes(file.type) || (file.name && file.name.match(allowedExtensions));
        }
        
function generateRandomGradient() {
    const colors = [
        '#ff6b6b', '#4ecdc4', '#45b7d1', '#96ceb4', '#ffeead',
        '#d4a5a5', '#9b59b6', '#3498db', '#e74c3c', '#2ecc71',
        '#f1c40f', '#1abc9c', '#e67e22', '#7f8c8d', '#2c3e50'
    ];
    
    const color1 = colors[Math.floor(Math.random() * colors.length)];
    let color2;
    do {
        color2 = colors[Math.floor(Math.random() * colors.length)];
    } while (color1 === color2);
    
    const angle = Math.floor(Math.random() * 360);
    
    const canvas = document.createElement('canvas');
    canvas.width = 500;
    canvas.height = 500;
    const ctx = canvas.getContext('2d');
    
    const gradient = ctx.createLinearGradient(0, 0, 500, 500);
    gradient.addColorStop(0, color1);
    gradient.addColorStop(1, color2);
    
    ctx.fillStyle = gradient;
    ctx.fillRect(0, 0, 500, 500);
    
    return canvas.toDataURL('image/jpeg', 0.9);
}

function updateLocalSongLookup(songsToAdd, options = {}) {
    if (options.clear) {
        localSongLookup.clear();
        console.log("Local song lookup map cleared.");
    }
    if (!Array.isArray(songsToAdd)) return; // Safety check

    for (const song of songsToAdd) {
        const uniqueKey = `${(song.artist || '').toLowerCase().trim()}::${(song.name || '').toLowerCase().trim()}`;
        // Only add the song if this key doesn't already exist.
        // This prioritizes the first-added version in case of library inconsistencies.
        if (!localSongLookup.has(uniqueKey)) {
            localSongLookup.set(uniqueKey, song);
        }
    }
}
        
async function preloadSongs(files) {
    const allowedTypes = [
        'audio/mpeg',        // MP3
        'audio/wav',         // WAV
        'audio/flac',        // FLAC
        'audio/ogg',         // OGG
        'audio/opus',        // OPUS
        'audio/x-m4a',       // M4A
        'audio/aac',         // AAC
        'audio/webm',        // WEBM audio
        'audio/x-flac'       // Alternative FLAC MIME type
    ];

    const filesArray = Array.from(files).filter(file => 
        allowedTypes.includes(file.type) || 
        file.name.match(/\.(mp3|wav|flac|ogg|opus|m4a|aac)$/i)
    );
    
    if (filesArray.length === 0) {
        console.warn('No valid audio files found');
        return;
    }

    for (const file of filesArray) {
        try {
            const arrayBuffer = await file.arrayBuffer();
            
            await new Promise((resolve, reject) => {
                const transaction = db.transaction(['musicFiles'], 'readwrite');
                const store = transaction.objectStore('musicFiles');
                
                const song = {
                    id: Date.now() + Math.random(),
                    file: new Blob([arrayBuffer], { type: file.type })
                };
                
                const request = store.put(song);
                
                transaction.oncomplete = () => resolve();
                transaction.onerror = (event) => reject(event.target.error);
            });
        } catch (error) {
            console.error('Error processing file:', error);
        }
    }
}

function updateFavicon(albumArt) {
  if (!albumArt) return;
  const canvas = document.createElement('canvas');
  const ctx = canvas.getContext('2d');
  const size = 32; 
  const radius = 10;

  canvas.width = size;
  canvas.height = size;

  const img = new Image();
  if (!albumArt.startsWith('data:')) {
    img.crossOrigin = 'anonymous';
  }

  img.onload = function() {
    ctx.clearRect(0, 0, size, size);
    ctx.beginPath();
    if (ctx.roundRect) {
        ctx.roundRect(0, 0, size, size, radius);
    } else { // Fallback for older browsers
        ctx.rect(0, 0, size, size);
    }
    ctx.closePath();
    ctx.clip();
    ctx.drawImage(img, 0, 0, size, size);

    const roundedImageURL = canvas.toDataURL('image/png');
    const existingFavicon = document.getElementById('favicon');
    if (existingFavicon) {
        existingFavicon.href = roundedImageURL;
    }
  };

  img.onerror = function() {
    console.error('Error loading album art for favicon');
  };
  img.src = getLowResArtUrl(albumArt);
}

async function loadSong(song) {
    playSong(song);
}
        
async function extractMetadata(file) {
    return new Promise((resolve) => {
        new jsmediatags.Reader(file)
            .read({
                onSuccess: async function(tag) {
                    let albumArt;
                    if (tag.tags.picture) {
                        const { data, format } = tag.tags.picture;
                        const base64String = data.reduce((acc, curr) => acc + String.fromCharCode(curr), '');
                        albumArt = `data:${format};base64,${btoa(base64String)}`;
                    } else {
                        albumArt = generateRandomGradient();
                    }

                    let lyricsText = null;
                    let lrcData = null;
                    let foundSyncedLyrics = false;
                    const lrcCandidates = [
                        tag.tags.USLT?.lyrics,
                        (typeof tag.tags.lyrics === 'object' ? tag.tags.lyrics.lyrics : tag.tags.lyrics),
                        tag.tags.LYRICS
                    ];
                    for (const candidate of lrcCandidates) {
                        if (candidate) {
                            const parsed = parseLRC(candidate);
                            if (parsed) {
                                lrcData = parsed;
                                lyricsText = candidate;
                                foundSyncedLyrics = true;
                                break;
                            }
                        }
                    }
                    if (!foundSyncedLyrics) {
                        lyricsText = lrcCandidates.find(text => typeof text === 'string' && text.trim() !== '') || null;
                    }

                    const parseComplexTag = (rawTag) => {
                        if (!rawTag) return null;
                        const value = rawTag.data || rawTag;
                        if (typeof value === 'object' && value.no) {
                            return parseInt(value.no, 10);
                        }
                        const parsed = parseInt(String(value).split('/')[0], 10);
                        return isNaN(parsed) ? null : parsed;
                    };

                    const discNumber = parseComplexTag(tag.tags.DISCNUMBER || tag.tags.disk || tag.tags.TPOS);
                    const trackNumber = parseComplexTag(tag.tags.TRACKNUMBER || tag.tags.track);
                    
                    const albumArtist = tag.tags.TPE2?.data || tag.tags.album_artist || tag.tags.artist || 'Unknown Artist';

                    const genreTag = tag.tags.TCON || tag.tags.genre;
                    const genre = genreTag ? (genreTag.data || genreTag) : null;

                    resolve({
                        title: tag.tags.title || file.name.replace(/\.[^/.]+$/, ""),
                        artist: tag.tags.artist || 'Unknown Artist',
                        album: tag.tags.album || 'Unknown Album',
                        albumArtist: albumArtist,
                        year: tag.tags.year || '',
                        albumArt: albumArt,
                        trackNumber: trackNumber,
                        discNumber: discNumber,
                        lyrics: lyricsText,
                        lrcData: lrcData,
                        genre: genre
                    });
                },
                onError: (error) => {
                    console.error("jsmediatags ERROR for:", file.name, error);
                    resolve({
                        title: file.name.replace(/\.[^/.]+$/, ""),
                        artist: 'Unknown Artist',
                        album: 'Unknown Album',
                        albumArtist: 'Unknown Artist',
                        year: '',
                        albumArt: generateRandomGradient(),
                        trackNumber: null,
                        discNumber: null,
                        lyrics: null,
                        lrcData: null,
                        genre: null
                    });
                }
            });
    });
}
        
async function addSongs(files, storageType) {
    const newSongs = [];
    const songFilesToStore = [];

    for (let fileHandleOrFile of files) {
        try {
            const file = storageType === 'filesystem' ? await fileHandleOrFile.getFile() : fileHandleOrFile;
            if (!isAudioFile(file)) continue;

            const metadata = await extractMetadata(file);
            const newSongId = Date.now() + Math.random();

            newSongs.push({
                id: newSongId,
                name: metadata.title,
                artist: metadata.artist,
                album: metadata.album,
                albumArtist: metadata.albumArtist,
                storage: storageType,
                handleName: file.name,
                dateAdded: Date.now(),
                year: metadata.year,
                albumArt: metadata.albumArt,
                trackNumber: metadata.trackNumber,
                discNumber: metadata.discNumber,
                lyrics: metadata.lyrics,
                lrcData: metadata.lrcData,
                genre: metadata.genre,
                playCount: 0 // Initialize playCount
            });

            if (storageType === 'indexeddb') {
                songFilesToStore.push({ id: newSongId, file: file });
            }

        } catch (error) {
            console.error("Could not process file:", fileHandleOrFile.name, error);
        }
    }

    if (newSongs.length > 0) {
        songs.push(...newSongs);
        processAndSortSongs();
        await saveSongs();

        if (songFilesToStore.length > 0) {
            const tx = db.transaction(['musicFiles'], 'readwrite');
            songFilesToStore.forEach(item => tx.objectStore('musicFiles').put(item));
            await tx.done;
        }
    }

    // Re-render the current view to show the new songs
    if (activeView === 'library') {
        renderLibraryPage();
    } else if (activeView === 'home') {
        renderHomePage();
    }
    updateLocalSongLookup(newSongs);
}

async function scanForNewSongs() {
    if (directoryHandles.length === 0) return false;

    console.log("Scanning for new songs in existing directories...");
    const filesToAdd = [];
    
    const existingSongNames = new Set(songs.map(s => s.handleName));

    for (const handle of directoryHandles) {
        try {
            for await (const entry of handle.values()) {
                if (entry.kind === 'file' && isAudioFile({ name: entry.name }) && !existingSongNames.has(entry.name)) {
                    filesToAdd.push(entry);
                }
            }
        } catch (e) {
            console.error(`Could not scan directory "${handle.name}". It may need to be re-added.`, e);
        }
    }

    if (filesToAdd.length > 0) {
        console.log(`Found ${filesToAdd.length} new songs. Adding them to the library...`);
        await addSongs(filesToAdd, 'filesystem');
        return true; 
    }
    
    console.log("No new songs found.");
    return false;
}

function parseLRC(lrcText) {
    if (!lrcText || !lrcText.includes('[')) return null;

    let allEntries = [];
    const timeRegex = /\[(\d{2}):(\d{2})\.(\d{2,3})\]/g;
    // This regex will find any text enclosed in () or []
    const asideRegex = /(\[.*?\]|\(.*?\))/;

    const lines = lrcText.split('\n');

    lines.forEach(line => {
        const timeMatches = [...line.matchAll(timeRegex)];
        if (timeMatches.length === 0) return;

        const rawText = line.substring(timeMatches[timeMatches.length - 1].index + timeMatches[timeMatches.length - 1][0].length).trim();
        if (!rawText) return;

        timeMatches.forEach(match => {
            const minutes = parseInt(match[1], 10);
            const seconds = parseInt(match[2], 10);
            const milliseconds = parseInt(match[3].padEnd(3, '0'), 10);
            const time = minutes * 60 + seconds + milliseconds / 1000;
            
            // Split the line by asides, keeping the delimiters.
            // e.g., "Hello (world)" becomes ["Hello ", "(world)"]
            const parts = rawText.split(asideRegex).filter(Boolean);
            
            parts.forEach(part => {
                const text = part.trim();
                if (!text) return;

                // If the part matches the aside format, classify it as 'aside'
                if (asideRegex.test(text)) {
                    const cleanedAsideText = text.slice(1, -1);
                    allEntries.push({ time, text: cleanedAsideText, type: 'aside' });
                } else {
                    allEntries.push({ time, text, type: 'line' });
                }
            });
        });
    });

    allEntries.sort((a, b) => a.time - b.time);

    return allEntries.length > 0 ? { lyrics: allEntries } : null;
}
        
async function loadSongsFromStorage() {
    try {
        const tx = db.transaction(['songs'], 'readonly');
        const songStore = tx.objectStore('songs');
        const songsRequest = songStore.getAll();
        
        const loadedSongs = await new Promise((resolve, reject) => {
            songsRequest.onsuccess = () => resolve(songsRequest.result);
            songsRequest.onerror = (e) => reject(e.target.error);
        });
        
        songs = loadedSongs || [];
        processAndSortSongs();
        updatePlayQueue();
    } catch (error) {
        console.error('Error loading songs from storage:', error);
    }
}
        
async function saveSongs() {
    const transaction = db.transaction(['songs'], 'readwrite');
    const store = transaction.objectStore('songs');
    
    return new Promise((resolve, reject) => {
        transaction.onerror = (event) => {
            console.error("Transaction error while saving songs:", event.target.error);
            reject(event.target.error);
        }
        
        store.clear();
        songs.forEach(song => {
            const songToStore = {
                id: song.id, name: song.name, artist: song.artist, album: song.album,
                albumArtist: song.albumArtist, year: song.year, albumArt: song.albumArt, 
                trackNumber: song.trackNumber, discNumber: song.discNumber,
                lyrics: song.lyrics, lrcData: song.lrcData, storage: song.storage,
                handleName: song.handleName, dateAdded: song.dateAdded,
                genre: song.genre,
                playCount: song.playCount || 0
            };
            store.add(songToStore);
        });
        
        transaction.oncomplete = () => {
            console.log(`Songs saved. Total count: ${songs.length}`);
            resolve();
        };
    });
}

async function migrateToFSA() {
    if (directoryHandles.length === 0) return;

    const songsToMigrate = songs.filter(s => s.storage === 'indexeddb');
    if (songsToMigrate.length === 0) {
        console.log("No songs to migrate.");
        return;
    }

    console.log(`Starting migration for ${songsToMigrate.length} songs...`);
    const blobIdsToDelete = [];
    let migrationOccurred = false;

    for (const song of songsToMigrate) {
        let foundInHandles = false;
        for (const handle of directoryHandles) {
            try {
                await handle.getFileHandle(song.handleName);
                foundInHandles = true;
                break;
            } catch (e) { /* Not in this handle */ }
        }
        
        if (foundInHandles) {
            song.storage = 'filesystem';
            blobIdsToDelete.push(song.id);
            migrationOccurred = true;
            console.log(`Migrated "${song.name}" to File System Access.`);
        } else {
            console.warn(`Could not find "${song.handleName}" in the directory. It will remain in browser storage.`);
        }
    }

    if (migrationOccurred) {
        if (blobIdsToDelete.length > 0) {
            const deleteTx = db.transaction('musicFiles', 'readwrite');
            blobIdsToDelete.forEach(id => deleteTx.objectStore('musicFiles').delete(id));
            await deleteTx.done;
        }
        
        await saveSongs();
        Gurasuraisu.showPopup(`Successfully migrated ${blobIdsToDelete.length} songs to use direct file access, freeing up browser storage!`);
    }
}

        // --- GuraAI Music Assistant Integration ---
        const isGuraAiEnabled = localStorage.getItem('aiAssistantEnabled') === 'true';
        let geminiApiKey = localStorage.getItem('geminiApiKey') || '';
        let genAI;
        let musicAiModel;

        // Utility function to format the user's library for the AI prompt
        function formatLibraryForPrompt(songList = songs) {
            if (songList.length === 0) return "The user's library is empty.";
            // Create a concise string representation of the music library
            return songList.map(s => `${s.artist} - ${s.name}`).join('\n');
        }

async function initializeMusicAi() {
    if (!isGuraAiEnabled) return;

    if (!geminiApiKey) {
        console.warn("GuraAI is enabled, but no API key is set. AI features will be disabled.");
        return;
    }

    try {
        // Dynamically import the AI library only if needed
        const { GoogleGenerativeAI } = await import("https://esm.sh/@google/generative-ai");
        genAI = new GoogleGenerativeAI(geminiApiKey);

        const systemInstruction = `You are GuraAI, an intelligent music assistant integrated into a music player. Your goal is to help users discover music and manage their library. You will be given a list of songs from the user's library as context. Based on the user's prompt, you must call one of the available functions. Your primary task is to select relevant songs from the provided library list. Do not respond with conversational text; only use function calls.`;

        const tools = [{
            "functionDeclarations": [
                {
                    "name": "createPlaylist",
                    "description": "Creates a new playlist.",
                    "parameters": {
                        "type": "OBJECT",
                        "properties": {
                            "playlistName": { "type": "STRING", "description": "A suitable name for the new playlist, derived from the user's prompt." },
                            "songs": { "type": "ARRAY", "items": { "type": "STRING" }, "description": "An array of song titles selected from the user's library that match the prompt's theme. Format each string as 'Artist - Title'." }
                        },
                        "required": ["playlistName", "songs"]
                    }
                },
                {
                    "name": "getSongRecommendations",
                    "description": "Selects and returns a list of songs from the user's library based on a theme, genre, artist, or the user's listening history.",
                    "parameters": {
                        "type": "OBJECT",
                        "properties": {
                            "songs": { "type": "ARRAY", "items": { "type": "STRING" }, "description": "An array of recommended song titles from the user's library. Format each string as 'Artist - Title'." }
                        },
                        "required": ["songs"]
                    }
                }
            ]
        }];
        
        musicAiModel = genAI.getGenerativeModel({
            model: "gemini-2.5-flash-lite", // Using a powerful model for better selections
            tools: tools,
            systemInstruction: systemInstruction,
        });

        console.log("GuraAI Music Assistant Initialized.");
    } catch (error) {
        console.error("GuraAI Music Assistant Initialization failed:", error);
    }
}

// Helper function to find a song object from a string like "Artist - Title"
function findSongByString(artistTitleString, additionalSongs = []) {
    if (!artistTitleString) return null;

    const fullLibrary = [...songs, ...additionalSongs];
    const cleanInput = artistTitleString.trim().toLowerCase();

    // --- New, More Robust Matching Logic ---

    // 1. First, try for a perfect "Artist - Title" match.
    const lastHyphenIndex = cleanInput.lastIndexOf(' - ');
    if (lastHyphenIndex > 0) {
        const artist = cleanInput.substring(0, lastHyphenIndex).trim();
        const title = cleanInput.substring(lastHyphenIndex + 3).trim();
        const perfectMatch = fullLibrary.find(song =>
            song.artist.toLowerCase() === artist && song.name.toLowerCase() === title
        );
        if (perfectMatch) return perfectMatch;
    }

    // 2. If no perfect match, fall back to a more flexible "contains" search.
    // This is great for when the AI returns just a title or a slightly incorrect format.
    const partialMatch = fullLibrary.find(song => 
        song.name.toLowerCase().includes(cleanInput) || 
        cleanInput.includes(song.name.toLowerCase())
    );
    if (partialMatch) return partialMatch;

    return null; // Return null if no match is found after all attempts.
}

const availableMusicFunctions = {
    createPlaylist: async ({ playlistName, songs: songStrings }) => {
        const songIds = songStrings.map(s => findSongByString(s)).filter(Boolean).map(s => s.id);
        
        if (songIds.length === 0) {
            Gurasuraisu.showPopup(`GuraAI couldn't find matching songs.`);
            return;
        }

        const newPlaylist = { name: playlistName, songIds: songIds };
        const tx = db.transaction('playlists', 'readwrite');
        const request = tx.objectStore('playlists').add(newPlaylist);
        
        await new Promise(resolve => {
            tx.oncomplete = () => {
                newPlaylist.id = request.result;
                resolve();
            };
        });

        playlists.push(newPlaylist);
        Gurasuraisu.showPopup(`GuraAI created playlist: "${playlistName}"`);
        if (activeView === 'library') renderLibraryPage();
    }
    // getSongRecommendations is handled directly by the calling function, so it doesn't need an entry here.
};

        /**
         * Takes an image source URL and creates a new, small, downscaled version of it.
         * This is the key to the performance improvement, as the animation loop
         * will only ever process these small images.
         * @param {string} src - The source URL of the high-resolution image.
         * @param {number} maxSize - The maximum width or height of the output image.
         * @returns {Promise<HTMLImageElement>} A promise that resolves with the new, loaded, resized image.
         */
        function createResizedImage(src, maxSize) {
            return new Promise((resolve, reject) => {
                const highResImage = new Image();
                highResImage.crossOrigin = 'Anonymous';
                highResImage.onload = () => {
                    const canvas = document.createElement('canvas');
                    const context = canvas.getContext('2d');
                    let { width, height } = highResImage;

                    // Calculate new dimensions while maintaining aspect ratio
                    if (width > height) {
                        if (width > maxSize) {
                            height *= maxSize / width;
                            width = maxSize;
                        }
                    } else {
                        if (height > maxSize) {
                            width *= maxSize / height;
                            height = maxSize;
                        }
                    }
                    canvas.width = width;
                    canvas.height = height;

                    // Draw the high-res image onto the small canvas
                    context.drawImage(highResImage, 0, 0, width, height);
                    
                    // Create a new Image object from the small canvas data
                    const resizedImage = new Image();
                    resizedImage.onload = () => resolve(resizedImage);
                    resizedImage.onerror = reject;
                    resizedImage.src = canvas.toDataURL('image/jpeg', 0.8); // Use JPEG for better compression
                };
                highResImage.onerror = reject;
                highResImage.src = src;
            });
        }

        /**
         * A self-contained 3D Perlin noise generator.
         * Using a third dimension (z) for time allows the blob shapes to continuously evolve.
         */
        function createNoiseGenerator() {
            const p = new Uint8Array(512);
            for (let i = 0; i < 256; i++) p[i] = i;
            for (let i = 255; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [p[i], p[j]] = [p[j], p[i]];
            }
            for (let i = 0; i < 256; i++) p[i + 256] = p[i];

            const fade = t => t * t * t * (t * (t * 6 - 15) + 10);
            const lerp = (a, b, t) => a + t * (b - a);
            const grad = (hash, x, y, z) => {
                const h = hash & 15;
                const u = h < 8 ? x : y;
                const v = h < 4 ? y : h === 12 || h === 14 ? x : z;
                return ((h & 1) === 0 ? u : -u) + ((h & 2) === 0 ? v : -v);
            };

            return (x, y, z) => {
                const X = Math.floor(x) & 255, Y = Math.floor(y) & 255, Z = Math.floor(z) & 255;
                x -= Math.floor(x); y -= Math.floor(y); z -= Math.floor(z);
                const u = fade(x), v = fade(y), w = fade(z);
                const a = p[X] + Y, b = p[X + 1] + Y;
                const a1 = p[a] + Z, a2 = p[a + 1] + Z;
                const b1 = p[b] + Z, b2 = p[b + 1] + Z;

                return lerp(
                    lerp(
                        lerp(grad(p[a1], x, y, z), grad(p[b1], x - 1, y, z), u),
                        lerp(grad(p[a2], x, y - 1, z), grad(p[b2], x - 1, y - 1, z), u),
                    v),
                    lerp(
                        lerp(grad(p[a1 + 1], x, y, z - 1), grad(p[b1 + 1], x - 1, y, z - 1), u),
                        lerp(grad(p[a2 + 1], x, y - 1, z - 1), grad(p[b2 + 1], x - 1, y - 1, z - 1), u),
                    v),
                w) * 0.5 + 0.5; // Return in 0-1 range
            };
        }

        /**
         * Initializes a LOW-RESOLUTION canvas and starts the animation. The canvas element
         * itself will be stretched by CSS to fill the screen.
         */
        function initDistortionCanvas() {
            // This constant defines our rendering resolution. 0.25 means 25% of the screen size.
            // A lower number means better performance but a more pixelated (though blurred) source.
            const RENDER_SCALE = 0.25;

            distortionCanvas = document.getElementById('distortionCanvas');
            if (!distortionCanvas) {
                console.error("Distortion Canvas not found in the DOM.");
                return;
            }
            
            ctx = distortionCanvas.getContext('2d'); 
            if (!ctx) {
                console.error("Failed to get 2D context from the canvas.");
                return;
            }
            
            noise = createNoiseGenerator();

            currentResizedArt.crossOrigin = 'Anonymous';
            oldResizedArt.crossOrigin = 'Anonymous';
            currentResizedArt.onerror = () => console.error("Failed to load current resized album art image.");
            oldResizedArt.onerror = () => console.error("Failed to load old resized album art image for transition.");

            const resizeCanvas = () => {
                // Set the canvas's actual drawing buffer size to be a fraction of the window size.
                // For a 1920x1080 screen, this creates a tiny 480x270 canvas to draw on.
                distortionCanvas.width = window.innerWidth * RENDER_SCALE;
                distortionCanvas.height = window.innerHeight * RENDER_SCALE;

                // The CSS `width: 100%` will stretch this small buffer to fill the screen.
                
                if (currentResizedArt.src) {
                    setTimeout(initBlobs, 100);
                }
            };
            window.addEventListener('resize', resizeCanvas);
            resizeCanvas();
        }

        /**
         * Asynchronously loads, resizes, and initiates a smooth transition for new album art.
         * This version includes a full state reset when imageUrl is empty, fixing the bug after resetPlayer.
         * @param {string} imageUrl - The URL of the new high-resolution album art.
         */
        async function loadAlbumArtForCanvas(imageUrl) {
            // If imageUrl is empty, it's a hard reset call from resetPlayer().
            if (!imageUrl) {
                // Clear both image sources to prevent any drawing.
                currentResizedArt.src = '';
                oldResizedArt.src = '';
                // Clear the blobs array.
                blobs = [];
                // Explicitly stop any ongoing transition and reset its progress.
                isTransitioning = false;
                transitionProgress = 0;
                return; // End the function here.
            }

            // The rest of the function only runs if we have a valid imageUrl.
            if (currentResizedArt.src && currentResizedArt.dataset.originalUrl === imageUrl) return;

            try {
                if (currentResizedArt.complete && currentResizedArt.src) {
                    oldResizedArt = currentResizedArt;
                }

                const smallImageUrl = getLowResArtUrl(imageUrl);
                const newResized = await createResizedImage(smallImageUrl, 64);
                newResized.dataset.originalUrl = imageUrl;
                currentResizedArt = newResized;

                // Start a new transition.
                isTransitioning = true;
                transitionProgress = 0;
                initBlobs();

            } catch (error) {
                console.error("Failed to resize and load album art:", error);
            }
        }

        /**
         * Creates blobs with density and size optimized for the device type.
         * On mobile, it uses fewer, larger blobs for better performance and visual clarity.
         * On desktop, it uses many smaller blobs for a dense, active background.
         */
        function initBlobs() {
            if (!distortionCanvas || !ctx || !currentResizedArt.complete) return;
            blobs = [];
            const { width: imgWidth, height: imgHeight } = currentResizedArt;
            const { width: canvasWidth, height: canvasHeight } = distortionCanvas;
            
            // --- Conditional Parameters for Mobile vs. Desktop ---
            let blobCount;
            let minRadiusMultiplier, radiusVariance;
            const maxSpeed = 0.5;

            if (isMobile) {
                // Mobile Configuration: Fewer, larger blobs.
                blobCount = 3;
                // Radius will be between 40% and 60% of the smaller canvas dimension to fill the screen.
                minRadiusMultiplier = 0.4; 
                radiusVariance = 0.2;
            } else {
                // Desktop Configuration: More, smaller blobs.
                blobCount = 15;
                // Radius will be between 15% and 25% of the smaller canvas dimension.
                minRadiusMultiplier = 0.15;
                radiusVariance = 0.1;
            }

            for (let i = 0; i < blobCount; i++) { // Use the dynamically set blobCount
                
                // Use the dynamic multipliers to calculate the radius for the current device.
                const radius = (Math.random() * radiusVariance + minRadiusMultiplier) * Math.min(canvasWidth, canvasHeight);

                // This logic for assigning a unique part of the album art remains the same.
                const sourceSize = Math.min(imgWidth, imgHeight) * (Math.random() * 0.3 + 0.3);
                const sourceX = Math.random() * (imgWidth - sourceSize);
                const sourceY = Math.random() * (imgHeight - sourceSize);

                blobs.push({
                    x: Math.random() * canvasWidth,
                    y: Math.random() * canvasHeight,
                    vx: (Math.random() - 0.5) * maxSpeed,
                    vy: (Math.random() - 0.5) * maxSpeed,
                    radius: radius,
                    rotation: Math.random() * Math.PI * 2,
                    rotationSpeed: (Math.random() - 0.5) * 0.002,
                    sourceX: sourceX,
                    sourceY: sourceY,
                    sourceSize: sourceSize,
                    time: Math.random() * 1000,
                    warpAmount: 0,
                    baseWarp: radius * 0.1,
                    contrast: 1,
                    scale: 1,
                });
            }
        }

        /**
         * Draws a single blob, adding animations based on the global beat intensity.
         * Each blob will now pulse in size and get a rotational "kick" on the beat.
         * @param {CanvasRenderingContext2D} context - The canvas context to draw on.
         * @param {object} blob - The blob object containing its properties.
         * @param {HTMLImageElement} imageToDraw - The pre-resized album art.
         * @param {number} currentBeatIntensity - The global beat intensity (0 to 1).
         */
        function drawOrganicBlob(context, blob, imageToDraw, currentBeatIntensity) {
            context.save();
            
            // --- Apply Beat Animations ---
            // 1. Calculate an effective scale for the blob (base size + beat pulse).
            const effectiveScale = 1 + currentBeatIntensity * 0.05; // 5% size increase on beat
            // 2. Calculate an effective rotation (base rotation + beat kick).
            const effectiveRotation = blob.rotation + currentBeatIntensity * 0.075; // Add a rotational nudge

            context.translate(blob.x, blob.y);
            context.rotate(effectiveRotation); // Use the animated rotation
            
            context.beginPath();
            const points = 20;
            const noiseFrequency = 1.8;
            const noiseSpeed = 0.004;
            
            for (let i = 0; i < points; i++) {
                const angle = (i / points) * Math.PI * 2;
                const x = Math.cos(angle);
                const y = Math.sin(angle);
                const noiseVal = noise((x + 1) * noiseFrequency, (y + 1) * noiseFrequency, blob.time * noiseSpeed);
                
                // Use the animated scale to calculate the radius for this frame
                const radius = blob.radius * effectiveScale + (noiseVal * blob.radius * 0.3);

                const pointX = x * radius;
                const pointY = y * radius;
                if (i === 0) context.moveTo(pointX, pointY);
                else context.lineTo(pointX, pointY);
            }
            context.closePath();
            context.clip();
            
            // The liquid strip effect (unchanged)
            const totalWarp = blob.baseWarp + Math.sin(blob.time * 0.1) * (blob.baseWarp * 0.5);
            const numStrips = 30;
            const stripWidth = (blob.radius * 2 * effectiveScale) / numStrips; // Use effectiveScale here too
            for (let i = 0; i < numStrips; i++) {
                const stripX = -blob.radius * effectiveScale + i * stripWidth;
                const sinInput = (i / numStrips) * Math.PI + blob.time * 0.1;
                const yOffset = Math.sin(sinInput) * totalWarp;
                
                context.drawImage(
                    imageToDraw,
                    blob.sourceX + (blob.sourceSize / numStrips) * i, blob.sourceY,
                    blob.sourceSize / numStrips, blob.sourceSize,
                    stripX, -blob.radius * effectiveScale + yOffset,
                    stripWidth + 1, blob.radius * 2 * effectiveScale
                );
            }

            context.restore();
        }

        /**
         * The animation loop, now featuring a global canvas distortion on beat
         * and passing the beat intensity down to each blob for synchronized animation.
         */
        function animateCanvas() {
            animationFrameId = requestAnimationFrame(animateCanvas);
            if (!ctx) return;
            
            const { width: canvasWidth, height: canvasHeight } = distortionCanvas;
            
            ctx.clearRect(0, 0, canvasWidth, canvasHeight);

            // --- Beat Effect Logic ---
            const BEAT_DECAY_SPEED = 0.95; // Controls how fast the effect fades out (closer to 1 is slower)

            // If a beat is active, smoothly decay the intensity on every frame.
            if (beatIntensity > 0.001) {
                beatIntensity *= BEAT_DECAY_SPEED;
            } else {
                beatIntensity = 0; // Clamp to zero to prevent tiny residual values
            }

            // --- Background Rotation and Drawing (Unchanged) ---
            backgroundRotation += 0.002;
            if (isTransitioning) {
                transitionProgress += 1 / TRANSITION_DURATION;
                if (transitionProgress >= 1) {
                    transitionProgress = 1; isTransitioning = false; oldResizedArt = new Image();
                }
            }
            const drawRotatingBackground = (image) => {
                const scale = 1.5; // Draw larger to prevent corners from appearing during rotation
                ctx.save();
                ctx.translate(canvasWidth / 2, canvasHeight / 2);
                ctx.rotate(backgroundRotation);
                ctx.drawImage(image, 
                    -canvasWidth * scale / 2, -canvasHeight * scale / 2, 
                    canvasWidth * scale, canvasHeight * scale
                );
                ctx.restore();
            };
            if (isTransitioning && oldResizedArt.complete && oldResizedArt.src) {
                ctx.globalAlpha = 1 - transitionProgress;
                drawRotatingBackground(oldResizedArt);
            }
            if (currentResizedArt.complete && currentResizedArt.src) {
                ctx.globalAlpha = isTransitioning ? transitionProgress : 1;
                drawRotatingBackground(currentResizedArt);
            }
            ctx.globalAlpha = 1;
            
            // --- Update and Draw Blobs ---
            blobs.forEach(blob => {
                // Blob movement logic is unchanged
                blob.x += blob.vx;
                blob.y += blob.vy;
                blob.rotation += blob.rotationSpeed;
                const radius = blob.radius * (1 + beatIntensity * 0.1); // Use an effective radius for wrapping
                if (blob.x - radius > canvasWidth) { blob.x = -radius; } 
                else if (blob.x + radius < 0) { blob.x = canvasWidth + radius; }
                if (blob.y - radius > canvasHeight) { blob.y = -radius; } 
                else if (blob.y + radius < 0) { blob.y = canvasHeight + radius; }

                blob.time += 0.1;

                // --- Draw Blobs with Transition and Beat Intensity ---
                // Pass the decaying `beatIntensity` to the drawing function
                if (isTransitioning && oldResizedArt.complete && oldResizedArt.src) {
                    ctx.globalAlpha = 1 - transitionProgress;
                    drawOrganicBlob(ctx, blob, oldResizedArt, beatIntensity);
                }
                if (currentResizedArt.complete && currentResizedArt.src) {
                    ctx.globalAlpha = isTransitioning ? transitionProgress : 1;
                    drawOrganicBlob(ctx, blob, currentResizedArt, beatIntensity);
                }
                ctx.globalAlpha = 1;
            });

            // 3. If a beat was active, restore the canvas from the global distortion.
            if (beatIntensity > 0.001) {
                ctx.restore();
            }
        }
        
        /**
         * Triggers the global beat effect by setting the intensity to its maximum.
         * The animateCanvas function will handle the decay and animation.
         */
        function triggerBeatEffect() {
            beatIntensity = 1;
        }
        
async function createResizedImageURL(imageUrl, width, height) {
    return new Promise((resolve, reject) => {
        const img = new Image();
        if (!imageUrl.startsWith('data:')) {
            img.crossOrigin = 'Anonymous';
        }
        
        img.onload = () => {
            const canvas = document.createElement('canvas');
            canvas.width = width;
            canvas.height = height;
            const ctx = canvas.getContext('2d');
            ctx.drawImage(img, 0, 0, width, height);
            resolve(canvas.toDataURL('image/jpeg', 0.8)); 
        };
        
        img.onerror = (err) => {
            console.error("Failed to load image for resizing.", err);
            reject(imageUrl); 
        };
        
        img.src = imageUrl;
    });
}

async function updateAllBackgrounds(imageUrl) {
    loadAlbumArtForCanvas(imageUrl);
}

class BeatDetector {
    constructor(frequencyBands, historySize = 60, minThreshold = 5) {
        this.frequencyBands = frequencyBands;
        this.historySize = historySize;
        this.minFluxThreshold = minThreshold;
        this.fluxHistories = this.frequencyBands.map(() => []);
        this.lastEnergies = new Array(this.frequencyBands.length).fill(0);
        this.beatValue = 0.0;
        this.decayRate = 0.96;
        this.dynamicSensitivity = 1.4;
        this.minSensitivity = 1.2;
        this.maxSensitivity = 2.4;
        this.increaseFactor = 1.05;
        this.decreaseFactor = 0.999;
    }

    _calculateStandardDeviation(array, mean) {
        if (array.length < 2) return 0;
        const variance = array.reduce((acc, val) => acc + (val - mean) ** 2, 0) / array.length;
        return Math.sqrt(variance);
    }

    update(dataArray) {
        let beatDetectedThisFrame = false;

        for (let i = 0; i < this.frequencyBands.length; i++) {
            const band = this.frequencyBands[i];
            const history = this.fluxHistories[i];
            
            let currentEnergy = 0;
            for (let j = band[0]; j <= band[1]; j++) currentEnergy += dataArray[j];
            currentEnergy /= (band[1] - band[0] + 1);

            const flux = Math.max(0, currentEnergy - this.lastEnergies[i]);
            this.lastEnergies[i] = currentEnergy;

            if (history.length < this.historySize) {
                history.push(flux);
                continue;
            }
            
            const averageFlux = history.reduce((a, b) => a + b, 0) / history.length;
            const stdDev = this._calculateStandardDeviation(history, averageFlux);
            const dynamicThreshold = averageFlux + (this.dynamicSensitivity * stdDev);

            if (flux > dynamicThreshold && flux > this.minFluxThreshold) {
                beatDetectedThisFrame = true;
            }

            history.push(flux);
            history.shift();
        }

        if (beatDetectedThisFrame) {
            this.beatValue = 1.0;
            this.dynamicSensitivity *= this.increaseFactor;
        } else {
            this.beatValue *= this.decayRate;
            this.dynamicSensitivity *= this.decreaseFactor;
        }
        
        this.dynamicSensitivity = Math.max(this.minSensitivity, Math.min(this.maxSensitivity, this.dynamicSensitivity));
        return this.beatValue;
    }
}

function initVisualizer() {
    if (document.body.classList.contains('reduce-animations')) {
        const canvas = document.getElementById('visualizerCanvas');
        if (canvas) canvas.style.display = 'none';
        return; 
    }

    if (isVisualizerInitialized) return;

    try {
        audioContext = new (window.AudioContext || window.webkitAudioContext)();
        
        eqBass = audioContext.createBiquadFilter();
        eqMid = audioContext.createBiquadFilter();
        eqTreble = audioContext.createBiquadFilter();
        eqBass.type = 'lowshelf'; eqBass.frequency.value = 300; 
        eqMid.type = 'peaking'; eqMid.frequency.value = 1000; eqMid.Q.value = 1; 
        eqTreble.type = 'highshelf'; eqTreble.frequency.value = 3000;
        
        analyser = audioContext.createAnalyser();
        
        source = audioContext.createMediaElementSource(audioPlayer);

        source.connect(eqBass);
        eqBass.connect(eqMid);
        eqMid.connect(eqTreble);
        eqTreble.connect(analyser);
        analyser.connect(audioContext.destination);

        if (isMobile) {
            analyser.fftSize = 64;
        } else {
            analyser.fftSize = 2048;
        }
        
        analyser.smoothingTimeConstant = 0.8;
        const bufferLength = analyser.frequencyBinCount;
        const dataArray = new Uint8Array(bufferLength);
        
        const displacementFilter = document.getElementById('displacement');
        const turbulenceFilter = document.getElementById('turbulence');

        const baselineDistortion = 80;
        const peakDistortion = 250;

        let beatDetector;
        if (!isMobile) {
            beatDetector = new BeatDetector([[0, 10], [20, 50], [80, 120]]);
        }
        
        const canvas = document.getElementById('visualizerCanvas');
        const canvasCtx = canvas.getContext('2d');
        
        // Define separate bar indices for desktop and mobile to match their FFT sizes.
        const desktopBarIndices = [5, 10, 30, 100, 200, 400];
        const mobileBarIndices = [1, 3, 6, 12, 20, 28]; // Mapped to a 32-bin array
        const numBars = 6;
        
        const sensitivityMultipliers = [1, 1.05, 1.1, 1.15, 1.25, 1.4];
        const powerCurve = 2.2;
        
        let smoothedPulse = 0.0; 
        const smoothingFactor = 0.2;

        visualizerDraw = () => {
            visualizerFrameId = requestAnimationFrame(visualizerDraw);
            analyser.getByteFrequencyData(dataArray);

            if (!isMobile) {
                const beatPulseTarget = beatDetector.update(dataArray);
                
                // --- Beat Detection Integration ---
                // If the beat detector returns a strong pulse, trigger our canvas effect.
                if(beatPulseTarget > 0.9) { // 0.9 is a good threshold for a clear beat
                    triggerBeatEffect();
                }

                smoothedPulse += (beatPulseTarget - smoothedPulse) * smoothingFactor;
            }
            
            if (canvas.width !== canvas.clientWidth) canvas.width = canvas.clientWidth;
            if (canvas.height !== canvas.clientHeight) canvas.height = canvas.clientHeight;
            canvasCtx.clearRect(0, 0, canvas.width, canvas.height);
            
            const gap = 2;
            const barWidth = (canvas.width - (numBars - 1) * gap) / numBars;
            const style = getComputedStyle(document.body);
            const textColor = style.getPropertyValue('--text-color').trim() || '#FFFFFF';
            canvasCtx.fillStyle = textColor;

            const indicesToUse = isMobile ? mobileBarIndices : desktopBarIndices;

            for (let i = 0; i < numBars; i++) {
                const x = i * (barWidth + gap);
                const value = Math.min(dataArray[indicesToUse[i]] * sensitivityMultipliers[i], 255);
                const barHeight = Math.pow(value / 255, powerCurve) * canvas.height;
                
                const pillRadius = Math.max(0, barWidth / 2);
                if (barHeight < pillRadius * 2) {
                    const dotRadius = barHeight / 2;
                    if (dotRadius < 1) continue;
                    canvasCtx.globalAlpha = barHeight / (pillRadius * 2);
                    canvasCtx.beginPath();
                    canvasCtx.arc(x + pillRadius, canvas.height / 2, dotRadius, 0, 2 * Math.PI);
                    canvasCtx.fill();
                } else {
                    const y = (canvas.height - barHeight) / 2;
                    canvasCtx.globalAlpha = 1.0;
                    canvasCtx.beginPath();
                    if (canvasCtx.roundRect) {
                        canvasCtx.roundRect(x, y, barWidth, barHeight, pillRadius);
                    } else { // Fallback
                        canvasCtx.rect(x, y, barWidth, barHeight);
                    }
                    canvasCtx.fill();
                }
            }
            canvasCtx.globalAlpha = 1.0;
        }

        isVisualizerInitialized = true;

    } catch(e) {
        console.error("Failed to initialize AudioContext/Visualizer:", e);
    }
}

function processAndSortSongs() {
    const songsByAlbum = songs.reduce((acc, song) => {
        const albumArtistKey = song.albumArtist || 'Unknown Artist';
        const albumKey = `${albumArtistKey}::${song.album || 'Unknown Album'}`;
        if (!acc[albumKey]) acc[albumKey] = [];
        acc[albumKey].push(song);
        return acc;
    }, {});

    for (const albumKey in songsByAlbum) {
        const albumSongs = songsByAlbum[albumKey];
        albumSongs.sort((a, b) => (a.handleName || a.name).localeCompare(b.handleName || b.name));

        let inferredDisc = 1;
        let lastTrack = 0;
        
        albumSongs.forEach(song => {
            if (song.trackNumber !== null && song.trackNumber < lastTrack) {
                inferredDisc++;
            }
            song.effectiveDiscNumber = song.discNumber || inferredDisc;
            lastTrack = song.trackNumber || 0;
        });
    }
}

async function getArtColors(imageUrl) {
    return new Promise((resolve) => {
        const img = new Image();
        img.crossOrigin = 'Anonymous';
        img.src = getLowResArtUrl(imageUrl);
        img.onload = () => {
            const canvas = document.createElement('canvas');
            canvas.width = img.width;
            canvas.height = img.height;
            const ctx = canvas.getContext('2d', { willReadFrequently: true });
            ctx.drawImage(img, 0, 0);
            
            // Get colors from top-left and bottom-right for a simple gradient
            const topLeft = ctx.getImageData(0, 0, 1, 1).data;
            const bottomRight = ctx.getImageData(img.width - 1, img.height - 1, 1, 1).data;

            const color1 = `rgba(${topLeft[0]}, ${topLeft[1]}, ${topLeft[2]}, 0.4)`;
            const color2 = `rgba(${bottomRight[0]}, ${bottomRight[1]}, ${bottomRight[2]}, 0.1)`;
            resolve(`linear-gradient(135deg, ${color1}, ${color2})`);
        };
        img.onerror = () => {
            // Fallback for failed image loads
            resolve('linear-gradient(135deg, rgba(255,255,255,0.1), rgba(255,255,255,0))');
        };
    });
}

async function renderHomePage() {
    const homeView = document.getElementById('home-view');
    if (!homeView) return;

    // --- 1. Fetch all necessary data asynchronously ---
    const topSongsPromise = new Promise(resolve => {
        const tx = db.transaction('songs', 'readonly');
        const index = tx.objectStore('songs').index('playCount');
        const req = index.getAll();
        req.onsuccess = () => resolve(req.result.sort((a,b) => (b.playCount || 0) - (a.playCount || 0)).slice(0, 10));
    });

    const historyPromise = new Promise(resolve => {
        const tx = db.transaction('playHistory', 'readonly');
        const store = tx.objectStore('playHistory');
        const req = store.getAll();
        req.onsuccess = () => resolve(req.result.sort((a,b) => b.timestamp - a.timestamp));
    });

    const [topSongs, history] = await Promise.all([topSongsPromise, historyPromise]);
    // --- 2. Select 4 unique songs for the highlights ---
    
    const highlightSongs = new Set();
    const listenAgainSongs = [];
    if (topSongs.length > 0) {
        listenAgainIndex = (listenAgainIndex + 1) % Math.min(topSongs.length, 10);
        localStorage.setItem('listenAgainIndex', listenAgainIndex);
        listenAgainSongs.push(topSongs[listenAgainIndex]);
        if (topSongs.length > 1) {
            listenAgainSongs.push(topSongs[(listenAgainIndex + 1) % topSongs.length]);
        }
        if (topSongs.length > 2) {
            listenAgainSongs.push(topSongs[(listenAgainIndex + 2) % topSongs.length]);
        }
        if (topSongs.length > 3) {
            listenAgainSongs.push(topSongs[(listenAgainIndex + 3) % topSongs.length]);
        }
    }
    listenAgainSongs.forEach(s => highlightSongs.add(s));

    const recommendations = songs.filter(s => !listenAgainSongs.some(ls => ls.id === s.id));
    for (let i = 0; i < 4 && recommendations.length > 0; i++) {
        const randomIndex = Math.floor(Math.random() * recommendations.length);
        highlightSongs.add(recommendations.splice(randomIndex, 1)[0]);
    }
    
    // --- 3. Build the HTML ---
    const highlights = Array.from(highlightSongs);
    const highlightsHtml = highlights.map((song, i) => {
        const isListenAgain = listenAgainSongs.includes(song);
        return `
        <div class="highlight-card" data-id="${song.id}" id="highlight-${i+1}">
            <img src="${song.albumArt}">
            <div class="highlight-card-info">
                <div class="highlight-card-label">${isListenAgain ? 'Listen Again' : 'From Your Library'}</div>
                <div class="highlight-card-title">${sanitize(song.name)}</div>
                <div class="highlight-card-subtitle">${sanitize(song.artist)}</div>
            </div>
            <span class="material-symbols-rounded highlight-card-play">play_circle</span>
        </div>`;
    }).join('');

    const recentSongIds = [...new Set(history.map(h => h.songId))];
    const recentlyPlayedSongs = recentSongIds.map(id => songs.find(s => s.id === id)).filter(Boolean);
    const recentAlbums = [];
    const recentAlbumIds = new Set();
    for (const song of recentlyPlayedSongs) {
        const albumId = `${song.albumArtist}::${song.album}`;
        if (!recentAlbumIds.has(albumId)) {
            recentAlbumIds.add(albumId);
            recentAlbums.push(song); // Use the song object as a representative for the album
        }
        if (recentAlbums.length >= 40) break; // Limit to 40 albums
    }
    const recentlyPlayedHtml = recentAlbums.map(song => `
         <div class="item-card" data-album-id="${sanitize(song.albumArtist)}::${sanitize(song.album)}">
            <img src="${song.albumArt}" class="item-card-art">
            <div class="item-card-info">
                <div class="item-card-title">${sanitize(song.album)}</div>
                <div class="item-card-subtitle">${sanitize(song.albumArtist)}</div>
            </div>
        </div>
    `).join('');
    
    const genres = [...new Set(songs.map(s => s.genre).filter(Boolean))];
    const genreSectionsHtml = genres.map(genre => {
        const genreSongs = songs.filter(s => s.genre === genre).slice(0, 8);
        return `
        <div>
            <h2 class="section-title">${sanitize(genre)}</h2>
            <div class="item-grid">${genreSongs.map(song => `
                <div class="item-card" data-album-id="${sanitize(song.albumArtist)}::${sanitize(song.album)}">
                    <img src="${song.albumArt}" class="item-card-art">
                    <div class="item-card-info">
                        <div class="item-card-title">${sanitize(song.album)}</div>
                        <div class="item-card-subtitle">${sanitize(song.albumArtist)}</div>
                    </div>
                </div>
            `).join('')}</div> 
        </div>`;
    }).join('');

    // --- GuraAI Section (Now renders a placeholder INSTANTLY) ---
    let aiPromptAreaHtml = '';
    if (isGuraAiEnabled && musicAiModel && songs.length > 5) {
        aiPromptAreaHtml = `
            <div id="ai-prompt-area" style="text-align:center; margin-bottom: 20px;">
                <div id="ai-prompt-bar" style="display:flex; gap:10px; max-width:600px; margin: auto auto 20px; border-bottom: 1px solid var(--search-background); padding-bottom: 10px;">
                    <input type="text" id="aiPromptInput" placeholder="Ask GuraAI" class="library-search-input" style="padding-left:15px;background: none;border: none;font-size: large;font-weight: bold; box-shadow: none; backdrop-filter: none;">
                    <button id="aiPromptSubmit" class="action-btn" style="height:auto; background: none; border: none; box-shadow: none; backdrop-filter: none;"><span class="material-symbols-rounded" style="font-size: 18px;">send</span></button>
                </div>
                <div id="ai-dynamic-prompts" style="display:flex; flex-wrap:wrap; justify-content:center; gap:10px"></div>
            </div>
        `;
    }

    homeView.innerHTML = `
    <div class="page-content-wrapper">
        <h2 class="section-title-fy">Streams</h2>
        <h2 class="section-subtitle">TIDAL</h2>
        ${aiPromptAreaHtml}
        <div class="highlight-grid">${highlightsHtml}</div>
        <div>
            <h2 class="section-title">Recently Played</h2>
            <div class="item-grid">${recentlyPlayedHtml}</div>
        </div>
        ${genreSectionsHtml}
    </div>`;
    
    // --- 4. Asynchronously Apply Gradients ---
    highlights.forEach((song, i) => {
        const card = document.getElementById(`highlight-${i+1}`);
        if (card) {
            if (song.vibrantColor) {
                const color = song.vibrantColor;
                card.style.background = `linear-gradient(135deg, ${color}BF, ${color}33)`;
            } else {
                 getArtColors(song.albumArt).then(gradient => { card.style.background = gradient; });
            }
        }
    });
    
    // --- Asynchronously update AI content ---
    // After the main page has rendered, call the function to fetch and populate AI prompts.
    // We DON'T await this, allowing the UI to be responsive while the AI works.
    if (isGuraAiEnabled && musicAiModel && songs.length > 5) {
        updateAiHomePagePrompts();
    }

    requestAnimationFrame(() => {
        const homeView = document.getElementById('home-view');
        homeView.scrollTop = scrollPositions.home;
    });
}

async function updateAiHomePagePrompts() {
    const promptsContainer = document.getElementById('ai-dynamic-prompts');
    if (!promptsContainer) return;

    promptsContainer.innerHTML = `<button class="action-btn" data-prompt="Create a high-energy playlist">High-energy Playlist</button><button class="action-btn" data-prompt="Find some relaxing songs">Relaxing Songs</button><button class="action-btn" data-prompt="Recommend a genre I might like">Suggest a Genre</button>`;

    let dynamicPromptsHtml = '';
    try {
        // A slightly stronger prompt encouraging the correct format
        const prompt = `Based on the user's library, suggest 3 short, action-oriented prompts for buttons to help them discover music. YOU MUST format your response by calling the 'createPlaylist' function and putting the 3 prompts inside the 'songs' array.

        Library Sample:\n${formatSongsForAiPrompt(songs.slice(0, 50))}`;
        
        const result = await musicAiModel.generateContent(prompt);
        const response = result.response;
        const call = response.functionCalls()?.[0];
        let promptIdeas = [];

        // --- THE FIX: Intelligent Fallback Logic ---
        if (call && call.name === 'createPlaylist' && call.args.songs) {
            // Path 1: The AI worked perfectly and used the function tool.
            console.log("AI responded with a function call.");
            promptIdeas = call.args.songs.slice(0, 3);
        } else {
            // Path 2: The AI responded with plain text. We will parse it.
            console.log("AI responded with plain text, parsing fallback.");
            const textResponse = response.text();
            if (textResponse) {
                // Parse a string like: "Prompt 1", "Prompt 2", "Prompt 3"
                promptIdeas = textResponse.split(',') // Split by comma
                                        .map(p => p.trim().replace(/"/g, '')) // Remove whitespace and quotes
                                        .filter(p => p.length > 5) // Filter out any empty strings
                                        .slice(0, 3);
            }
        }

        if (promptIdeas.length > 0) {
            dynamicPromptsHtml = promptIdeas.map(p => `<button class="action-btn" data-prompt="${sanitize(p)}">${sanitize(p)}</button>`).join('');
        } else {
            // This now only runs if both the function call AND text parsing fail.
            throw new Error("AI did not return any valid prompts in any format.");
        }
    } catch (e) {
        console.error("AI dynamic prompt generation failed:", e);
        // On error, provide useful static fallback prompts
        dynamicPromptsHtml = `<button class="action-btn" data-prompt="Create a high-energy playlist">High-energy Playlist</button><button class="action-btn" data-prompt="Find some relaxing songs">Relaxing Songs</button><button class="action-btn" data-prompt="Recommend a genre I might like">Suggest a Genre</button>`;
    }

    // Update the container with the final HTML (either from AI or fallback)
    promptsContainer.innerHTML = dynamicPromptsHtml;
}

function renderLibraryPage() {
    const libraryView = document.getElementById('library-view');
    const libraryGrid = document.getElementById('library-grid');
    if (!libraryGrid) return;

    // --- RENDER MAIN LIBRARY VIEW ---
    const searchFilteredSongs = songs; // No search bar here anymore

    if (searchFilteredSongs.length === 0) {
        libraryGrid.innerHTML = `<div class="no-results" style="grid-column: 1 / -1;"><span class="material-symbols-rounded">library_music</span><p>You have nothing owned.</p><p style="font-size: 0.8em; color: var(--secondary-text-color);">Enable Streaming, then open Discover to start saving songs.</p></div>`;
        return;
    }
    
    let itemsHtml = ''; // Declare itemsHtml here

    switch (currentFilter) {
        case 'artists':
            libraryGrid.className = 'item-grid';
            const artistsMap = new Map();
            searchFilteredSongs.forEach(song => {
                const artist = song.artist || 'Unknown Artist';
                if (!artistsMap.has(artist)) {
                    artistsMap.set(artist, song.albumArt);
                }
            });
            let artistsList = Array.from(artistsMap.entries());
            if (currentSortMode === 'alpha') artistsList.sort((a, b) => a[0].localeCompare(b[0]));
            
            itemsHtml = artistsList.map(([artist, art]) => `
                <div class="item-card" data-artist-name="${artist}">
                    <img src="${art || generateRandomGradient()}" alt="${artist}" class="item-card-art" style="border-radius: 50%;">
                    <div class="item-card-info" style="text-align: center;">
                        <div class="item-card-title">${sanitize(artist)}</div>
                    </div>
                </div>`).join('');
            break;
        
        case 'songs':
            libraryGrid.className = 'item-list'; // Enforce list view
            const sortedSongs = [...searchFilteredSongs]; // Create a copy to sort
             if (currentSortMode === 'alpha') searchFilteredSongs.sort((a,b) => a.name.localeCompare(b.name));
             else searchFilteredSongs.sort((a,b) => b.dateAdded - a.dateAdded);

            itemsHtml = searchFilteredSongs.map(song => `
                <div class="music-item" data-id="${song.id}" style="cursor: pointer;">
                     <div class="song-info">
                        <img src="${song.albumArt}" class="album-thumbnail" style="width: 40px; height: 40px; scale: 1.2; border-radius: 8px; margin-right: 10px;">
                        <div>
                            <div class="song-title" style="white-space: normal;">${sanitize(song.name)}</div>
                            <div class="album-artist" style="font-size: 0.8em;">${sanitize(song.artist)}</div>
                        </div>
                    </div>
                </div>
            `).join('');
            break;

        case 'playlists':
            libraryGrid.className = 'item-grid';
            
            // Generate the HTML for the user's existing playlists first
            itemsHtml = playlists.map(p => {
                const playlistSongs = p.songIds.map(id => songs.find(s => s.id === id)).filter(Boolean);
                const art = playlistSongs.length > 0 ? playlistSongs[0].albumArt : generateRandomGradient();
                return `
                <div class="item-card" data-playlist-id="${p.id}">
                    <img src="${art}" alt="${p.name}" class="item-card-art">
                    <div class="item-card-info">
                        <div class="item-card-title">${sanitize(p.name)}</div>
                        <div class="item-card-subtitle">${playlistSongs.length} songs</div>
                    </div>
                </div>`;
            }).join('');
        
            // Now, generate the AI creator section ONLY if AI is enabled
            if (isGuraAiEnabled && musicAiModel) {
                const aiPlaylistSection = `
                    <div id="ai-playlist-creator" style="grid-column: 1 / -1; margin: 20px auto 0 auto; max-width: 600px; text-align: center;">
                        <div style="display: flex; gap: 10px;">
                            <input type="text" id="aiPlaylistPrompt" placeholder="Create a Playlist with GuraAI" class="library-search-input" style="padding-left: 15px;">
                            <button id="aiCreatePlaylistBtn" class="action-btn" style="height: auto;"><span class="material-symbols-rounded" style="font-size: 18px;">add</span></button>
                        </div>
                    </div>
                `;
                // Append the AI section to the end of the playlists HTML
                itemsHtml += aiPlaylistSection;
            }
            break;

        case 'albums':
        default:
            libraryGrid.className = 'item-grid'; // Enforce grid view
            const albums = groupSongsByAlbum(searchFilteredSongs);
            itemsHtml = albums.map(album => {
                const albumId = `${album.artist}::${album.originalAlbum}`;
                return `
                <div class="item-card" data-album-id="${albumId}">
                    <img src="${album.albumArt}" alt="${album.name}" class="item-card-art">
                    <div class="item-card-info">
                        <div class="item-card-title">${sanitize(album.name)}</div>
                        <div class="item-card-subtitle">${sanitize(album.artist)}</div>
                    </div>
                </div>`;
            }).join('');
            break;
    }
    
    libraryGrid.innerHTML = itemsHtml;
    
    // --- SCROLL RESTORATION LOGIC ---
    requestAnimationFrame(() => {
        const libraryView = document.getElementById('library-view');
        libraryView.scrollTop = scrollPositions.library;
    });
}
        
function renderPlaylists() {
    const musicListContainer = document.querySelector('.music-list');
    musicListContainer.innerHTML = ''; 

    if (playlists.length === 0) {
        musicListContainer.innerHTML = '<div class="no-results"><span class="material-symbols-rounded">playlist_add</span><p>No playlists to add to</p><p style="font-size: 0.8em; color: var(--secondary-text-color);">Create one from the "More Options" menu while a song is playing.</p></div>';
        return;
    }

    playlists.forEach(playlist => {
        const playlistSongs = playlist.songIds.map(id => songs.find(s => s.id === id)).filter(Boolean);
        const albumArt = playlistSongs.length > 0 ? playlistSongs[0].albumArt : generateRandomGradient();
        
        const item = document.createElement('div');
        item.className = 'music-item';
        item.style.position = 'relative'; 
        item.innerHTML = `
            <div class="song-info">
                <img src="${albumArt}" class="album-thumbnail" style="width: 40px; height: 40px; border-radius: 8px; margin-right: 5px;">
                <div>
                    <div class="song-title" style="font-size: 1em; margin-bottom: 2px; white-space: normal;">${playlist.name}</div>
                    <div class="album-artist" style="font-size: 0.8em;">${playlistSongs.length} songs</div>
                </div>
            </div>
            <button class="remove-from-queue-btn" onclick="deletePlaylist(${playlist.id}, event)" style="position: absolute; right: 10px; top: 50%; transform: translateY(-50%);">
                <span class="material-symbols-rounded" style="font-size: 14px;">cancel</span>
            </button>`;
        
        item.addEventListener('click', (e) => {
            if (e.target.closest('button')) return; 
            renderPlaylistSongs(playlist.id);
        });

        musicListContainer.appendChild(item);
    });
}

function renderPlaylistSongs(playlistId) {
    activePlaylistId = playlistId;
    const playlist = playlists.find(p => p.id === playlistId);
    if (!playlist) return;

    const musicListContainer = document.querySelector('.music-list');
    musicListContainer.innerHTML = '';

    const playlistSongs = playlist.songIds.map(id => songs.find(s => s.id === id)).filter(Boolean);

    if (playlistSongs.length === 0) {
        musicListContainer.insertAdjacentHTML('beforeend', '<div class="no-results"><p>This playlist is empty.</p></div>');
        return;
    }

    const songsHtml = playlistSongs.map(song => `
        <div class="music-item ${song.id === currentSongId ? "active" : ""}" data-id="${song.id}">
            <div class="song-info">
                <img src="${song.albumArt}" class="album-thumbnail" style="width: 40px; height: 40px; scale: 1.2; border-radius: 8px; margin-right: 10px;">
                <div>
                    <div class="song-title" style="font-size: 1em; margin-bottom: 2px; white-space: normal;">${song.name}</div>
                    <div class="album-artist" style="font-size: 0.8em;">${sanitize(song.artist)}</div>
                </div>
                <button class="remove-from-queue-btn" onclick="removeSongFromPlaylist(${song.id}, ${playlist.id}, event)" style="margin-left: auto;">
                    <span class="material-symbols-rounded" style="font-size: 14px;">cancel</span>
                </button>
            </div>
        </div>
    `).join('');

    musicListContainer.insertAdjacentHTML('beforeend', songsHtml);
    
    musicListContainer.querySelectorAll('.music-item').forEach(item => {
        item.addEventListener('click', (e) => {
            if (e.target.closest('button')) return;
            const songId = parseFloat(item.dataset.id);
            const songToPlay = songs.find(s => s.id === songId);
            if (songToPlay) playSong(songToPlay);
        });
    });
}
        
async function deletePlaylist(playlistId) {
    const playlist = playlists.find(p => p.id === playlistId);
    if (!playlist) return;

    if (confirm(`Are you sure you want to permanently delete the playlist "${playlist.name}"?`)) {
        // 1. Remove the playlist from the in-memory array.
        playlists = playlists.filter(p => p.id !== playlistId);

        // 2. Remove the playlist from the IndexedDB database.
        const tx = db.transaction('playlists', 'readwrite');
        tx.objectStore('playlists').delete(playlistId);
        await tx.done;

        // 3. Close the drawer, as its content is now invalid.
        closeDrawer();

        // 4. Notify the user and refresh the library view.
        Gurasuraisu.showPopup(`Playlist "${playlist.name}" deleted`);
        if (activeView === 'library') {
            renderLibraryPage(); 
        }
    }
}

async function removeSongFromPlaylist(songId, playlistId, event) {
    event.stopPropagation();
    const playlist = playlists.find(p => p.id === playlistId);
    const song = songs.find(s => s.id === songId);
    if (!playlist || !song) return;

    playlist.songIds = playlist.songIds.filter(id => id !== songId);

    const tx = db.transaction('playlists', 'readwrite');
    tx.objectStore('playlists').put(playlist);
    await tx.done;
    
    showPopupMessage(`Removed "${song.name}" from "${playlist.name}"`);
    renderPlaylistSongs(playlistId);
}
        
function renderSongs(albums, isArtistView = false) {
  const musicListContainer = document.querySelector('.music-list');
  
  if (!albums || albums.length === 0) {
    musicListContainer.innerHTML = '<div class="no-results"><span class="material-symbols-rounded">search_off</span><p>No songs found</p></div>';
    return;
  }
  
  musicListContainer.innerHTML = albums.map(album => `
    <div class="album-section" 
         data-album-artist="${album.artist}" 
         data-album-name="${album.originalAlbum}">
      <div class="album-header">
        <img src="${album.albumArt}" alt="${album.name}" class="album-thumbnail">
        <div class="album-info">
          <div class="album-name">${album.name}</div>
          ${isArtistView ? '' : `<div class="album-artist">${album.artist}</div>`}
          <div class="album-year">${album.year}</div>
        </div>
      </div>
      <div class="album-songs">
        ${album.songs.map(song => `
          <div class="music-item ${song.id === currentSongId ? "active" : ""}" data-id="${song.id}">
            <div class="song-info">
              <span class="track-number">${song.trackNumber ? song.trackNumber + "." : ""}</span>
              <span class="song-title">${song.name}</span>
            </div>
          </div>
        `).join("")}
      </div>
    </div>
  `).join("");
  
  attachSongAndAlbumEventListeners();
}

function renderSongsAsList(songsToRender) {
    const musicListContainer = document.querySelector('.music-list');
    musicListContainer.innerHTML = songsToRender.map(song => `
        <div class="music-item ${song.id === currentSongId ? "active" : ""}" data-id="${song.id}">
            <div class="song-info">
                <img src="${song.albumArt}" class="album-thumbnail" style="width: 40px; height: 40px; border-radius: 8px; margin-right: 5px;">
                <div>
                    <div class="song-title" style="font-size: 1em; margin-bottom: 2px;">${song.name}</div>
                    <div class="album-artist" style="font-size: 0.8em;">${sanitize(song.artist)}</div>
                </div>
            </div>
        </div>
    `).join('');
    attachSongAndAlbumEventListeners();
}
        
async function renderLyrics() {
    const lyricsQueuePanel = document.getElementById('lyrics-queue-panel');
    if (!lyricsQueuePanel) return;

    const lyricsContainer = lyricsQueuePanel.querySelector('.lyrics-container') || 
                            (() => {
                                lyricsQueuePanel.innerHTML = `<div class="lyrics-container" id="lyrics-scroll-container"></div>`;
                                return lyricsQueuePanel.querySelector('.lyrics-container');
                            })();

    if (!currentSongId) {
        lyricsContainer.innerHTML = `<p style="opacity: 1; filter: none;">No song is currently playing.</p>`;
        return;
    }
    
    const songIdForThisRender = currentSongId;
    const song = currentlyPlayingSong;

    if (song.lyrics) {
        if (song.lrcData && song.lrcData.lyrics && song.lrcData.lyrics.length > 0) {
            let lineIndex = 0; 
            const lyricsHtml = song.lrcData.lyrics.map(item => {
                switch(item.type) {
                    case 'line':
                        return `<p id="lyric-line-${lineIndex++}" data-time="${item.time}">${item.text || '• • •'}</p>`;
                    case 'aside':
                        return `<p class="lyric-aside" data-time="${item.time}">${item.text}</p>`;
                    default:
                        return '';
                }
            }).join('');
            
            lyricsContainer.innerHTML = lyricsHtml;

            lyricsContainer.querySelectorAll('p:not(.lyric-aside)').forEach(lineEl => {
                lineEl.addEventListener('click', () => {
                    const seekTime = parseFloat(lineEl.dataset.time);
                    if (!isNaN(seekTime)) audioPlayer.currentTime = seekTime;
                });
            });

            lyricsContainer.addEventListener('scroll', () => {
                if (isProgrammaticScroll) return;
                isUserScrollingLyrics = true;
                clearTimeout(lyricsScrollTimeout);
                lyricsContainer.querySelectorAll('p').forEach(p => {
                    p.style.filter = 'none';
                    p.style.opacity = 1;
                });
                lyricsScrollTimeout = setTimeout(() => {
                    isUserScrollingLyrics = false;
                    lastActiveIndex = -1;
                }, 250);
            });

        } else {
            lyricsContainer.innerHTML = `<p style="opacity: 1; filter: none; white-space: pre-wrap;">${song.lyrics}</p>`;
        }
        return;
    }

    // Use istidalEnabled as the toggle for the new API
    if (istidalEnabled || isLrclibEnabled) {
        lyricsContainer.innerHTML = `<div class="loading-message"><svg width="24" height="24" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg" style="color: var(--text-color);"><style>.spinner_V8m1{transform-origin:center;animation:spinner_zKoa 2s linear infinite}.spinner_V8m1 circle{stroke-linecap:round;animation:spinner_YpZS 1.5s ease-in-out infinite}@keyframes spinner_zKoa{100%{transform:rotate(360deg)}}@keyframes spinner_YpZS{0%{stroke-dasharray:0 150;stroke-dashoffset:0}47.5%{stroke-dasharray:42 150;stroke-dashoffset:-16}95%,100%{stroke-dasharray:42 150;stroke-dashoffset:-59}}</style><g class="spinner_V8m1"><circle cx="12" cy="12" r="9.5" fill="none" stroke-width="3"></circle></g></svg></div>`;
        const fetchedLyrics = await fetchLyrics(song);

        if (songIdForThisRender !== currentSongId) return;

        if (fetchedLyrics) {
            song.lyrics = fetchedLyrics.content;
            if (fetchedLyrics.type === 'lrc') song.lrcData = parseLRC(fetchedLyrics.content);
            
            if (song.storage === 'tidal') await updatetidalCacheWithLyrics(song);
            else await saveSongs();
            
            renderLyrics();
        } else {
             lyricsContainer.innerHTML = `
                <div class="no-results">
                    <p>No lyrics found automatically.</p>
                    ${song.storage !== 'tidal' ? '<button id="manual-search-trigger" class="goto-btn">Search Manually</button>' : ''}
                </div>`;
            if (document.getElementById('manual-search-trigger')) {
                document.getElementById('manual-search-trigger').addEventListener('click', () => {
                    const cleaned = cleanMetadataForLyricsSearch(song);
                    document.getElementById('manualLyricsSearchInput').value = `${cleaned.artist} - ${cleaned.name}`;
                    document.getElementById('manualLyricsResults').innerHTML = '';
                    openModal(manualLyricsSearchModal);
                });
            }
        }
        return;
    }

    lyricsContainer.innerHTML = `<p style="opacity: 1; filter: none;">No lyrics found.</p>`;
}

async function fetchLyricsFromLrclib(song) {
    if (!song) return null;

    // Use the cleaned metadata for the API call
    const cleanedSong = cleanMetadataForLyricsSearch(song);
    const artist = encodeURIComponent(cleanedSong.artist);
    const track = encodeURIComponent(cleanedSong.name);

    // Start building the URL with the required parameters
    let url = `https://lrclib.net/api/get?artist_name=${artist}&track_name=${track}`;

    // --- THE FIX ---
    // Only add the album_name parameter if it's NOT a tidal song
    // and if an album name actually exists.
    if (song.storage !== 'tidal' && cleanedSong.album) {
        const album = encodeURIComponent(cleanedSong.album);
        url += `&album_name=${album}`;
    }

    try {
        const response = await fetch(url);
        if (!response.ok) {
            console.warn(`LRCLIB request failed with status: ${response.status}`);
            return null;
        }
        
        const data = await response.json();
        if (Object.keys(data).length === 0 || (!data.plainLyrics && !data.syncedLyrics)) {
            return null;
        }

        if (data.syncedLyrics) {
            return { type: 'lrc', content: data.syncedLyrics };
        } else if (data.plainLyrics) {
            return { type: 'plain', content: data.plainLyrics };
        }

    } catch (error) {
        console.error("Error fetching lyrics from LRCLIB:", error);
    }
    return null;
}

// This function cleans metadata before any LRCLIB search
function cleanMetadataForLyricsSearch(song) {
    let cleanTitle = song.name || '';
    let cleanArtist = song.artist || '';

    // Remove common patterns like (feat...), (prod...), [Official Video], etc.
    const patternsToRemove = [
        /\s*\(feat\..*?\)/i,
        /\s*\(prod\..*?\)/i,
        /\s*\[.*?\]/g,
        /\s*\(.*?(official|lyric|audio|video|visualizer).*?\)/i,
        /\s-\s(official|lyric|audio|video|visualizer).*/i,
        /MV/g
    ];

    patternsToRemove.forEach(pattern => {
        cleanTitle = cleanTitle.replace(pattern, '').trim();
    });

    return { name: cleanTitle, artist: cleanArtist, album: song.album };
}

// New function to handle the manual search API call
async function searchLrclibForManualPick() {
    const query = document.getElementById('manualLyricsSearchInput').value;
    const resultsContainer = document.getElementById('manualLyricsResults');
    if (!query) return;

    resultsContainer.innerHTML = `<div class="loading-message"><svg width="24" height="24" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg" style="color: var(--text-color);"><style>.spinner_V8m1{transform-origin:center;animation:spinner_zKoa 2s linear infinite}.spinner_V8m1 circle{stroke-linecap:round;animation:spinner_YpZS 1.5s ease-in-out infinite}@keyframes spinner_zKoa{100%{transform:rotate(360deg)}}@keyframes spinner_YpZS{0%{stroke-dasharray:0 150;stroke-dashoffset:0}47.5%{stroke-dasharray:42 150;stroke-dashoffset:-16}95%,100%{stroke-dasharray:42 150;stroke-dashoffset:-59}}</style><g class="spinner_V8m1"><circle cx="12" cy="12" r="9.5" fill="none" stroke-width="3"></circle></g></svg></div>`;
    const url = `https://lrclib.net/api/search?q=${encodeURIComponent(query)}`;

    try {
        const response = await fetch(url);
        if (!response.ok) throw new Error('API Search failed');
        
        // Store results in our global variable
        lastLrclibSearchResults = await response.json();

        if (lastLrclibSearchResults.length === 0) {
            resultsContainer.innerHTML = '<p>No results found.</p>';
            return;
        }

        resultsContainer.innerHTML = lastLrclibSearchResults.map(track => `
            <div class="menu-item" data-id="${track.id}" style="cursor: pointer;">
                <div>
                    <div>${sanitize(track.trackName)}</div>
                    <div style="font-size: 0.8em; color: var(--secondary-text-color);">${sanitize(track.artistName)}</div>
                </div>
            </div>
        `).join('');

        // Add click listeners to each new result item
        resultsContainer.querySelectorAll('.menu-item').forEach(item => {
            item.addEventListener('click', async () => {
                const trackId = parseInt(item.dataset.id, 10);
                const selectedTrack = lastLrclibSearchResults.find(t => t.id === trackId);
                
                if (!selectedTrack) return; // Safety check

                const song = currentlyPlayingSong;
                if (!song) return;

                // Apply lyrics directly from the selected search result
                if (selectedTrack.syncedLyrics) {
                    song.lyrics = selectedTrack.syncedLyrics;
                    song.lrcData = parseLRC(selectedTrack.syncedLyrics);
                } else if (selectedTrack.plainLyrics) {
                    song.lyrics = selectedTrack.plainLyrics;
                    song.lrcData = null;
                } else {
                    Gurasuraisu.showPopup("Selected track has no lyrics.");
                    return;
                }

                // Save the newly found lyrics
                if (song.storage === 'tidal') {
                    await updatetidalCacheWithLyrics(song);
                } else {
                    await saveSongs();
                }
                
                // Close modal and re-render the lyrics panel
                closeModal(manualLyricsSearchModal);
                await renderLyrics();
            });
        });

    } catch (error) {
        resultsContainer.innerHTML = `<p>Error during search.</p>`;
        console.error("Manual LRCLIB search error:", error);
    }
}
    
async function renderOfflinetidalView() {
    const resultsGrid = document.getElementById('tidal-results-grid');
    const query = document.getElementById('tidalOfflineSearchInput').value.toLowerCase();
    resultsGrid.innerHTML = '';
    
    try {
        const tx = db.transaction('tidalCache', 'readonly');
        const store = tx.objectStore('tidalCache');
        const allCachedItems = await promiseIDBRequest(store.getAll());

        let filteredItems = allCachedItems;
        if (query) {
            filteredItems = allCachedItems.filter(item => 
                item.metadata.name.toLowerCase().includes(query) ||
                item.metadata.artist.toLowerCase().includes(query)
            );
        }
        
        if (filteredItems.length === 0) {
            if (query) {
                // If there was a search query, show a "no results" message.
                resultsGrid.innerHTML = `<div class="no-results" style="grid-column: 1 / -1;"><p>No cached songs match "${sanitize(query)}"</p></div>`;
            } else {
                // If there was no query, it means the cache is empty.
                resultsGrid.innerHTML = `<div class="no-results" style="grid-column: 1 / -1;"><p>No tidal songs are cached</p></div>`;
            }
            return;
        }
        
        // Sort by most recently played
        filteredItems.sort((a, b) => b.timestamp - a.timestamp);

        const resultsHtml = filteredItems.map(entry => {
            const track = entry.metadata;
            return `
            <div class="music-item" data-cached-id="${track.id}" style="cursor: pointer;">
                 <div class="song-info">
                    <img src="${track.albumArt}" class="album-thumbnail" style="width: 40px; height: 40px; border-radius: 8px; margin-right: 6px;">
                    <div>
                        <div class="song-title" style="white-space: normal;">${sanitize(track.name)}</div>
                        <div class="album-artist" style="font-size: 0.8em;">${sanitize(track.artist)}</div>
                    </div>
                </div>
            </div>
            `;
        }).join('');
        resultsGrid.className = 'item-list';
        resultsGrid.innerHTML = resultsHtml;
    } catch (error) {
        console.error('Failed to render offline songs:', error);
        resultsGrid.innerHTML = `<div class="no-results" style="grid-column: 1 / -1;"><p>Error loading cached songs.</p></div>`;
    }
}

// This new function will control the view in the "New" tab
function rendertidalPage() {
    const searchContainer = document.getElementById('tidal-search-container');
    const offlineSearchContainer = document.getElementById('tidal-offline-search-container');
    const filterContainer = document.getElementById('tidal-filter-container');
    
    if (istidalOfflineMode) {
        searchContainer.style.display = 'none';
        offlineSearchContainer.style.display = 'flex';
        filterContainer.style.display = 'none';
        document.getElementById('tidalOfflineToggle').classList.add('active');
        renderOfflinetidalView();
    } else {
        searchContainer.style.display = 'block';
        offlineSearchContainer.style.display = 'none';
        filterContainer.style.display = 'flex';
        document.getElementById('tidalOfflineToggle').classList.remove('active');
        document.getElementById('tidalOfflineSearchInput').value = '';
        rendertidalSearchResults();
    }
}
        
function renderQueue() {
    const lyricsQueuePanel = document.getElementById('lyrics-queue-panel');
    if (!lyricsQueuePanel) return;

    // Create the header with the title and the new autoplay toggle
    const headerHtml = `
        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 0; flex-shrink: 0;">
            <h2 class="section-title" style="margin: 0;">Up Next</h2>
            <div style="display: flex; align-items: center; gap: 10px;">
                <label for="autoplayToggle" style="font-size: 14px; color: var(--secondary-text-color);">Autoplay</label>
                <input type="checkbox" id="autoplayToggle" ${isAutoplayEnabled ? 'checked' : ''}>
            </div>
        </div>
    `;

    if (playQueue.length === 0) {
        lyricsQueuePanel.innerHTML = headerHtml + `
            <div class="now-queue">
                <div class="no-results" style="flex-grow: 1; justify-content: center;">
                    <span class="material-symbols-rounded">queue_music</span>
                    <p>The queue is empty.</p>
                </div>
            </div>
        `;
    } else {
        const queueHtml = playQueue.map((song, index) => `
            <div class="music-item queue-item ${song.id === currentSongId ? "active" : ""}" data-queue-index="${index}" data-id="${song.id}">
                <div class="song-info">
                    <img src="${song.albumArt}" class="album-thumbnail" style="width: 40px; height: 40px; border-radius: 6px; margin: 0 5px;">
                    <div class="song-title">${sanitize(song.name)}</div>
                    <span class="song-artist-queue">${song.artist}</span>
                    <button class="remove-from-queue-btn" data-queue-index="${index}">
                        <span class="material-symbols-rounded" style="font-size: 14px;">cancel</span>
                    </button>
                </div>
            </div>
        `).join('');
        
        lyricsQueuePanel.innerHTML = `<div class="now-queue">${headerHtml}<div class="queue-list-container" style="margin-top: 10px;">${queueHtml}</div></div>`;
    }

    // Attach event listener for the new toggle switch
    const autoplayToggle = document.getElementById('autoplayToggle');
    if (autoplayToggle) {
        autoplayToggle.addEventListener('change', toggleAutoplay);
    }

    makeQueueItemsDraggable();
    addQueueItemEventListeners();
}

function scrollToCurrentSongInQueue() {
    // Use a small timeout to ensure the DOM has updated
    setTimeout(() => {
        const activeSongEl = document.querySelector('#lyrics-queue-panel .queue-item.active');
        if (activeSongEl) {
            activeSongEl.scrollIntoView({
                behavior: 'smooth',
                block: 'center'
            });
        }
    }, 100);
}

function attachSongAndAlbumEventListeners() {
  document.querySelectorAll('.song-actions').forEach(button => {
      button.addEventListener('click', (e) => {
          const songId = parseFloat(button.dataset.id);
          openSongContextMenu(e, songId);
      });
  });
}

function rebuildQueueFromCurrentView() {
    const newQueue = [];
    let songItems;

    // Determine where to source the song list from based on the active view
    if (activeView === 'library') {
        songItems = document.querySelectorAll('#library-grid .item-card[data-album-id]');
    } else if (activeView === 'search') {
        // We will add search logic later, for now, it can be empty
        songItems = document.querySelectorAll('#search-view .item-card');
    } else {
        // Default or Home view, we can source from the entire song list for now
        playQueue = [...songs]; // Fallback to all songs
        console.log(`Queue rebuilt from all songs. ${playQueue.length} songs.`);
        isQueueUserModified = false;
        return;
    }

    if (songItems.length > 0) {
        // This part needs to be adapted based on what each view renders.
        // For the library's album view:
        if (activeView === 'library' && currentFilter === 'albums') {
            const albumSongs = [];
            songItems.forEach(card => {
                const [artist, albumName] = card.dataset.albumId.split('::');
                const songsFromAlbum = songs.filter(s => s.albumArtist === artist && s.album === albumName);
                albumSongs.push(...songsFromAlbum);
            });
            // Remove duplicates in case albums are shown multiple times
            const uniqueIds = new Set();
            playQueue = albumSongs.filter(song => {
                const isDuplicate = uniqueIds.has(song.id);
                uniqueIds.add(song.id);
                return !isDuplicate;
            });

        } else {
             // Fallback for other potential views (like song list view later)
             songItems.forEach(item => {
                const songId = parseFloat(item.dataset.id);
                const song = songs.find(s => s.id === songId);
                if (song && !newQueue.some(s => s.id === song.id)) {
                    newQueue.push(song);
                }
            });
            playQueue = newQueue;
        }

    } else {
        // If the view is empty, just use the full song list
        playQueue = [...songs];
    }
    
    console.log(`Queue rebuilt from ${activeView} view. ${playQueue.length} songs.`);
    isQueueUserModified = false; 
}
        
function addToQueue(songId, position = 'last') {
    isQueueUserModified = true; // Flag that the user is now manually curating the queue
    
    // FIX: Find song from multiple possible sources
    let song = songs.find(s => s.id === songId);
    if (!song && lasttidalSearchResults.length > 0) { // If not in local library, check tidal results
         const track = lasttidalSearchResults.find(t => t.id === songId);
         if (track) {
            song = {
                id: track.id,
                name: track.title,
                artist: track.user.username,
                album: 'tidal',
                albumArt: getHighResArtwork(track.artwork_url),
                storage: 'tidal'
            };
         }
    }

    if (!song) {
        console.error("Could not find song to add to queue with ID:", songId);
        return;
    }

    if (playQueue.length === 0) {
        rebuildQueueFromCurrentView();
        currentQueueIndex = playQueue.findIndex(s => s.id === currentSongId);
    }
    
    if (currentQueueIndex === -1) {
        currentQueueIndex = playQueue.length > 0 ? playQueue.length -1 : 0;
    }
    
    if (position === 'next') {
        playQueue.splice(currentQueueIndex + 1, 0, song);
    } else { 
        playQueue.push(song);
    }

    Gurasuraisu.showPopup(`Added "${sanitize(song.name)}" to queue.`);
    
    if (isPanelVisible && panelContent === 'queue') {
        renderQueue();
    }
}

async function toggleAutoplay(event) {
    isAutoplayEnabled = event.target.checked;
    if (isAutoplayEnabled) {
        await generateAutoplaySongs();
    } else {
        removeAutoplaySongs();
    }
}

function removeAutoplaySongs() {
    if (autoplaySongIds.size === 0) return;

    playQueue = playQueue.filter(song => !autoplaySongIds.has(song.id));
    autoplaySongIds.clear();
    
    // After removing songs, the current index might be wrong. Let's fix it.
    currentQueueIndex = playQueue.findIndex(s => s.id === currentSongId);

    renderQueue();
}

function setPlayerLoadingState(isLoading, song = null) {
    const loadingSVG = `<svg width="24" height="24" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg" style="color: var(--text-color);"><style>.spinner_V8m1{transform-origin:center;animation:spinner_zKoa 2s linear infinite}.spinner_V8m1 circle{stroke-linecap:round;animation:spinner_YpZS 1.5s ease-in-out infinite}@keyframes spinner_zKoa{100%{transform:rotate(360deg)}}@keyframes spinner_YpZS{0%{stroke-dasharray:0 150;stroke-dashoffset:0}47.5%{stroke-dasharray:42 150;stroke-dashoffset:-16}95%,100%{stroke-dasharray:42 150;stroke-dashoffset:-59}}</style><g class="spinner_V8m1"><circle cx="12" cy="12" r="9.5" fill="none" stroke-width="3"></circle></g></svg>`;
    const playIconText = 'play_arrow';
    const pauseIconText = 'pause';

    if (isLoading) {
        if (song) {
            updatePlayerUI(song);
            updateMiniplayerUI(song, 'loading');
        }
        playPauseIcon.innerHTML = loadingSVG;
        const miniplayerPlayBtn = document.getElementById('miniplayer-play-btn');
        if(miniplayerPlayBtn) miniplayerPlayBtn.innerHTML = loadingSVG;
    } else {
        const state = audioPlayer.paused ? 'paused' : 'playing';
        updateMiniplayerUI(currentlyPlayingSong, state);
        playPauseIcon.innerHTML = '';
        playPauseIcon.textContent = state === 'playing' ? pauseIconText : playIconText;
    }
}

async function generateAutoplaySongs() {
    removeAutoplaySongs(); // Always start with a clean slate

    const lastSong = playQueue.length > 0 ? playQueue[playQueue.length - 1] : null;
    if (!lastSong || !lastSong.artist) return;

    try {
        const response = await fetch(`https://hifi.401658.xyz/search/?s=${encodeURIComponent(lastSong.artist)}&limit=20`);
        if (!response.ok) throw new Error("Autoplay search failed");
        
        const data = await response.json();
        const potentialTracks = data.items || [];
        
        const queueIds = new Set(playQueue.map(s => s.id));
        const recommendations = potentialTracks
            .filter(track => track && track.id && !queueIds.has(track.id))
            .map(track => ({
                id: track.id,
                name: track.title,
                artist: track.artist.name,
                album: track.album.title,
                albumArt: getHighResArtwork(track.album.cover),
                storage: 'tidal',
                duration: track.duration,
                audioQuality: track.audioQuality,
                vibrantColor: track.album.vibrantColor
            }));

        if (recommendations.length > 0) {
            recommendations.forEach(song => autoplaySongIds.add(song.id));
            playQueue.push(...recommendations);
        }
        
        if (isPanelVisible && panelContent === 'queue') {
            renderQueue();
        }

    } catch (e) {
        console.error("Autoplay generation failed:", e);
    }
}

function formatSongsForAiPrompt(songList) {
    if (!songList || songList.length === 0) return "No songs available.";
    // Provide more context: Title, Artist, Genre, and Source (tidal or Local)
    return songList.map(s => 
        `Title: ${s.name}, Artist: ${s.artist}, Genre: ${s.genre || 'Unknown'}, Source: ${s.storage === 'tidal' ? 'tidal' : 'Local'}`
    ).join('\n');
}

async function generateAiAutoplaySongs() {
    if (!musicAiModel) return [];

    const contextQueue = playQueue.length > 0 ? playQueue : (currentlyPlayingSong ? [currentlyPlayingSong] : []);
    if (contextQueue.length === 0) return [];

    // --- Build Comprehensive Context for AI ---
    let comprehensiveLibrary = [...songs];
    const userQueueSongIds = new Set(playQueue.map(s => s.id));

    // 1. If tidal is enabled, fetch potential recommendations to add to the AI's knowledge base.
    if (istidalEnabled && tidalClientId) {
        const contextArtists = new Set(contextQueue.map(s => s.artist).filter(Boolean));
        const contextGenres = new Set(contextQueue.map(s => s.genre).filter(Boolean));
        const searchTerms = [...new Set([...contextArtists, ...contextGenres])];
        
        const promises = searchTerms.map(term =>
            fetch(proxyUrl(`https://api-v2.tidal.com/search/tracks?q=${encodeURIComponent(term)}&client_id=${tidalClientId}&limit=10`))
                .then(res => res.ok ? res.json() : { collection: [] })
                .catch(() => ({ collection: [] }))
        );
        const results = await Promise.all(promises);
        const scTracks = results.flatMap(data => data.collection).map(track => ({
            id: track.id, name: track.title, artist: track.user.username,
            album: 'tidal', albumArt: getHighResArtwork(track.artwork_url), storage: 'tidal', genre: track.genre
        }));

        // Add tidal tracks to the library if they aren't duplicates of local songs
        scTracks.forEach(scSong => {
            const uniqueKey = `${scSong.artist.toLowerCase().trim()}::${scSong.name.toLowerCase().trim()}`;
            if (!localSongLookup.has(uniqueKey)) {
                comprehensiveLibrary.push(scSong);
            }
        });
    }
    
    // 2. Create a precise prompt for the AI
    const queuePrompt = `The user's current queue contains:\n${formatSongsForAiPrompt(contextQueue)}`;
    const libraryPrompt = `Here is the comprehensive library of available songs (Local and tidal):\n${formatSongsForAiPrompt(comprehensiveLibrary)}`;
    const instructionPrompt = `\nSelect up to 20 songs from the comprehensive library that are similar to the user's queue. CRITICAL: Do NOT include any songs that are already in the queue.`;
    
    const fullPrompt = `${queuePrompt}\n\n${libraryPrompt}\n\n${instructionPrompt}`;

    try {
        const result = await musicAiModel.generateContent(fullPrompt);
        const call = result.response.functionCalls()?.[0];

        if (call && call.name === 'getSongRecommendations') {
            // Find the full song objects from the AI's string recommendations
            const recommendedSongs = call.args.songs
                .map(songString => findSongByString(songString, comprehensiveLibrary))
                .filter(song => song && !userQueueSongIds.has(song.id)); // Final check for duplicates
            return recommendedSongs;
        }
    } catch (error) {
        console.error("GuraAI Autoplay Error:", error);
    }
    return []; // Return empty array on failure
}

function openSongContextMenu(targetElement, songId) {
    if (!targetElement) return; // Safety check

    const contextMenu = document.getElementById('songContextMenu');
    
    document.getElementById('menuAddToQueueNext').onclick = () => {
        addToQueue(songId, 'next');
        contextMenu.classList.remove('visible');
    };
    document.getElementById('menuAddToQueueLast').onclick = () => {
        addToQueue(songId, 'last');
        contextMenu.classList.remove('visible');
    };

    contextMenu.classList.add('visible'); // Make visible before measuring to get dimensions
    const rect = targetElement.getBoundingClientRect();
    const menuWidth = contextMenu.offsetWidth;
    const menuHeight = contextMenu.offsetHeight;
    const viewportWidth = window.innerWidth;
    const viewportHeight = window.innerHeight;

    let top = rect.bottom;
    let left = rect.right - menuWidth; // Align to the right edge of the target

    // Adjust for viewport boundaries
    if (left < 0) {
        left = rect.left; // If it overflows left, align to the left edge instead
    }
    if (top + menuHeight > viewportHeight) {
        top = rect.top - menuHeight; // If it overflows bottom, open upwards
    }
    
    contextMenu.style.top = `${top}px`;
    contextMenu.style.left = `${left}px`;

    // Add a one-time listener to close the menu when clicking elsewhere
    // Use a timeout to prevent the current click from being captured
    setTimeout(() => {
        const closeMenuOnClickOutside = (e) => {
            if (!contextMenu.contains(e.target)) {
                contextMenu.classList.remove('visible');
                document.removeEventListener('click', closeMenuOnClickOutside, true);
                document.removeEventListener('contextmenu', closeMenuOnClickOutside, true);
            }
        };
        // Use the capture phase (true) to catch the click before it bubbles to other elements
        document.addEventListener('click', closeMenuOnClickOutside, true);
        document.addEventListener('contextmenu', closeMenuOnClickOutside, true);
    }, 0);
}

async function playSong(song, playContext = null) {
    if (isPlayerLoading) {
        console.warn("Player is already loading, blocking new play request.");
        return;
    }
    
    if (playContext && Array.isArray(playContext)) {
        const wasAutoplayEnabled = isAutoplayEnabled;
        playQueue = [...playContext];
        isQueueUserModified = false;
        autoplaySongIds.clear();
        if (wasAutoplayEnabled) {
            await generateAutoplaySongs();
        }
    } else if (playQueue.length === 0) {
        rebuildQueueFromCurrentView();
    }
    
    isPlayerLoading = true;

    try {
        audioPlayer.pause();
        lastActiveTimestamp = -1;
        song.hasBeenLogged = false;
        currentlyPlayingSong = song;

        const isHlsStream = song.streamUrl && song.streamUrl.includes('.m3u8');

        if (hls) {
            hls.destroy();
            hls = null;
        }
        if (audioPlayer.src && audioPlayer.src.startsWith('blob:')) {
            URL.revokeObjectURL(audioPlayer.src);
        }
        audioPlayer.src = ''; 
        audioPlayer.load();
        
        const fileUrl = song.blobUrl || song.streamUrl || await getSongFileUrl(song);
        if (!fileUrl) {
            throw new Error(`Could not get a playable URL for ${song.name}`);
        }

        const isCrossOriginStream = song.storage === 'tidal' && !song.blobUrl;
        if (isCrossOriginStream) {
            audioPlayer.crossOrigin = "anonymous";
            disconnectAudioGraph();
        } else {
            audioPlayer.removeAttribute('crossorigin');
            connectAudioGraph();
        }

        if (isHlsStream) {
            if (typeof Hls !== 'undefined' && Hls.isSupported()) {
                hls = new Hls();
                hls.on(Hls.Events.ERROR, function (event, data) {
                    if (data.fatal) {
                        console.error('Fatal HLS Error:', data);
                        isPlayerLoading = false;
                        playNextSong({ userInitiated: false });
                    }
                });
                hls.loadSource(fileUrl);
                hls.attachMedia(audioPlayer);
            } else if (audioPlayer.canPlayType('application/vnd.apple.mpegurl')) {
                audioPlayer.src = fileUrl;
            }
        } else {
            audioPlayer.src = fileUrl;
        }

        currentSongId = song.id;
        currentQueueIndex = playQueue.findIndex(s => s.id === currentSongId);
        
        updatePlayerUI(song);
        updateMiniplayerUI(song, 'paused');
        await updateMediaSessionMetadata(song);

        Gurasuraisu.registerMediaSession(
            { title: song.name, artist: song.artist, artwork: [{ src: song.albumArt }] },
            ['playPause', 'next', 'prev']
        );

        if (isPanelVisible) {
            if (panelContent === 'lyrics') {
                renderLyrics();
            } else if (panelContent === 'queue') {
                renderQueue();
                scrollToCurrentSongInQueue();
            }
        }

        await new Promise((resolve, reject) => {
            const playAudio = () => {
                audioPlayer.play().then(resolve).catch(e => {
                    if (e.name === 'AbortError') {
                        resolve();
                    } else {
                        reject(e);
                    }
                });
            };
            if (audioPlayer.readyState >= 3) {
                playAudio();
            } else {
                audioPlayer.oncanplay = () => {
                    audioPlayer.oncanplay = null;
                    audioPlayer.onerror = null;
                    playAudio();
                };
                audioPlayer.onerror = (e) => {
                    audioPlayer.oncanplay = null;
                    audioPlayer.onerror = null;
                    reject(e.target.error || new Error("Unknown audio player error"));
                };
            }
        });

        proactivelyCacheNextInQueue();

        playPauseIcon.textContent = 'pause';
        playPauseBtn.classList.add('playing');
        Gurasuraisu.updatePlaybackState({ playbackState: 'playing' });
        updateMiniplayerUI(song, 'playing');

    } catch (error) {
        if (error.name !== 'AbortError') console.error("Failed to play song:", song.name, error);
        Gurasuraisu.updatePlaybackState({ playbackState: 'paused' });
        updateMiniplayerUI(song, 'paused');
    } finally {
        isPlayerLoading = false;
    }
}

function getLocalVersionIfExists(track) {
    if (!track) return track;
    const artistName = (track.artist && track.artist.name) ? track.artist.name : track.artist;
    const trackName = track.title || track.name;

    if (!artistName || !trackName) return track;

    const uniqueKey = `${artistName.toLowerCase().trim()}::${trackName.toLowerCase().trim()}`;
    if (localSongLookup.has(uniqueKey)) {
        console.log(`Found local version for "${trackName}", switching to owned track.`);
        return localSongLookup.get(uniqueKey);
    }
    return track;
}

function updateMiniplayerUI(song, state) {
    // If we are on the Now Playing screen, the miniplayer should ALWAYS be hidden.
    if (activeView === 'now-playing') {
        miniplayer.classList.add('hidden');
        return;
    }

    if (!song || !currentSongId) {
        miniplayer.classList.add('hidden');
        return;
    }

    miniplayer.classList.remove('hidden');
    miniplayerArt.src = song.albumArt;
    miniplayerTitle.textContent = sanitize(song.name);
    miniplayerArtist.textContent = sanitize(song.artist);

    let iconHtml;
    switch(state) {
        case 'playing':
            iconHtml = `<span class="material-symbols-rounded" style="font-size: 28px;">pause</span>`;
            break;
        case 'loading':
            iconHtml = `<svg width="24" height="24" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg" style="color: var(--text-color);"><style>.spinner_V8m1{transform-origin:center;animation:spinner_zKoa 2s linear infinite}.spinner_V8m1 circle{stroke-linecap:round;animation:spinner_YpZS 1.5s ease-in-out infinite}@keyframes spinner_zKoa{100%{transform:rotate(360deg)}}@keyframes spinner_YpZS{0%{stroke-dasharray:0 150;stroke-dashoffset:0}47.5%{stroke-dasharray:42 150;stroke-dashoffset:-16}95%,100%{stroke-dasharray:42 150;stroke-dashoffset:-59}}</style><g class="spinner_V8m1"><circle cx="12" cy="12" r="9.5" fill="none" stroke-width="3"></circle></g></svg>`;
            break;
        case 'paused':
        default:
            iconHtml = `<span class="material-symbols-rounded" style="font-size: 28px;">play_arrow</span>`;
            break;
    }
    const miniplayerPlayBtn = document.getElementById('miniplayer-play-btn');
    if(miniplayerPlayBtn) miniplayerPlayBtn.innerHTML = iconHtml;
}
        
async function getSongFileUrl(song) {
    if (!song) return null;

    if (song.storage === 'indexeddb') {
        try {
            const tx = db.transaction(['musicFiles'], 'readonly');
            const request = tx.objectStore('musicFiles').get(song.id);
            const result = await new Promise((resolve, reject) => {
                request.onsuccess = () => resolve(request.result);
                request.onerror = () => reject(request.error);
            });
            return result ? URL.createObjectURL(result.file) : null;
        } catch (e) {
             console.error(`Could not get blob for ${song.name}:`, e);
             return null;
        }
    }

    for (const handle of directoryHandles) {
        try {
            const fileHandle = await handle.getFileHandle(song.handleName);
            const file = await fileHandle.getFile();
            return URL.createObjectURL(file);
        } catch (e) {
            if (e.name === 'NotFoundError') continue;
            console.error(`Error accessing handle for ${song.name} in directory ${handle.name}:`, e);
        }
    }

    console.warn(`Could not find "${song.handleName}" in any connected directories.`);
    return null;
}

async function logSongPlay(songId) {
    try {
        const songTx = db.transaction('songs', 'readwrite');
        const songStore = songTx.objectStore('songs');
        const songReq = songStore.get(songId);

        songReq.onsuccess = () => {
            const songData = songReq.result;
            if (songData) {
                songData.playCount = (songData.playCount || 0) + 1;
                songStore.put(songData);
            }
        };
        
        const historyTx = db.transaction('playHistory', 'readwrite');
        const historyStore = historyTx.objectStore('playHistory');
        historyStore.put({ timestamp: Date.now(), songId: songId });

        await Promise.all([songTx.done, historyTx.done]);

        // Also update the in-memory version
        const inMemorySong = songs.find(s => s.id === songId);
        if (inMemorySong) {
            inMemorySong.playCount = (inMemorySong.playCount || 0) + 1;
        }

    } catch (error) {
        console.error("Failed to log song play:", error);
    }
}

function proxyUrl(url) {
    if (isCorsProxyEnabled) {
        // This regex matches all relevant tidal domains that need proxying.
        const tidalDomains = /(tidal\.com|sndcdn\.com|tidal\.cloud)/;
        if (tidalDomains.test(url)) {
            return `https://corsproxy.io/?${encodeURIComponent(url)}`;
        }
    }
    return url;
}
        
function initModalVariables() {
    editModal = document.getElementById('editModal');
    editSongId = document.getElementById('editSongId');
    editTitle = document.getElementById('editTitle');
    editArtist = document.getElementById('editArtist');
    editAlbum = document.getElementById('editAlbum');
    saveEdit = document.getElementById('saveEdit');
    cancelEdit = document.getElementById('cancelEdit');
    saveEdit.addEventListener('click', saveMetadataChanges);
    cancelEdit.addEventListener('click', () => closeModal(editModal));

    sleepTimerModal = document.getElementById('sleepTimerModal');
    document.getElementById('cancelSleepTimer').addEventListener('click', () => setSleepTimer(0));

    playlistModal = document.getElementById('playlistModal');
    document.getElementById('closePlaylistModal').addEventListener('click', () => closeModal(playlistModal));
    document.getElementById('createPlaylistBtn').addEventListener('click', createPlaylistAndAddSong);

    equalizerModal = document.getElementById('equalizerModal');
    document.getElementById('closeEqModal').addEventListener('click', () => closeModal(equalizerModal));
    document.getElementById('resetEq').addEventListener('click', () => {
        ['bass-slider', 'mid-slider', 'treble-slider'].forEach(id => {
            const slider = document.getElementById(id);
            slider.value = 0;
            slider.dispatchEvent(new Event('input')); 
        });
    });
    document.getElementById('bass-slider').addEventListener('input', (e) => { if(eqBass) eqBass.gain.value = e.target.value; });
    document.getElementById('mid-slider').addEventListener('input', (e) => { if(eqMid) eqMid.gain.value = e.target.value; });
    document.getElementById('treble-slider').addEventListener('input', (e) => { if(eqTreble) eqTreble.gain.value = e.target.value; });
    
    manageFoldersModal = document.getElementById('manageFoldersModal');
    document.getElementById('closeFoldersModal').addEventListener('click', () => closeModal(manageFoldersModal));

    manualLyricsSearchModal = document.getElementById('manualLyricsSearchModal');
    document.getElementById('manualLyricsSearchBtn').addEventListener('click', searchLrclibForManualPick);
    document.getElementById('closeManualLyricsModal').addEventListener('click', () => closeModal(manualLyricsSearchModal));
}

        function openManageFoldersModal() {
            // Populate settings
            document.getElementById('tidalToggle').checked = istidalEnabled;
            document.getElementById('lrclibToggle').checked = isLrclibEnabled;
            openModal(manageFoldersModal);
        }

        async function saveIntegrationSettings() {
            istidalEnabled = document.getElementById('tidalToggle').checked;
            isLrclibEnabled = document.getElementById('lrclibToggle').checked;

            const tx = db.transaction('config', 'readwrite');
            await Promise.all([
                tx.objectStore('config').put({ key: 'istidalEnabled', value: istidalEnabled }),
                tx.objectStore('config').put({ key: 'isLrclibEnabled', value: isLrclibEnabled })
            ]);
            
            toggletidalTab();
        }

async function saveIntegrationSettings() {
    istidalEnabled = document.getElementById('tidalToggle').checked;
    isLrclibEnabled = document.getElementById('lrclibToggle').checked;

    const tx = db.transaction('config', 'readwrite');
    await Promise.all([
        tx.objectStore('config').put({ key: 'istidalEnabled', value: istidalEnabled }),
        tx.objectStore('config').put({ key: 'isLrclibEnabled', value: isLrclibEnabled })
    ]);
    
    toggletidalTab();
}

function toggletidalTab() {
    const tab = document.getElementById('tidal-tab');
    if (tab) {
        tab.style.display = istidalEnabled ? 'flex' : 'none';
    }
}

        async function searchtidal({ loadMore = false } = {}) {
            if (tidalSearchAbortController && !loadMore) {
                tidalSearchAbortController.abort();
            }
            tidalSearchAbortController = new AbortController();
            const signal = tidalSearchAbortController.signal;

            const query = document.getElementById('tidalSearchInput').value.trim();
            const resultsGrid = document.getElementById('tidal-results-grid');
            if (!query) {
                resultsGrid.innerHTML = '';
                lasttidalSearchResults = [];
                return;
            }

            if (!loadMore) {
                resultsGrid.innerHTML = `<div class="loading-message"><svg width="24" height="24" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg" style="color: var(--text-color);"><style>.spinner_V8m1{transform-origin:center;animation:spinner_zKoa 2s linear infinite}.spinner_V8m1 circle{stroke-linecap:round;animation:spinner_YpZS 1.5s ease-in-out infinite}@keyframes spinner_zKoa{100%{transform:rotate(360deg)}}@keyframes spinner_YpZS{0%{stroke-dasharray:0 150;stroke-dashoffset:0}47.5%{stroke-dasharray:42 150;stroke-dashoffset:-16}95%,100%{stroke-dasharray:42 150;stroke-dashoffset:-59}}</style><g class="spinner_V8m1"><circle cx="12" cy="12" r="9.5" fill="none" stroke-width="3"></circle></g></svg></div>`;
                tidalSearchOffset = 0;
                lasttidalSearchResults = [];
            } else {
                tidalSearchOffset += 50;
            }

            const searchUrl = `https://hifi.401658.xyz/search/?s=${encodeURIComponent(query)}&limit=50&offset=${tidalSearchOffset}`;

            try {
                const response = await fetch(searchUrl, { signal });
                if (!response.ok) throw new Error(`API request failed: ${response.statusText}`);
                
                const data = await response.json();
                let newItems = [];
                let totalItems = 0;
                const rawItems = data.items || [];

                switch (tidalFilter) {
                    case 'artists':
                        const artistsMap = new Map();
                        rawItems.forEach(track => {
                            if (track.artists) {
                                track.artists.forEach(artist => {
                                    if (artist && artist.id && !artistsMap.has(artist.id)) {
                                        artistsMap.set(artist.id, artist);
                                    }
                                });
                            }
                        });
                        newItems = Array.from(artistsMap.values());
                        totalItems = newItems.length;
                        break;
                    case 'albums':
                        const albumsMap = new Map();
                        rawItems.forEach(track => {
                            if (track.album && track.album.id && !albumsMap.has(track.album.id)) {
                                albumsMap.set(track.album.id, { ...track.album, artists: track.artists });
                            }
                        });
                        newItems = Array.from(albumsMap.values());
                        totalItems = newItems.length;
                        break;
                    case 'tracks':
                    default:
                        newItems = rawItems;
                        totalItems = data.totalNumberOfItems || 0;
                        break;
                }

                lasttidalSearchResults = lasttidalSearchResults.concat(newItems);
                rendertidalSearchResults(totalItems);

            } catch (error) {
                if (error.name === 'AbortError') {
                    console.log('Search request was aborted.');
                    return;
                }
                console.error('Hifi Search Error:', error);
                resultsGrid.innerHTML = `<div class="no-results" style="grid-column: 1 / -1;"><p>Error searching the catalogue</p></div>`;
            }
        }

// This is a new helper function to manage the cache size
async function manageCacheSize() {
    const tx = db.transaction('tidalCache', 'readwrite');
    const store = tx.objectStore('tidalCache');
    const index = store.index('timestamp');
    const allEntriesReq = index.getAll();

    allEntriesReq.onsuccess = async () => {
        const entries = allEntriesReq.result;
        let totalSize = entries.reduce((acc, entry) => acc + entry.size, 0);

        if (totalSize > tidal_CACHE_LIMIT) {
            console.log(`Cache size (${(totalSize / 1024 / 1024).toFixed(2)}MB) exceeds limit. Pruning...`);
            entries.sort((a, b) => a.timestamp - b.timestamp); // Sort oldest first

            for (const entry of entries) {
                if (totalSize <= tidal_CACHE_LIMIT) break;
                await store.delete(entry.id);
                totalSize -= entry.size;
                console.log(`Removed ${entry.metadata.name} from cache.`);
            }
        }
    };
    await tx.done;
}

// This is a new function to handle background caching
async function cachetidalTrack(songObject, streamUrl) {
    try {
        const audioResponse = await fetch(streamUrl);
        if (!audioResponse.ok) throw new Error('Could not download audio file for caching.');
        const audioBlob = await audioResponse.blob();

        const cacheEntry = {
            id: songObject.id,
            metadata: songObject,
            blob: audioBlob,
            timestamp: Date.now(),
            size: audioBlob.size
        };

        const tx = db.transaction('tidalCache', 'readwrite');
        tx.objectStore('tidalCache').put(cacheEntry);
        await tx.done;

        console.log(`Successfully cached "${songObject.name}"`);
        await manageCacheSize();

    } catch (error) {
        console.error(`Failed to cache ${songObject.name}:`, error);
    }
}

// This is a NEW function for proactive background caching
async function proactivelyCacheNextInQueue() {
    if (playQueue.length === 0 || currentQueueIndex < 0) return;

    // Look ahead 2 songs in the queue
    for (let i = 1; i <= 2; i++) {
        const nextIndex = currentQueueIndex + i;
        if (nextIndex >= playQueue.length) break;

        const nextSong = playQueue[nextIndex];
        if (nextSong.storage === 'tidal') {
            const tx = db.transaction('tidalCache', 'readonly');
            const store = tx.objectStore('tidalCache');
            const checkReq = store.get(nextSong.id);

            // Use an async function for the callback to handle the caching process
            checkReq.onsuccess = async () => {
                // If the song is not already in the cache, start the process
                if (!checkReq.result) {
                    console.log(`Proactively caching next song: ${nextSong.name}`);
                    try {
                        // THE FIX: Call the main, self-sufficient caching function.
                        // It already contains all the necessary logic for resilient, proxied fetching.
                        await processAndCachetidalTrack(nextSong);
                    } catch (err) {
                        console.error(`Failed to proactively cache ${nextSong.name}:`, err);
                    }
                }
            };
        }
    }
}

async function processAndCachetidalTrack(songObject) {
    try {
        const baseQualityLevels = ['LOSSLESS', 'HIGH', 'LOW'];
        let qualityLevelsToTry = [];
        if (songObject.audioQuality && baseQualityLevels.includes(songObject.audioQuality)) {
            qualityLevelsToTry.push(songObject.audioQuality);
        }
        baseQualityLevels.forEach(q => {
            if (!qualityLevelsToTry.includes(q)) {
                qualityLevelsToTry.push(q);
            }
        });

        let concatenatedBlob = null;

        for (const quality of qualityLevelsToTry) {
            const manifestUrl = `https://hifi.401658.xyz/dash/?id=${songObject.id}&quality=${quality}`;
            try {
                const response = await fetch(manifestUrl);
                if (response.ok) {
                    const text = await response.text();
                    if (text && text.trim().startsWith('<?xml')) {
                        console.log(`Found XML manifest for track ${songObject.id} at quality: ${quality}`);
                        const parser = new DOMParser();
                        const xmlDoc = parser.parseFromString(text, "application/xml");
                        const representation = xmlDoc.querySelector("Representation");
                        const segmentTemplate = representation.querySelector("SegmentTemplate");
                        const initUrl = segmentTemplate.getAttribute("initialization");
                        const mediaUrlTemplate = segmentTemplate.getAttribute("media");
                        const segmentTimeline = segmentTemplate.querySelector("SegmentTimeline");
                        const sElements = segmentTimeline.querySelectorAll("S");
                        const segments = [];
                        sElements.forEach(s => {
                            const r = parseInt(s.getAttribute("r") || "0");
                            for (let i = 0; i <= r; i++) segments.push(1);
                        });
                        const segmentUrls = [];
                        for (let i = 0; i < segments.length; i++) {
                            segmentUrls.push(mediaUrlTemplate.replace('$Number$', i + 1));
                        }
                        const [initSegmentBlob, ...mediaSegmentBlobs] = await Promise.all(
                            [initUrl, ...segmentUrls].map(url => fetch(url).then(res => res.blob()))
                        );
                        concatenatedBlob = new Blob([initSegmentBlob, ...mediaSegmentBlobs], { type: 'audio/mp4' });
                        break;
                    } else {
                        try {
                            const directUrlData = JSON.parse(text);
                            if (directUrlData && directUrlData.urls && directUrlData.urls.length > 0) {
                                console.log(`Found direct URL for track ${songObject.id} at quality: ${quality}`);
                                const audioResponse = await fetch(directUrlData.urls[0]);
                                if (audioResponse.ok) {
                                    concatenatedBlob = await audioResponse.blob();
                                    break;
                                }
                            }
                        } catch (e) {
                           console.warn(`Received non-XML/JSON response for quality ${quality}.`);
                        }
                    }
                }
            } catch (e) {
                console.warn(`Request failed for quality ${quality}:`, e);
            }
        }

        if (!concatenatedBlob) {
            throw new Error('Failed to fetch a valid manifest or direct URL for any quality level.');
        }
        
        const lrcDataResult = await fetchLyrics(songObject);
        const lrcData = lrcDataResult && lrcDataResult.type === 'lrc' ? parseLRC(lrcDataResult.content) : null;
        
        const cacheEntry = {
            id: songObject.id, blob: concatenatedBlob, timestamp: Date.now(), size: concatenatedBlob.size,
            metadata: {
                ...songObject,
                lyrics: lrcDataResult ? lrcDataResult.content : null, lrcData: lrcData,
            }
        };

        const tx = db.transaction('tidalCache', 'readwrite');
        tx.objectStore('tidalCache').put(cacheEntry);
        await tx.done;
        console.log(`Successfully processed and cached track "${songObject.name}"`);
        await manageCacheSize();
        return cacheEntry;
    } catch (error) {
        console.error(`Failed to process and cache track ${songObject.name}:`, error);
        return null;
    }
}

async function openArtistView(artistId, artistName) {
    currentDrawerContext = [];
    openDrawer(artistName, "Loading albums...", `<div class="loading-message"><svg width="24" height="24" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg" style="color: var(--text-color);"><style>.spinner_V8m1{transform-origin:center;animation:spinner_zKoa 2s linear infinite}.spinner_V8m1 circle{stroke-linecap:round;animation:spinner_YpZS 1.5s ease-in-out infinite}@keyframes spinner_zKoa{100%{transform:rotate(360deg)}}@keyframes spinner_YpZS{0%{stroke-dasharray:0 150;stroke-dashoffset:0}47.5%{stroke-dasharray:42 150;stroke-dashoffset:-16}95%,100%{stroke-dasharray:42 150;stroke-dashoffset:-59}}</style><g class="spinner_V8m1"><circle cx="12" cy="12" r="9.5" fill="none" stroke-width="3"></circle></g></svg></div>`);

    try {
        const response = await fetch(`https://hifi.401658.xyz/artist/?f=${artistId}`);
        if (!response.ok) throw new Error('Failed to fetch artist albums');
        
        const data = await response.json();
        const albums = data[2] || [];

        if (!albums || albums.length === 0) {
            drawerContent.innerHTML = `<div class="no-results"><p>No albums found for this artist.</p></div>`;
            return;
        }
        
        currentDrawerContext = albums;

        const contentHtml = `<div class="item-grid">${albums.map(album => `
            <div class="item-card" data-album-id="${album.id}" data-album-name="${sanitize(album.title)}" data-album-artist-name="${sanitize(artistName)}">
                <img src="${getHighResArtwork(album.cover, 320)}" class="item-card-art">
                <div class="item-card-info">
                    <div class="item-card-title">${sanitize(album.title)}</div>
                </div>
            </div>`).join('')}</div>`;
        
        const drawerSubtitleEl = document.getElementById('drawer-subtitle');
        drawerSubtitleEl.innerHTML = `
            <div style="display: flex; align-items: center; justify-content: center; gap: 15px;">
                <span>${albums.length} albums found</span>
                <button class="action-btn" id="save-artist-btn" style="padding: 8px 12px; height: auto;">
                    <span class="material-symbols-rounded" style="font-size: 16px;">arrow_circle_down</span>
                    Own All
                </button>
            </div>
        `;

        drawerContent.innerHTML = contentHtml;
        document.getElementById('save-artist-btn').addEventListener('click', () => saveArtistContent(currentDrawerContext, artistName));

    } catch (error) {
        console.error("Error fetching artist albums:", error);
        drawerContent.innerHTML = `<div class="no-results"><p>Could not load albums.</p></div>`;
    }
}
        
async function openAlbumView(albumId, albumName, artistName) {
    openDrawer(albumName, artistName, `<div class="loading-message"><svg width="24" height="24" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg" style="color: var(--text-color);"><style>.spinner_V8m1{transform-origin:center;animation:spinner_zKoa 2s linear infinite}.spinner_V8m1 circle{stroke-linecap:round;animation:spinner_YpZS 1.5s ease-in-out infinite}@keyframes spinner_zKoa{100%{transform:rotate(360deg)}}@keyframes spinner_YpZS{0%{stroke-dasharray:0 150;stroke-dashoffset:0}47.5%{stroke-dasharray:42 150;stroke-dashoffset:-16}95%,100%{stroke-dasharray:42 150;stroke-dashoffset:-59}}</style><g class="spinner_V8m1"><circle cx="12" cy="12" r="9.5" fill="none" stroke-width="3"></circle></g></svg></div>`);

    try {
        // FIX: Use the direct album endpoint to get its tracks.
        const response = await fetch(`https://hifi.401658.xyz/album/?id=${albumId}`);
        if (!response.ok) throw new Error('Failed to fetch album tracks');
        
        // This API returns a 2-element array: [album_metadata, { items: [tracks] }]
        const data = await response.json();
        const tracks = data[1].items.map(t => t.item);

        if (!tracks || tracks.length === 0) {
            drawerContent.innerHTML = `<div class="no-results"><p>No tracks found for this album.</p></div>`;
            return;
        }
        
        tracks.sort((a, b) => (a.volumeNumber || 1) - (b.volumeNumber || 1) || (a.trackNumber || 0) - (b.trackNumber || 0));
        currentDrawerContext = tracks;
        const albumArt = getHighResArtwork(tracks[0].album.cover);
        
        const contentHtml = `
            <div class="album-header-list" style="margin-bottom: 15px; display: flex; align-items: center; justify-content: space-between;">
                <div style="display: flex; align-items: center; gap: 15px;">
                    <img src="${albumArt}" style="width: 100px; height: 100px; border-radius: 12px; box-shadow: 0 0 0 1px var(--glass-border);">
                    <div>
                        <h2>${sanitize(albumName)}</h2>
                        <p>${sanitize(artistName)}</p>
                    </div>
                </div>
                <button class="action-btn" id="save-album-btn" style="padding: 8px 12px; height: auto; margin-right: 10px;">
                    <span class="material-symbols-rounded" style="font-size: 16px;">arrow_circle_down</span>
                    Own
                </button>
            </div>
            <div class="item-list">${tracks.map(track => `
                <div class="music-item" data-track-id="${track.id}" style="cursor: pointer;">
                    <div class="song-info">
                        <span class="track-number">${track.trackNumber}.</span>
                        <div class="song-title">${sanitize(track.title)}</div>
                    </div>
                </div>`).join('')}
            </div>`;

        drawerContent.innerHTML = contentHtml;
        document.getElementById('save-album-btn').addEventListener('click', () => saveAlbumContent(tracks, albumName));

    } catch (error) {
        console.error("Error fetching album tracks:", error);
        drawerContent.innerHTML = `<div class="no-results"><p>Could not load album tracks.</p></div>`;
    }
}

function openLocalAlbumView(artistName, albumName) {
    // Filter local songs based on artist and album
    const albumSongs = songs.filter(s => s.albumArtist === artistName && s.album === albumName)
                           .sort((a,b) => (a.trackNumber || 0) - (b.trackNumber || 0));

    if (albumSongs.length === 0) {
        openDrawer(albumName, artistName, `<div class="no-results"><p>No songs found for this local album.</p></div>`);
        return;
    }
    
    // Use the first song's art for the header
    const albumArt = albumSongs[0].albumArt;

    // Build the content HTML
    const contentHtml = `
        <div class="album-header-list" style="margin-bottom: 15px; display: flex; align-items: center; justify-content: space-between;">
            <div style="display: flex; align-items: center; gap: 15px;">
                <img src="${albumArt}" style="width: 100px; height: 100px; border-radius: 12px; box-shadow: 0 0 0 1px var(--glass-border);">
                <div>
                    <h2>${sanitize(albumName)}</h2>
                    <p>${sanitize(artistName)}</p>
                </div>
            </div>
        </div>
        <div class="item-list">${albumSongs.map(song => `
            <div class="music-item" data-id="${song.id}" style="cursor: pointer;">
                <div class="song-info">
                    <span class="track-number">${song.trackNumber || '•'}.</span>
                    <div class="song-title">${sanitize(song.name)}</div>
                </div>
            </div>`).join('')}
        </div>`;

    openDrawer(albumName, artistName, contentHtml);
}

async function fetchAndUpdateLyrics(song) {
    if (song.lyrics) {
        if (isPanelVisible && panelContent === 'lyrics') {
            renderLyrics();
        }
        return;
    }

    console.log(`Fetching lyrics for "${song.name}" in the background...`);
    const fetchedLyrics = await fetchLyrics(song);

    if (fetchedLyrics && currentlyPlayingSong && currentlyPlayingSong.id === song.id) {
        currentlyPlayingSong.lyrics = fetchedLyrics.content;
        currentlyPlayingSong.lrcData = fetchedLyrics.type === 'lrc' ? parseLRC(fetchedLyrics.content) : null;
        
        if (currentlyPlayingSong.storage === 'tidal') {
            updatetidalCacheWithLyrics(currentlyPlayingSong);
        } else {
            saveSongs();
        }

        if (isPanelVisible && panelContent === 'lyrics') {
            renderLyrics();
        }
    }
}
        
async function savetidalTrackToLibrary() {
    if (!currentlyPlayingSong || currentlyPlayingSong.storage !== 'tidal') return;

    const songToSave = currentlyPlayingSong;
    try {
        Gurasuraisu.showPopup(`Saving "${songToSave.name}"...`);
        let audioBlob;
        const tx = db.transaction('tidalCache', 'readonly');
        const cacheReq = await promiseIDBRequest(tx.objectStore('tidalCache').get(songToSave.id));
        if (cacheReq && cacheReq.blob) {
            audioBlob = cacheReq.blob;
        } else {
            const processedEntry = await processAndCacheAudio(songToSave);
            if (!processedEntry || !processedEntry.blob) throw new Error("Failed to process track for saving.");
            audioBlob = processedEntry.blob;
        }

        if (!songToSave.lyrics) {
            const fetchedLyrics = await fetchLyrics(songToSave);
            if (fetchedLyrics) {
                songToSave.lyrics = fetchedLyrics.content;
                songToSave.lrcData = fetchedLyrics.type === 'lrc' ? parseLRC(fetchedLyrics.content) : null;
                updatetidalCacheWithLyrics(songToSave);
            }
        }

        const newLocalId = Date.now() + Math.random();
        const newLocalSong = {
            id: newLocalId, name: songToSave.name, artist: songToSave.artist,
            album: songToSave.album, albumArtist: songToSave.artist,
            storage: 'indexeddb', handleName: `${songToSave.name}.mp3`,
            dateAdded: Date.now(), year: new Date().getFullYear().toString(),
            albumArt: songToSave.albumArt, trackNumber: songToSave.trackNumber,
            discNumber: songToSave.volumeNumber,
            lyrics: songToSave.lyrics, lrcData: songToSave.lrcData, playCount: 0,
            vibrantColor: songToSave.vibrantColor,
            isrc: songToSave.isrc,
            copyright: songToSave.copyright
        };
        const songTx = db.transaction(['songs', 'musicFiles'], 'readwrite');
        songTx.objectStore('songs').put(newLocalSong);
        songTx.objectStore('musicFiles').put({ id: newLocalId, file: audioBlob });
        await songTx.done;
        songs.push(newLocalSong);
        processAndSortSongs();
        updateLocalSongLookup([newLocalSong]);
        Gurasuraisu.showPopup(`Added "${songToSave.name}"`);
    } catch (error) {
        console.error("Failed to save track to library:", error);
        Gurasuraisu.showPopup("Cannot add song");
    }
}

async function batchSaveTidalTracks(tracks) {
    const newSongs = [];
    const filesToStore = [];
    let processedCount = 0;

    // Filter out tracks that are already in the local library using the ISRC map
    const tracksToProcess = tracks.filter(track => !track.isrc 
        || !isrcToLocalSongMap.has(track.isrc));

    if (tracksToProcess.length === 0) {
        return 0; // Nothing to do
    }

    // Concurrency Limiter
    const concurrencyLimit = 5;
    const queue = [...tracksToProcess];
    let activeWorkers = 0;
    const results = [];

    const processTrack = async (track) => {
        try {
            const audioBlob = (await processAndCacheAudio(track))?.blob;
            if (!audioBlob) throw new Error("Failed to process audio.");

            const fetchedLyrics = await fetchLyrics(track);

            const newLocalId = Date.now() + Math.random();
            const newLocalSong = {
                id: newLocalId, name: track.name, artist: track.artist,
                album: track.album, albumArtist: track.artist,
                storage: 'indexeddb', handleName: `${track.name}.mp3`,
                dateAdded: Date.now(), year: new Date().getFullYear().toString(),
                albumArt: track.albumArt, trackNumber: track.trackNumber,
                discNumber: track.volumeNumber,
                lyrics: fetchedLyrics ? fetchedLyrics.content : null,
                lrcData: (fetchedLyrics && fetchedLyrics.type === 'lrc') 
                    ? parseLRC(fetchedLyrics.content) : null,
                playCount: 0,
                vibrantColor: track.vibrantColor,
                isrc: track.isrc,
                copyright: track.copyright
            };
            
            return { 
                songData: newLocalSong, 
                fileData: { id: newLocalId, file: audioBlob } 
            };

        } catch (error) {
            console.error(`Failed to save track "${track.name}":`, error);
            return null; // Return null on failure for this track
        }
    };

    return new Promise(resolve => {
        const worker = async () => {
            while (queue.length > 0) {
                const track = queue.shift();
                const result = await processTrack(track);
                if (result) {
                    results.push(result);
                }
            }
            activeWorkers--;
            if (activeWorkers === 0) {
                // All workers are done, finalize the process
                finalizeBatchSave();
            }
        };

        const finalizeBatchSave = async () => {
            if (results.length === 0) {
                resolve(0);
                return;
            }

            const newSongsData = results.map(r => r.songData);
            const newFilesData = results.map(r => r.fileData);

            // Perform a single, large transaction
            const tx = db.transaction(['songs', 'musicFiles'], 'readwrite');
            const songStore = tx.objectStore('songs');
            const fileStore = tx.objectStore('musicFiles');
            newSongsData.forEach(song => songStore.put(song));
            newFilesData.forEach(file => fileStore.put(file));
            await tx.done;

            // Update in-memory state
            songs.push(...newSongsData);
            processAndSortSongs();
            updateLocalSongLookup(newSongsData);
            newSongsData.forEach(song => {
                if(song.isrc) isrcToLocalSongMap.set(song.isrc, song);
            });
            
            resolve(results.length);
        };

        // Start workers
        for (let i = 0; i < concurrencyLimit && queue.length > 0; i++) {
            activeWorkers++;
            worker();
        }
    });
}

async function saveArtistContent(albums, artistName) {
    Gurasuraisu.showPopup(`Saving all albums by: ${artistName}...`);
    for (const album of albums) {
        try {
            const response = await fetch(`https://hifi.401658.xyz/album/?id=${album.id}`);
            if (response.ok) {
                const data = await response.json();
                const tracks = data[1].items.map(t => t.item);
                await saveAlbumContent(tracks, album.title, true); // silent=true
            }
        } catch (error) {
            console.error(`Failed to fetch tracks for album ${album.title}:`, error);
        }
    }
    Gurasuraisu.showPopup(`Finished saving albums for ${artistName}.`);
    renderLibraryPage(); // Refresh the library view
}

async function saveAlbumContent(tracks, albumName, silent = false) {
    if (!silent) {
        Gurasuraisu.showPopup(`Saving album: "${albumName}"...`);
    }

    const tracksToSave = tracks.map(trackData => ({
        id: trackData.id, name: trackData.title, artist: trackData.artist.name,
        album: trackData.album.title, albumArt: getHighResArtwork(trackData.album.cover),
        storage: 'tidal', duration: trackData.duration, audioQuality: trackData.audioQuality,
        trackNumber: trackData.trackNumber, volumeNumber: trackData.volumeNumber,
        isrc: trackData.isrc, copyright: trackData.copyright,
        vibrantColor: trackData.album.vibrantColor
    }));

    const savedCount = await batchSaveTidalTracks(tracksToSave);

    if (!silent) {
        if (savedCount > 0) {
            Gurasuraisu.showPopup(`Saved ${savedCount} new track(s) from "${albumName}".`);
            renderLibraryPage();
        } else {
            Gurasuraisu.showPopup(`All tracks from "${albumName}" are already owned.`);
        }
    }
}
        
async function processAndCacheAudio(songObject) {
    try {
        const baseQualityLevels = ['LOSSLESS', 'HIGH', 'LOW'];
        let qualityLevelsToTry = [];
        if (songObject.audioQuality && baseQualityLevels.includes(songObject.audioQuality)) {
            qualityLevelsToTry.push(songObject.audioQuality);
        }
        baseQualityLevels.forEach(q => {
            if (!qualityLevelsToTry.includes(q)) {
                qualityLevelsToTry.push(q);
            }
        });

        let concatenatedBlob = null;

        for (const quality of qualityLevelsToTry) {
            const manifestUrl = `https://hifi.401658.xyz/dash/?id=${songObject.id}&quality=${quality}`;
            try {
                const response = await fetch(manifestUrl);
                if (response.ok) {
                    const text = await response.text();
                    if (text && text.trim().startsWith('<?xml')) {
                        console.log(`Found XML manifest for track ${songObject.id} at quality: ${quality}`);
                        const parser = new DOMParser();
                        const xmlDoc = parser.parseFromString(text, "application/xml");
                        const representation = xmlDoc.querySelector("Representation");
                        const segmentTemplate = representation.querySelector("SegmentTemplate");
                        const initUrl = segmentTemplate.getAttribute("initialization");
                        const mediaUrlTemplate = segmentTemplate.getAttribute("media");
                        const segmentTimeline = segmentTemplate.querySelector("SegmentTimeline");
                        const sElements = segmentTimeline.querySelectorAll("S");
                        const segments = [];
                        sElements.forEach(s => {
                            const r = parseInt(s.getAttribute("r") || "0");
                            for (let i = 0; i <= r; i++) segments.push(1);
                        });
                        const segmentUrls = [];
                        for (let i = 0; i < segments.length; i++) {
                            segmentUrls.push(mediaUrlTemplate.replace('$Number$', i + 1));
                        }
                        const [initSegmentBlob, ...mediaSegmentBlobs] = await Promise.all(
                            [initUrl, ...segmentUrls].map(url => fetch(url).then(res => res.blob()))
                        );
                        concatenatedBlob = new Blob([initSegmentBlob, ...mediaSegmentBlobs], { type: 'audio/mp4' });
                        break;
                    } else {
                        try {
                            const directUrlData = JSON.parse(text);
                            if (directUrlData && directUrlData.urls && directUrlData.urls.length > 0) {
                                console.log(`Found direct URL for track ${songObject.id} at quality: ${quality}`);
                                const audioResponse = await fetch(directUrlData.urls[0]);
                                if (audioResponse.ok) {
                                    concatenatedBlob = await audioResponse.blob();
                                    break;
                                }
                            }
                        } catch (e) {
                           console.warn(`Received non-XML/JSON response for quality ${quality}.`);
                        }
                    }
                }
            } catch (e) {
                console.warn(`Request failed for quality ${quality}:`, e);
            }
        }

        if (!concatenatedBlob) {
            throw new Error('Failed to fetch a valid manifest or direct URL for any quality level.');
        }
        
        const cacheEntry = {
            id: songObject.id, blob: concatenatedBlob, timestamp: Date.now(), size: concatenatedBlob.size,
            metadata: {
                ...songObject,
                lyrics: null,
                lrcData: null,
            }
        };

        const tx = db.transaction('tidalCache', 'readwrite');
        tx.objectStore('tidalCache').put(cacheEntry);
        await tx.done;
        console.log(`Successfully cached audio for "${songObject.name}"`);
        await manageCacheSize();
        return cacheEntry;
    } catch (error) {
        console.error(`Failed to cache audio for ${songObject.name}:`, error);
        return null;
    }
}
        
async function updatetidalCacheWithLyrics(song) {
    if (!song || song.storage !== 'tidal') return;

    try {
        const tx = db.transaction('tidalCache', 'readwrite');
        const store = tx.objectStore('tidalCache');
        const request = store.get(song.id);

        request.onsuccess = () => {
            const entry = request.result;
            if (entry) {
                // Add the new lyrics data to the cached metadata
                entry.metadata.lyrics = song.lyrics;
                entry.metadata.lrcData = song.lrcData;
                store.put(entry);
            }
        };
        await tx.done;
        console.log(`Saved lyrics for SC track "${song.name}" to cache.`);
    } catch (error) {
        console.error("Failed to update tidal cache with lyrics:", error);
    }
}

async function playtidalTrack(trackId, playContext = null) {
    const numericTrackId = Number(trackId);
    let songObject;
    try {
        const trackData = lasttidalSearchResults.find(t => t.id === numericTrackId) ||
                          currentDrawerContext.find(t => t.id === numericTrackId);

        if (!trackData) throw new Error("Track not found in search results");

        if (trackData.isrc && isrcToLocalSongMap.has(trackData.isrc)) {
            const localSong = isrcToLocalSongMap.get(trackData.isrc);
            console.log(`Found local version for "${trackData.title}". Playing from library.`);
            await playSong(localSong, null);
            return;
        }

        songObject = {
            id: trackData.id, name: trackData.title, artist: trackData.artist.name,
            album: trackData.album.title, albumArt: getHighResArtwork(trackData.album.cover),
            storage: 'tidal', duration: trackData.duration, audioQuality: trackData.audioQuality,
            trackNumber: trackData.trackNumber, volumeNumber: trackData.volumeNumber,
            isrc: trackData.isrc, copyright: trackData.copyright, vibrantColor: trackData.album.vibrantColor
        };
        
        currentlyPlayingSong = songObject;
        currentSongId = songObject.id;
        setPlayerLoadingState(true, songObject);

        const tx = db.transaction('tidalCache', 'readonly');
        const cachedEntry = await promiseIDBRequest(tx.objectStore('tidalCache').get(numericTrackId));
        
        if (cachedEntry) {
            console.log("Playing from cache.");
            const songToPlay = cachedEntry.metadata;
            songToPlay.blobUrl = URL.createObjectURL(cachedEntry.blob);
            await playSong(songToPlay, playContext);
            fetchAndUpdateLyrics(songToPlay);
            return;
        }
        
        console.log("Track not cached. Processing audio before playback.");
        const cachedSong = await processAndCacheAudio(songObject);
        if (cachedSong) {
            const songToPlay = cachedSong.metadata;
            songToPlay.blobUrl = URL.createObjectURL(cachedSong.blob);
            await playSong(songToPlay, playContext);
            fetchAndUpdateLyrics(songToPlay);
        } else {
            throw new Error("Caching and processing failed.");
        }
    } catch (error) {
        console.error(`Failed to play Hi-Fi track ${numericTrackId}:`, error);
        Gurasuraisu.showPopup("Cannot play selected item");
        isPlayerLoading = false;
        playNextSong({ userInitiated: false });
    } finally {
        setPlayerLoadingState(false, songObject);
    }
}
        
function connectAudioGraph() {
    if (source && audioContext && eqBass) {
        try {
            source.disconnect(); // Disconnect everything first to ensure a clean state
        } catch(e) { /* Fails if not connected, which is fine */ }
        // Reconnect the full chain: source -> EQ -> analyser -> output
        source.connect(eqBass);
        document.getElementById('visualizerCanvas').style.visibility = 'visible';
        console.log("Audio graph connected for visualizer and EQ.");
    }
}

function disconnectAudioGraph() {
    if (source) {
        try {
            // Disconnect the source from the processing graph (EQ/analyser).
            // The HTMLAudioElement will now play directly to the speakers by default.
            source.disconnect();
        } catch(e) { /* Fails if not connected, which is fine */ }
        document.getElementById('visualizerCanvas').style.visibility = 'hidden';
        console.log("Audio graph disconnected for CORS track. Visualizer/EQ disabled.");
    }
}
        
async function removeFolder(folderName) {
    if (!confirm(`Are you sure you want to remove the folder "${folderName}"? All songs from this folder will be removed from your library.`)) {
        return;
    }

    const initialSongCount = songs.length;
    
    // Update the list of active directory handles in memory
    directoryHandles = directoryHandles.filter(h => h.name !== folderName);

    const songsToKeep = [];
    for (const song of songs) {
        // Always keep songs that are stored directly in the browser's database
        if (song.storage === 'indexeddb') {
            songsToKeep.push(song);
            continue;
        }

        // For filesystem-based songs, check if their file still exists in any of the REMAINING folders
        if (song.storage === 'filesystem') {
            let isStillAvailable = false;
            for (const handle of directoryHandles) {
                try {
                    // Check if we can get a handle to the file. If this doesn't throw an error, the file exists.
                    await handle.getFileHandle(song.handleName, { create: false });
                    isStillAvailable = true;
                    break; // The song is safe, no need to check other folders
                } catch (e) {
                    // A "NotFoundError" is expected if the song was in the removed folder.
                    // We only log other potential errors (e.g., permission denied).
                    if (e.name !== 'NotFoundError') {
                        console.warn(`Permission or other error checking for "${song.handleName}" in "${handle.name}".`, e);
                    }
                }
            }
            // Only add the song to our list of survivors if it was found in a remaining folder.
            if (isStillAvailable) {
                songsToKeep.push(song);
            }
        }
    }

    const removedSongCount = initialSongCount - songsToKeep.length;
    
    // Replace the main songs array with the filtered list of survivors.
    songs = songsToKeep;

    // --- Persist all state changes and update the UI ---

    // 1. Save the updated (smaller) list of directory handles to the database.
    const tx = db.transaction('config', 'readwrite');
    tx.objectStore('config').put({ key: 'directoryHandles', value: directoryHandles });
    await tx.done;
    
    // 2. Save the updated (smaller) list of songs to the database.
    await saveSongs();

    // 3. Update the play queue in case a removed song was in it.
    updatePlayQueue();

    // 4. Show a confirmation message and refresh the UI.
    Gurasuraisu.showPopup(`Removed "${folderName}" and ${removedSongCount} song(s).`);
    openManageFoldersModal(); // Refreshes the folder list inside the modal.
    if (activeView === 'library') {
        renderLibraryPage(); // Refreshes the main library view in the background.
    }
}

        async function deleteSong(songIdToDelete) {
            const songIndex = songs.findIndex(s => s.id === songIdToDelete);
            if (songIndex === -1) return;
        
            const songToDelete = songs[songIndex];
            if (songToDelete.storage === 'indexeddb') {
                const tx = db.transaction('musicFiles', 'readwrite');
                tx.objectStore('musicFiles').delete(songIdToDelete);
                await tx.done;
            }
            
            if (songToDelete.isrc) {
                isrcToLocalSongMap.delete(songToDelete.isrc);
            }
        
            songs.splice(songIndex, 1);
            await saveSongs();
        
            if (songIdToDelete === currentSongId) {
                playNextSong(); 
            } else {
                updatePlayQueue();
            }
        }
        
        function openEditModal(songId) {
            const song = songs.find(s => s.id === songId);
            if (!song) return;
        
            editSongId.value = song.id;
            editTitle.value = song.name;
            editArtist.value = song.artist;
            editAlbum.value = song.album;
            openModal(editModal);
        }

        async function saveMetadataChanges() {
            const songId = parseFloat(editSongId.value);
            const song = songs.find(s => s.id === songId);
            if (!song) return;

            song.name = editTitle.value;
            song.artist = editArtist.value;
            song.album = editAlbum.value;

            if (song.id === currentSongId) {
                musicTitle.textContent = sanitize(song.name);
                musicArtist.textContent = song.artist;
                document.title = `${song.name} by ${song.artist}`;
                updateMediaSessionMetadata(song);
            }

            await saveSongs();
            closeModal(editModal);
        }

        function openPlaylistModal() {
            const playlistList = document.getElementById('playlistList');
            playlistList.innerHTML = '';
            if (playlists.length > 0) {
                 playlists.forEach(p => {
                    const item = document.createElement('div');
                    item.className = 'menu-item';
                    item.textContent = p.name;
                    item.onclick = () => addSongToPlaylist(p.id);
                    playlistList.appendChild(item);
                });
            } else {
                playlistList.innerHTML = '<p style="color: var(--secondary-text-color); text-align: center;">No playlists to add to</p>';
            }
            openModal(playlistModal);
        }
    
        async function fetchLyrics(song) {
            if (song.storage === 'tidal') { // 'tidal' now means 'hifi'
                return await fetchLyricsFromHifi(song);
            } else if (isLrclibEnabled) { // For local files, use LRCLIB if enabled
                return await fetchLyricsFromLrclib(song);
            }
            return null;
        }

        async function fetchLyricsFromHifi(song) {
            if (!song || !song.id) return null;
            try {
                const url = `https://hifi.401658.xyz/lyrics/?id=${song.id}`;
                const response = await fetch(url);
                if (!response.ok) {
                    console.warn(`Hifi Lyrics request failed with status: ${response.status}`);
                    return null;
                }
                const data = await response.json();
                if (!data || data.length === 0 || (!data[0].lyrics && !data[0].subtitles)) {
                    return null;
                }
                const lyricsData = data[0];
                if (lyricsData.subtitles) {
                    return { type: 'lrc', content: lyricsData.subtitles };
                } else if (lyricsData.lyrics) {
                    return { type: 'plain', content: lyricsData.lyrics };
                }
            } catch (error) {
                console.error("Error fetching lyrics from Hifi API:", error);
            }
            return null;
        }
        
function addQueueItemEventListeners() {
    document.querySelectorAll('.queue-item').forEach(item => {
        item.addEventListener('click', (e) => {
            // Prevent click from propagating to the remove button
            if (e.target.closest('.remove-from-queue-btn')) return;

            const songId = parseFloat(item.dataset.id);
            const song = playQueue.find(s => s.id === songId);
            if (song) {
                // --- THE FIX ---
                // We now call the play functions with "null" as the context.
                // This tells the player to find the song in the EXISTING queue
                // instead of creating a new one.
                if (song.storage === 'tidal') {
                    playtidalTrack(song.id, null);
                } else {
                    playSong(song, null);
                }
            }
        });
    });

    document.querySelectorAll('.remove-from-queue-btn').forEach(btn => {
        btn.addEventListener('click', (e) => {
            e.stopPropagation();
            isQueueUserModified = true; // <-- ADD THIS LINE: Removing a song is a manual edit.
            const indexToRemove = parseInt(e.currentTarget.dataset.queueIndex, 10);
            
            if (playQueue[indexToRemove].id === currentSongId) {
                playQueue.splice(indexToRemove, 1);
                if (playQueue.length > 0) {
                    let nextIndex = indexToRemove >= playQueue.length ? 0 : indexToRemove;
                    currentQueueIndex = nextIndex - 1;
                    playNextSong();
                } else {
                    resetPlayer();
                }
            } else {
                playQueue.splice(indexToRemove, 1);
                if (indexToRemove < currentQueueIndex) currentQueueIndex--;
            }
            renderQueue();
        });
    });
}

function makeQueueItemsDraggable() {
    const container = document.querySelector('.queue-list-container');
    if (!container) return;
    let draggedQueueItem = null;

    container.querySelectorAll('.queue-item').forEach(item => {
        item.setAttribute('draggable', 'true');
        item.addEventListener('dragstart', () => {
            draggedQueueItem = item;
            setTimeout(() => item.classList.add('dragging'), 0);
        });
        item.addEventListener('dragend', () => {
            if (draggedQueueItem) {
                draggedQueueItem.classList.remove('dragging');
                draggedQueueItem = null;
                updateQueueFromDOM();
            }
        });
    });

    container.addEventListener('dragover', e => {
        e.preventDefault();
        const afterElement = getDragAfterElement(container, e.clientY);
        if (afterElement == null) {
            container.appendChild(draggedQueueItem);
        } else {
            container.insertBefore(draggedQueueItem, afterElement);
        }
    });
}

function getDragAfterElement(container, y) {
    const draggableElements = [...container.querySelectorAll('.queue-item:not(.dragging)')];
    return draggableElements.reduce((closest, child) => {
        const box = child.getBoundingClientRect();
        const offset = y - box.top - box.height / 2;
        if (offset < 0 && offset > closest.offset) {
            return { offset, element: child };
        } else {
            return closest;
        }
    }, { offset: Number.NEGATIVE_INFINITY }).element;
}

function updateQueueFromDOM() {
    isQueueUserModified = true; 
    const newQueueOrder = [];
    document.querySelectorAll('.queue-item').forEach(item => {
        const songId = parseFloat(item.dataset.id);
        const song = playQueue.find(s => s.id === songId);
        if (song) newQueueOrder.push(song);
    });

    playQueue = newQueueOrder;
    currentQueueIndex = playQueue.findIndex(s => s.id === currentSongId);

    // Check if an autoplay song was moved to be next
    if (currentQueueIndex + 1 < playQueue.length) {
        const nextSongId = playQueue[currentQueueIndex + 1].id;
        if (autoplaySongIds.has(nextSongId)) {
            autoplaySongIds.delete(nextSongId);
        }
    }
    
    isShuffleEnabled = false;
    updateShuffleButtonState();
    
    renderQueue();
}
        
async function playNextSong({ userInitiated = false, isTransition = false } = {}) {
    if (userInitiated && repeatMode === 'one') toggleRepeat();
    if (!userInitiated && !isTransition && repeatMode === 'one') {
        audioPlayer.currentTime = 0;
        audioPlayer.play().catch(e => console.error("Repeat-one playback failed", e));
        return;
    }
    if (!playQueue || playQueue.length === 0) return;
    
    currentQueueIndex++;
    
    // If we have reached the end of the queue AND autoplay is enabled...
    if (isAutoplayEnabled && currentQueueIndex >= playQueue.length) {
        // ...await the generation of new songs. This ensures the queue is populated
        // before the function continues. The generate function already handles clearing old songs.
        await generateAutoplaySongs(); 
    }

    if (currentQueueIndex >= playQueue.length) {
        if (repeatMode === 'all') currentQueueIndex = 0;
        else {
            resetPlayer();
            return;
        }
    }

    const nextSong = playQueue[currentQueueIndex];
    if (nextSong) {
        // **THE FIX:** Check song type and call the correct function
        if (nextSong.storage === 'tidal') {
            playtidalTrack(nextSong.id);
        } else {
            playSong(nextSong, { isTransition });
        }
        proactivelyCacheNextInQueue();
    }
}
        
function playPreviousSong() {
    if (repeatMode === 'one') toggleRepeat();
    if (!playQueue.length) return;
    if (audioPlayer.currentTime > 5) {
        audioPlayer.currentTime = 0;
        audioPlayer.play().catch(e => console.error("Restart playback failed", e));
        return;
    }
    currentQueueIndex--;
    if (currentQueueIndex < 0) {
        currentQueueIndex = (repeatMode === 'all') ? playQueue.length - 1 : 0;
    }

    const prevSong = playQueue[currentQueueIndex];
    if (prevSong) {
        // **THE FIX:** Check song type and call the correct function
        if (prevSong.storage === 'tidal') {
            playtidalTrack(prevSong.id);
        } else {
            playSong(prevSong, { isTransition: false });
        }
        proactivelyCacheNextInQueue();
    }
}

function cleanupBlobs() {
    songs.forEach(song => {
        if (song.url) URL.revokeObjectURL(song.url);
    });
}
   
function toggleShuffle() {
    isShuffleEnabled = !isShuffleEnabled;
    document.getElementById("shuffleBtn").classList.toggle("active", isShuffleEnabled);

    if (playQueue.length <= 1) return; // No need to shuffle if queue is small

    if (isShuffleEnabled) {
        // When shuffle is turned ON, shuffle the current queue but keep the playing song at the top.
        const currentSong = playQueue[currentQueueIndex];
        let songsToShuffle = playQueue.filter(song => song.id !== currentSongId);
        
        shuffleArray(songsToShuffle); // Use the utility function we added previously

        // Rebuild the queue with the current song first, followed by the shuffled list.
        playQueue = [currentSong, ...songsToShuffle];
        currentQueueIndex = 0; // The current song is now at the start of the shuffled queue.
        isQueueUserModified = true; // Shuffling is a user modification of the queue order.
    }
    // Note: When shuffle is turned OFF, we do not re-sort the queue. It remains in its
    // current shuffled order until a new song/album is played.

    // Re-render the queue panel if it's open to show the new shuffled order.
    if (isPanelVisible && panelContent === 'queue') {
        renderQueue();
    }
}

function updateShuffleButtonState() {
    document.getElementById("shuffleBtn").classList.toggle("active", isShuffleEnabled);
}
        
function toggleRepeat() {
    const repeatBtn = document.getElementById('repeatBtn');
    switch(repeatMode) {
        case 'none':
            repeatMode = 'all';
            repeatBtn.innerHTML = '<span class="material-symbols-rounded">repeat</span>';
            repeatBtn.classList.add('active');
            break;
        case 'all':
            repeatMode = 'one';
            repeatBtn.innerHTML = '<span class="material-symbols-rounded">repeat_one</span>';
            break;
        case 'one':
            repeatMode = 'none';
            repeatBtn.innerHTML = '<span class="material-symbols-rounded">repeat</span>';
            repeatBtn.classList.remove('active');
            break;
    }
}
    
function updatePlayQueue() {
    if (isQueueUserModified) {
        currentQueueIndex = playQueue.findIndex(s => s.id === currentSongId);
        // Corrected check: if the queue panel is visible, re-render it
        if (isPanelVisible && panelContent === 'queue') {
            renderQueue();
        }
        return;
    }

    if (isShuffleEnabled) {
        let availableSongs = [...songs];
        let currentSong = currentSongId ? availableSongs.find(s => s.id === currentSongId) : null;
        if (currentSong) availableSongs = availableSongs.filter(s => s.id !== currentSongId);
        
        for (let i = availableSongs.length - 1; i > 0; i--) {
            const j = Math.floor(Math.random() * (i + 1));
            [availableSongs[i], availableSongs[j]] = [availableSongs[j], availableSongs[i]];
        }
        playQueue = currentSong ? [currentSong, ...availableSongs] : availableSongs;
    } else {
        const sortedSongs = [...songs].sort((a, b) => {
            const albumCompare = (a.albumArtist || '').localeCompare(b.albumArtist || '') 
                            || (a.album || '').localeCompare(b.album || '');
            if (albumCompare !== 0) return albumCompare;
            const discCompare = (a.effectiveDiscNumber || 1) - (b.effectiveDiscNumber || 1);
            if (discCompare !== 0) return discCompare;
            return (a.trackNumber || 0) - (b.trackNumber || 0);
        });
        playQueue = sortedSongs;
    }
    
    currentQueueIndex = playQueue.findIndex(s => s.id === currentSongId);
    // Corrected check: if the queue panel is visible, re-render it
    if (isPanelVisible && panelContent === 'queue') {
        renderQueue();
    }
}
        
function groupSongsByAlbum(songsToRender) {
  const albums = {};
  
  songsToRender.forEach(song => {
    const albumArtistName = song.albumArtist || song.artist || 'Unknown Artist';
    const albumName = song.album || 'Unknown Album';
    const albumKey = `${albumArtistName}::${albumName}::${song.effectiveDiscNumber}`;

    if (!albums[albumKey]) {
      const albumDisplayName = song.effectiveDiscNumber > 1 ? `${albumName} (Disc ${song.effectiveDiscNumber})` : albumName;
      albums[albumKey] = {
        name: albumDisplayName,
        artist: albumArtistName,
        year: song.year,
        albumArt: song.albumArt,
        songs: [],
        originalAlbum: albumName,
        originalAlbumArtist: albumArtistName,
        effectiveDiscNumber: song.effectiveDiscNumber,
        dateAdded: 0 
      };
    }
    albums[albumKey].songs.push(song);
  });
  
  for (let key in albums) {
      albums[key].dateAdded = Math.max(...albums[key].songs.map(s => s.dateAdded || 0));
      albums[key].songs.sort((a, b) => (a.trackNumber || 0) - (b.trackNumber || 0));
  }
  
  let albumArray = Object.values(albums);
  
  if (currentSortMode === 'dateAdded') {
      albumArray.sort((a, b) => b.dateAdded - a.dateAdded);
  } else { // 'alpha'
      albumArray.sort((a, b) => {
         const artistCompare = a.originalAlbumArtist.localeCompare(b.originalAlbumArtist);
         if (artistCompare !== 0) return artistCompare;
         const albumCompare = a.originalAlbum.localeCompare(b.originalAlbum);
         if (albumCompare !== 0) return albumCompare;
         return a.effectiveDiscNumber - b.effectiveDiscNumber;
      });
  }
  return albumArray;
}

async function updateMediaSessionMetadata(song) {
    if (!('mediaSession' in navigator)) return;

    // Phase 1: Immediately update text metadata, reusing the old artwork temporarily.
    // This prevents the notification from disappearing.
    const metadata = {
        title: song.name,
        artist: song.artist,
        album: song.album,
    };

    const temporaryArtworkSrc = currentMediaSessionArtBlobUrl || song.albumArt;
    
    navigator.mediaSession.metadata = new MediaMetadata({
        ...metadata,
        artwork: [{ src: temporaryArtworkSrc, sizes: '512x512', type: 'image/png' }]
    });

    // Phase 2: Asynchronously create the new blob URL and update the artwork.
    const oldBlobUrl = currentMediaSessionArtBlobUrl;
    let newBlobUrl = null;

    if (song.albumArt && song.albumArt.startsWith('data:')) {
        try {
            const response = await fetch(song.albumArt);
            const blob = await response.blob();
            newBlobUrl = URL.createObjectURL(blob);
        } catch (e) {
            console.error("Failed to create blob URL for media session artwork", e);
        }
    }
    
    currentMediaSessionArtBlobUrl = newBlobUrl;

    // Update the metadata again, this time with the final, correct artwork.
    const finalArtworkSrc = newBlobUrl || song.albumArt;
    navigator.mediaSession.metadata = new MediaMetadata({
        ...metadata,
        artwork: [
            { src: finalArtworkSrc, sizes: '96x96', type: 'image/png' },
            { src: finalArtworkSrc, sizes: '128x128', type: 'image/png' },
            { src: finalArtworkSrc, sizes: '192x192', type: 'image/png' },
            { src: finalArtworkSrc, sizes: '256x256', type: 'image/png' },
            { src: finalArtworkSrc, sizes: '384x384', type: 'image/png' },
            { src: finalArtworkSrc, sizes: '512x512', type: 'image/png' },
        ]
    });

    // Now that the new artwork is in place, it's safe to revoke the old URL.
    if (oldBlobUrl && oldBlobUrl !== newBlobUrl) {
        URL.revokeObjectURL(oldBlobUrl);
    }
}

function updateMediaSessionPlaybackState(state) {
    if ('mediaSession' in navigator) navigator.mediaSession.playbackState = state;
}

function updateMediaSessionPositionState() {
    if (!('mediaSession' in navigator) || !isFinite(audioPlayer.duration)) return;
    try {
        navigator.mediaSession.setPositionState({
            duration: audioPlayer.duration,
            playbackRate: audioPlayer.playbackRate,
            position: audioPlayer.currentTime,
        });
    } catch (error) {
        console.error("Error setting media session position state:", error);
    }
}

function setupMediaSessionActions() {
    if (!('mediaSession' in navigator)) return;

    navigator.mediaSession.setActionHandler('play', () => playPauseBtn.click());
    navigator.mediaSession.setActionHandler('pause', () => playPauseBtn.click());
    navigator.mediaSession.setActionHandler('nexttrack', () => playNextSong({ userInitiated: true }));
    navigator.mediaSession.setActionHandler('previoustrack', () => playPreviousSong());
    navigator.mediaSession.setActionHandler('stop', () => resetPlayer());

    navigator.mediaSession.setActionHandler('seekforward', (d) => { audioPlayer.currentTime = Math.min(audioPlayer.currentTime + (d.seekOffset || 10), audioPlayer.duration); });
    navigator.mediaSession.setActionHandler('seekbackward', (d) => { audioPlayer.currentTime = Math.max(audioPlayer.currentTime - (d.seekOffset || 10), 0); });
    navigator.mediaSession.setActionHandler('seekto', (d) => { audioPlayer.currentTime = d.seekTime; });
}
        
window.addEventListener("beforeunload", () => {
    if (currentSongId !== null) {
        localStorage.setItem("currentSong", JSON.stringify({
            id: currentSongId,
            progress: audioPlayer.currentTime
        }));
    } else {
        localStorage.removeItem("currentSong");
    }
});

window.addEventListener("load", async () => {
    try {
        if (isMobile) {
            document.body.classList.add('is-mobile');
        }
        
        await initDB();
        initModalVariables();

        if ('showDirectoryPicker' in window) {
            const tx = db.transaction('config', 'readonly');
            const handleReq = tx.objectStore('config').get('directoryHandles');
            const configResult = await new Promise(r => { handleReq.onsuccess = () => r(handleReq.result) });
            
            if (configResult && Array.isArray(configResult.value)) {
                const verifiedHandles = [];
                // **THE FIX IS HERE:** Check if the handles are valid before trying to use them.
                const storedHandles = configResult.value;
                for (const handle of storedHandles) {
                    // Plain objects from an import won't have the queryPermission method.
                    if (typeof handle.queryPermission === 'function') {
                        if (await verifyPermission(handle, false)) { // Don't prompt on load
                            verifiedHandles.push(handle);
                        }
                    } else {
                        console.warn(`Removed an invalid or restored folder handle: "${handle.name}". Please re-add the folder manually.`);
                    }
                }
                directoryHandles = verifiedHandles;

                // If some handles were invalid, update the database with the cleaned list.
                if (directoryHandles.length < storedHandles.length) {
                    Gurasuraisu.showPopup("Some music folders need to be re-added after the system import.");
                    const writeTx = db.transaction('config', 'readwrite');
                    writeTx.objectStore('config').put({ key: 'directoryHandles', value: directoryHandles });
                    await writeTx.done;
                }
                console.log(`Restored and verified ${directoryHandles.length} folder handles.`);
            }
        }

        // --- Load tidal Settings ---
        const configTx = db.transaction('config', 'readonly');
        const scIdReq = configTx.objectStore('config').get('tidalClientId');
        const scEnabledReq = configTx.objectStore('config').get('istidalEnabled');
        const corsProxyReq = configTx.objectStore('config').get('isCorsProxyEnabled');
        const lrclibReq = configTx.objectStore('config').get('isLrclibEnabled'); 
        
        const scIdResult = await new Promise(r => { scIdReq.onsuccess = () => r(scIdReq.result) });
        const scEnabledResult = await new Promise(r => { scEnabledReq.onsuccess = () => r(scEnabledReq.result) });
        const corsProxyResult = await new Promise(r => { corsProxyReq.onsuccess = () => r(corsProxyReq.result) });
        const lrclibEnabledResult = await new Promise(r => { lrclibReq.onsuccess = () => r(lrclibReq.result) }); 
        
        tidalClientId = scIdResult ? scIdResult.value : '';
        istidalEnabled = scEnabledResult ? scEnabledResult.value : false;
        isCorsProxyEnabled = corsProxyResult ? corsProxyResult.value : false;
        isLrclibEnabled = lrclibEnabledResult ? lrclibEnabledResult.value : false;
        toggletidalTab();

        await loadSongsAndPlaylists();
        await scanForNewSongs();
        await migrateToFSA();

        const savedData = localStorage.getItem("currentSong");
        if (savedData) {
            const { id, progress } = JSON.parse(savedData);
            const song = songs.find(s => s.id === id);
            if (song) {
                currentSongId = song.id;
                currentlyPlayingSong = song;
                updatePlayerUI(song);
                updateMiniplayerUI(song, 'paused');
                playPauseIcon.textContent = 'play_arrow';
                playPauseBtn.classList.remove('playing');
                isQueueUserModified = false;
                updatePlayQueue();
                const fileUrl = await getSongFileUrl(song);
                if (fileUrl) {
                    audioPlayer.src = fileUrl;
                    audioPlayer.load();
                    audioPlayer.onloadedmetadata = () => {
                         audioPlayer.currentTime = progress || 0;
                         updateTimeDisplays();
                         audioPlayer.onloadedmetadata = null;
                    };
                }
            }
        }
        
        setView('home');
        initDistortionCanvas();
    } catch (error) {
        console.error('Critical error on application load:', error);
    }
});

async function verifyPermission(handle, shouldRequest = false) {
    const options = { mode: 'read' };
    if (await handle.queryPermission(options) === 'granted') return true;
    if (shouldRequest && await handle.requestPermission(options) === 'granted') return true;
    console.warn(`Permission not granted for folder: ${handle.name}`);
    return false;
}

        function updatePlayerUI(song, progress = 0) {
            musicTitle.textContent = sanitize(song.name);
            musicArtist.textContent = song.artist;
            albumArtImg.src = song.albumArt;
            albumArtImg.classList.remove('fade-out');
            updateAllBackgrounds(song.albumArt);
            updateFavicon(song.albumArt);
            updateTimeDisplays(progress, audioPlayer.duration);

            // **MODIFICATION**: Prioritize the known (trimmed) duration from the song object
            const displayDuration = song.duration || audioPlayer.duration || 0;
            updateTimeDisplays(progress, displayDuration);
        }

        function updateTimeDisplays(current = 0, duration = 0) {
            currentTimeDisplay.textContent = formatTime(current);
            durationDisplay.textContent = formatTime(duration);
        }

let lastActiveIndex = -1;
let isUserScrollingLyrics = false;
let lyricsScrollTimeout = null;
let isProgrammaticScroll = false;

audioPlayer.addEventListener('timeupdate', async () => {
    if (currentSongId) {
        const song = currentlyPlayingSong;
        const duration = song.duration || audioPlayer.duration;
        const percentage = (audioPlayer.currentTime / duration) * 100;
        progress.style.width = `${percentage}%`;
        const scaledPercentage = (percentage / 100) * 93;
        miniplayerProgress.style.width = `${scaledPercentage}%`;
        updateTimeDisplays(audioPlayer.currentTime, audioPlayer.duration);
        updatePageTitle();

        // Only log plays for local songs
        if (song && song.storage !== 'tidal' && !song.hasBeenLogged && audioPlayer.currentTime > 30) {
            song.hasBeenLogged = true;
            await logSongPlay(song.id);
        }

        if (audioPlayer.duration) Gurasuraisu.updateMediaProgress({ currentTime: audioPlayer.currentTime, duration: audioPlayer.duration });
        if ('mediaSession' in navigator) updateMediaSessionPositionState();
        if (crossfadeEnabled && audioPlayer.duration > 0 && audioPlayer.duration - audioPlayer.currentTime < 3 && !audioPlayer.isFading) {
             audioPlayer.isFading = true;
             playNextSong({ isTransition: true });
        }
        
        if (song && song.lrcData && song.lrcData.lyrics && isPanelVisible && panelContent === 'lyrics') {
            if (isUserScrollingLyrics) return; // Halt updates while user scrolls

            const currentTime = audioPlayer.currentTime;
            const allLyricElements = document.querySelectorAll('#lyrics-scroll-container p');
            if (allLyricElements.length === 0) return;

            // 1. Find the single active timestamp
            let activeTime = -1;
            allLyricElements.forEach(el => {
                const elTime = parseFloat(el.dataset.time);
                if (!isNaN(elTime) && elTime <= currentTime) {
                    activeTime = elTime;
                }
            });

            // 2. Find all indices that match this active time
            const activeIndices = [];
            if (activeTime > -1) {
                allLyricElements.forEach((el, index) => {
                    if (parseFloat(el.dataset.time) === activeTime) {
                        activeIndices.push(index);
                    }
                });
            }

            const referenceIndex = activeIndices.length > 0 ? activeIndices[0] : -1;

            if (referenceIndex !== lastActiveIndex) { // Check for change to prevent redundant updates
                const firstActiveIndex = activeIndices.length > 0 ? activeIndices[0] : -1;
                const lastActiveIndexInGroup = activeIndices.length > 0 ? activeIndices[activeIndices.length - 1] : -1;

                allLyricElements.forEach((el, index) => {
                    const isActive = activeIndices.includes(index);
                    let blur = 0;
                    let opacity = 1;

                    if (!isActive) {
                        if (index > lastActiveIndexInGroup) { // Lines below active group
                            const distance = index - lastActiveIndexInGroup;
                            if (distance >= 5) {
                                blur = 5; opacity = 0;
                            } else {
                                blur = distance * 1.25;
                                opacity = 1 - (distance * 0.25);
                            }
                        } else { // Lines above active group
                            const distance = firstActiveIndex - index;
                            if (distance >= 2) {
                                blur = 3; opacity = 0;
                            } else { // distance is 1
                                blur = 1.5; opacity = 0.5;
                            }
                        }
                    }

                    el.style.filter = `blur(${blur}px)`;
                    el.style.opacity = opacity;
                });

                const activeElement = allLyricElements[referenceIndex];
                if (activeElement) {
                    isProgrammaticScroll = true;
                    activeElement.scrollIntoView({ behavior: 'smooth', block: 'start' });
                    // After a delay, reset the flag so user scrolls work again
                    setTimeout(() => { isProgrammaticScroll = false; }, 500);
                }
                lastActiveIndex = referenceIndex;
            }
        }
    }
});
        
playPauseBtn.addEventListener('click', async () => {
    if (audioContext && audioContext.state === 'suspended') {
        await audioContext.resume();
    }
    if (!currentSongId) return;

    if (!isVisualizerInitialized) initVisualizer();

    if (audioPlayer.paused) {
        if ('mediaSession' in navigator && navigator.mediaSession.metadata === null) {
            const song = currentlyPlayingSong;
            if (song) {
                updateMediaSessionMetadata(song);
                Gurasuraisu.registerMediaSession(
                    { title: song.name, artist: song.artist, album: song.album, artwork: [{ src: song.albumArt }] },
                    ['playPause', 'next', 'prev']
                );
            }
        }
        audioPlayer.play().catch(error => console.error("Play failed:", error));
    } else {
        audioPlayer.pause();
    }
});
        
nextBtn.addEventListener('click', async () => await playNextSong({ userInitiated: true }));
prevBtn.addEventListener('click', () => playPreviousSong());

function seekAudio(e) {
    if(isNaN(audioPlayer.duration)) return;
    const rect = progressBar.getBoundingClientRect();
    const clickX = Math.max(0, Math.min(e.clientX, rect.right)) - rect.left;
    const percent = Math.max(0, Math.min(1, clickX / rect.width));
    audioPlayer.currentTime = percent * audioPlayer.duration;
}

function handleProgressDrag(e) { if (isDragging) seekAudio(e.touches ? e.touches[0] : e); }

function closePanel() {
    if (!isPanelVisible) return;
    isPanelVisible = false;
    
    document.getElementById('now-playing-view').classList.remove('panel-is-open');

    // Remove the 'visible' class from the panel
    document.getElementById('lyrics-queue-panel').classList.remove('visible');
    
    // Remove the 'active' class from the buttons
    document.querySelector('.lyrics-button').classList.remove('active');
    document.querySelector('.queue-button').classList.remove('active');
    
    // Update the .now-playing-wrapper styles
    const nowPlayingWrapper = document.querySelector('.now-playing-wrapper');
    if (nowPlayingWrapper) {
        nowPlayingWrapper.style.padding = '5px';
        nowPlayingWrapper.style.alignItems = 'center';
    }
}
        
progressBar.addEventListener("click", e => seekAudio(e));
progressBar.addEventListener("mousedown", () => { isDragging = true; });
document.addEventListener("mouseup", () => { isDragging = false; });
document.addEventListener("mousemove", e => handleProgressDrag(e));
progressBar.addEventListener("touchstart", () => { isDragging = true; }, { passive: true });
document.addEventListener("touchend", () => { isDragging = false; });
document.addEventListener("touchmove", e => handleProgressDrag(e), { passive: true });


volumeSlider.addEventListener('input', (e) => {
    const volume = e.target.value / 100;
    audioPlayer.volume = volume;
    if (volume === 0) volumeIcon.textContent = 'volume_mute';
    else if (volume < 0.5) volumeIcon.textContent = 'volume_down';
    else volumeIcon.textContent = 'volume_up';
});

audioPlayer.addEventListener('pause', () => {
    const nowPlayingView = document.getElementById('now-playing-view');
    if(nowPlayingView) nowPlayingView.classList.add('paused');
    
    playPauseIcon.textContent = 'play_arrow';
    playPauseBtn.classList.remove('playing');
    updateMiniplayerUI(currentlyPlayingSong, 'paused');
    updateMediaSessionPlaybackState('paused');
    Gurasuraisu.updatePlaybackState({ playbackState: 'paused' });
});

audioPlayer.addEventListener('play', () => {
    const nowPlayingView = document.getElementById('now-playing-view');
    if(nowPlayingView) nowPlayingView.classList.remove('paused');

    playPauseIcon.textContent = 'pause';
    playPauseBtn.classList.add('playing');
    updateMiniplayerUI(currentlyPlayingSong, 'playing');
    updateMediaSessionPlaybackState('playing');
    Gurasuraisu.updatePlaybackState({ playbackState: 'playing' });

    if (!document.body.classList.contains('reduce-animations')) {
    }
});

audioPlayer.addEventListener('ended', () => {
    audioPlayer.isFading = false;
    playNextSong(); 
});

audioPlayer.addEventListener('durationchange', updateMediaSessionPositionState);
audioPlayer.addEventListener('loadedmetadata', updateMediaSessionPositionState);

document.addEventListener('DOMContentLoaded', async () => {
    try {
        await initDB();
        searchInput = document.getElementById('searchInput');
        const musicUploadInput = document.getElementById('musicUpload');
        const libraryGrid = document.getElementById('library-grid');
        
        searchInput.addEventListener('input', () => {
            clearTimeout(searchTimeout);
            searchTimeout = setTimeout(() => {
                if (activeView === 'search') {
                    renderSearchResults();
                }
            }, 300);
        });

        document.getElementById('search-results-grid').addEventListener('click', (e) => {
            const songItem = e.target.closest('.music-item[data-id]');
            if (songItem) {
                const songId = parseFloat(songItem.dataset.id);
                const song = songs.find(s => s.id === songId);
                if (song) {
                    // Get context from the search results
                    const contextSongs = Array.from(document.querySelectorAll('#search-results-grid .music-item[data-id]'))
                        .map(item => songs.find(s => s.id === parseFloat(item.dataset.id)))
                        .filter(Boolean);

                    isShuffleEnabled = false; 
                    updateShuffleButtonState();
                    
                    playSong(song, contextSongs);
                }
            }
        });
        
        document.getElementById('home-view').addEventListener('click', (e) => {
            const highlightCard = e.target.closest('.highlight-card[data-id]');
            const albumCard = e.target.closest('.item-card[data-album-id]');
    
            if (highlightCard) {
                const songId = parseFloat(highlightCard.dataset.id);
                const song = songs.find(s => s.id === songId);
                if (song) {
                    // Play this single song as its own context
                    playSong(song, [song]);
                }
            } else if (albumCard) {
                const albumId = albumCard.dataset.albumId;
                const [artist, albumName] = albumId.split('::');
                // When playing from a "Recently Played" album card, play the first song of that album
                const songToPlay = songs.find(s => s.albumArtist === artist && s.album === albumName);
                if(songToPlay) {
                    // The context is all songs from that album
                    const albumContext = songs.filter(s => s.albumArtist === artist && s.album === albumName);
                    playSong(songToPlay, albumContext);
                }
            }
        });

        libraryGrid.addEventListener('click', (e) => {
            const songItem = e.target.closest('.music-item[data-id]');
            const albumCard = e.target.closest('.item-card[data-album-id]');
            const artistCard = e.target.closest('.item-card[data-artist-name]');
            const playlistCard = e.target.closest('.item-card[data-playlist-id]');

            if (songItem) {
                const songId = parseFloat(songItem.dataset.id);
                const song = songs.find(s => s.id === songId);
                if (song) {
                    // Get the context from the currently displayed list
                    const contextSongs = Array.from(libraryGrid.querySelectorAll('.music-item[data-id]'))
                        .map(item => songs.find(s => s.id === parseFloat(item.dataset.id)))
                        .filter(Boolean);
                    isShuffleEnabled = false; 
                    updateShuffleButtonState();
                    playSong(song, contextSongs);
                }
            } else if (albumCard) {
                const albumId = albumCard.dataset.albumId;
                const [artist, albumName] = albumId.split('::');
                // When an album is clicked from the main library view, show its tracks.
                openLocalAlbumView(artist, albumName);
            } else if (artistCard) {
                const artistName = artistCard.dataset.artistName;
                const artistAlbums = groupSongsByAlbum(songs.filter(s => s.artist === artistName));
                const contentHtml = `<div class="item-grid">${artistAlbums.map(album => `
                    <div class="item-card" data-album-id="${album.artist}::${album.originalAlbum}">
                        <img src="${album.albumArt}" alt="${album.name}" class="item-card-art">
                        <div class="item-card-info">
                            <div class="item-card-title">${sanitize(album.name)}</div>
                        </div>
                    </div>`).join('')}</div>`;
                openDrawer(artistName, `${artistAlbums.length} albums`, contentHtml); // Pass details
            } else if (playlistCard) {
                 const playlistId = parseInt(playlistCard.dataset.playlistId, 10);
                 const playlist = playlists.find(p => p.id === playlistId);
                 const playlistSongs = playlist.songIds.map(id => songs.find(s => s.id === id)).filter(Boolean);
                 const contentHtml = `<div class="item-list">${playlistSongs.map(song => `
                    <div class="music-item" data-id="${song.id}" style="cursor: pointer;">
                         <div class="song-info">
                            <img src="${song.albumArt}" class="album-thumbnail" style="width: 40px; height: 40px; border-radius: 8px; margin-right: 6px;">
                            <div>
                                <div class="song-title">${sanitize(song.name)}</div>
                                <div class="album-artist" style="font-size: 0.8em;">${sanitize(song.artist)}</div>
                            </div>
                        </div>
                    </div>`).join('')}</div>`;
                openDrawer(playlist.name, `${playlistSongs.length} songs`, contentHtml, { type: 'playlist', id: playlistId }); // Pass details
            }
        });

        drawerContent.addEventListener('click', (e) => {
            const localSongItem = e.target.closest('.music-item[data-id]');
            const tidalSongItem = e.target.closest('.music-item[data-track-id]');
            const albumCard = e.target.closest('.item-card[data-album-id]');
            const backButton = e.target.closest('.drawer-back-btn'); // Correctly find the button

            if (backButton) {
                const artistName = backButton.dataset.artistName;
                const artistAlbums = groupSongsByAlbum(songs.filter(s => s.albumArtist === artistName));
                const contentHtml = `<div class="item-grid">${artistAlbums.map(album => {
                    const albumId = `${album.artist}::${album.originalAlbum}`;
                    return `
                    <div class="item-card" data-album-id="${sanitize(albumId)}">
                        <img src="${album.albumArt}" alt="${sanitize(album.name)}" class="item-card-art">
                        <div class="item-card-info">
                            <div class="item-card-title">${sanitize(album.name)}</div>
                        </div>
                    </div>`;
                }).join('')}</div>`;
                openDrawer(sanitize(artistName), `${artistAlbums.length} albums`, contentHtml);
            } else if (localSongItem) {
                // Logic for playing a local song from the library
                const songId = parseFloat(localSongItem.dataset.id);
                const song = songs.find(s => s.id === songId);
                if (song) {
                    const contextSongs = Array.from(drawerContent.querySelectorAll('.music-item[data-id]'))
                        .map(item => songs.find(s => s.id === parseFloat(item.dataset.id)))
                        .filter(Boolean);
                    playSong(song, contextSongs.length > 0 ? contextSongs : [song]);
                    closeDrawer();
                }
            } else if (albumCard) {
                const albumId = albumCard.dataset.albumId;
                const albumName = albumCard.dataset.albumName;
                const artistName = albumCard.dataset.albumArtistName;

                // Check if the albumId is a number (TIDAL) or a string (Local)
                if (!isNaN(parseFloat(albumId)) && isFinite(albumId)) {
                    // It's a numerical ID, so it's a TIDAL album.
                    openAlbumView(albumId, albumName, artistName);
                } else {
                    // It's a string like "Artist::Album", so it's a LOCAL album.
                    const [localArtist, localAlbum] = albumId.split('::');
                    openLocalAlbumView(localArtist, localAlbum);
                }
            } else if (tidalSongItem) {
                const trackId = tidalSongItem.dataset.trackId;
                const playContext = currentDrawerContext.map(track => ({
                    id: track.id,
                    name: track.title,
                    artist: track.artist.name,
                    album: track.album.title,
                    albumArt: getHighResArtwork(track.album.cover),
                    storage: 'tidal',
                    duration: track.duration,
                    audioQuality: track.audioQuality
                }));
                playtidalTrack(trackId, playContext);
                closeDrawer();
            }
        });

        document.getElementById('uploadBtn').addEventListener('click', async () => {
            if ('showDirectoryPicker' in window) {
                try {
                    const handle = await window.showDirectoryPicker();
                    if (await verifyPermission(handle, true)) {
                        directoryHandles.push(handle);
                        const tx = db.transaction('config', 'readwrite');
                        tx.objectStore('config').put({ key: 'directoryHandles', value: directoryHandles });
                        await tx.done;
                        await processDirectory(handle);
                    }
                } catch (err) {
                    if (err.name !== 'AbortError') console.error('Error picking directory:', err);
                }
            } else {
                musicUploadInput.click();
            }
        });

        musicUploadInput.addEventListener('change', (e) => {
            if (e.target.files.length > 0) addSongs(e.target.files, 'indexeddb');
        });
        
        document.querySelectorAll('.filter-container .filter-btn').forEach(btn => {
            btn.addEventListener('click', () => {
                document.querySelector('.filter-container .filter-btn.active').classList.remove('active');
                btn.classList.add('active');
                currentFilter = btn.dataset.filter;
                if (activeView === 'library') renderLibraryPage();
            });
        });

        const sortBtn = document.getElementById('sortBtn');
        const sortModeDisplay = document.getElementById('sort-mode-display');

        sortBtn.addEventListener('click', () => {
            // Toggle the sort mode
            currentSortMode = currentSortMode === 'alpha' ? 'dateAdded' : 'alpha';
            
            // Update the button's appearance
            if (currentSortMode === 'alpha') {
                sortBtn.innerHTML = `<span class="material-symbols-rounded">sort_by_alpha</span><span id="sort-mode-display"></span>`;
            } else {
                sortBtn.innerHTML = `<span class="material-symbols-rounded">history</span><span id="sort-mode-display"></span>`;
            }
            
            // Re-render the library with the new sorting
            renderLibraryPage();
        });

        // ADD listener for the new "Save to Library" button
        document.getElementById('menuSaveToLibrary').addEventListener('click', () => {
            savetidalTrackToLibrary();
            moreOptionsMenu.classList.remove('visible');
        });
    
        // ADD listener for the offline search input
        document.getElementById('tidalOfflineSearchInput').addEventListener('input', renderOfflinetidalView);
    
        // ADD listeners for the new filter buttons
        document.getElementById('tidal-filter-container').addEventListener('click', (e) => {
            const btn = e.target.closest('.filter-btn-sc');
            if (btn) {
                document.querySelector('#tidal-filter-container .filter-btn-sc.active').classList.remove('active');
                btn.classList.add('active');
                tidalFilter = btn.dataset.filter;
                searchtidal();
            }
        });

        document.body.addEventListener('click', async (e) => {
            // AI Playlist Creation Button
            if (e.target.id === 'aiCreatePlaylistBtn') {
                const promptInput = document.getElementById('aiPlaylistPrompt');
                const prompt = promptInput.value.trim();
                if (!prompt) return;
        
                e.target.htmlContent = '<svg width="18" height="18" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg" style="color: var(--text-color);"><style>.spinner_V8m1{transform-origin:center;animation:spinner_zKoa 2s linear infinite}.spinner_V8m1 circle{stroke-linecap:round;animation:spinner_YpZS 1.5s ease-in-out infinite}@keyframes spinner_zKoa{100%{transform:rotate(360deg)}}@keyframes spinner_YpZS{0%{stroke-dasharray:0 150;stroke-dashoffset:0}47.5%{stroke-dasharray:42 150;stroke-dashoffset:-16}95%,100%{stroke-dasharray:42 150;stroke-dashoffset:-59}}</style><g class="spinner_V8m1"><circle cx="12" cy="12" r="9.5" fill="none" stroke-width="3"></circle></g></svg>';
                e.target.disabled = true;
        
                const fullPrompt = `${prompt}\n\nLibrary:\n${formatLibraryForPrompt()}`;
                const result = await musicAiModel.generateContent(fullPrompt);
                const call = result.response.functionCalls()?.[0];
                if (call && call.name === 'createPlaylist') {
                    availableMusicFunctions.createPlaylist(call.args);
                } else {
                    Gurasuraisu.showPopup("GuraAI was unable to create a playlist from that prompt.");
                }
                promptInput.value = '';
                e.target.htmlContent = '<span class="material-symbols-rounded" style="font-size: 18px;">add</span>';
                e.target.disabled = false;
            }
        
            // --- AI Home Page Prompt Bar & Dynamic Buttons ---
            const handleHomeAiPrompt = async (prompt) => {
                if (!prompt || !musicAiModel) return;
                const fullPrompt = `${prompt}\n\nLibrary:\n${formatSongsForAiPrompt(songs)}`;
                try {
                    const result = await musicAiModel.generateContent(fullPrompt);
                    const call = result.response.functionCalls()?.[0];
        
                    if (call && call.name === 'createPlaylist') {
                        availableMusicFunctions.createPlaylist(call.args);
                    } else if (call && call.name === 'getSongRecommendations') {
                        const recommendedSongs = call.args.songs.map(s => findSongByString(s)).filter(Boolean);
                        if (recommendedSongs.length > 0) {
                             const contentHtml = `<div class="item-list">${recommendedSongs.map(song => `
                                <div class="music-item" data-id="${song.id}" style="cursor: pointer;">
                                     <div class="song-info">
                                        <img src="${song.albumArt}" class="album-thumbnail" style="width: 40px; height: 40px; border-radius: 8px; margin-right: 6px;">
                                        <div><div class="song-title">${sanitize(song.name)}</div><div class="album-artist" style="font-size: 0.8em;">${sanitize(song.artist)}</div></div>
                                    </div>
                                </div>`).join('')}</div>`;
                            openDrawer("GuraAI Recommendations", prompt, contentHtml);
                        } else {
                             Gurasuraisu.showPopup("GuraAI couldn't find any matching songs for that.");
                        }
                    } else {
                        Gurasuraisu.showPopup("GuraAI could not process that request.");
                    }
                } catch (err) {
                    console.error("Error handling Home AI Prompt:", err);
                    Gurasuraisu.showPopup("An error occurred with the AI request.");
                }
            };
        
            if (e.target.id === 'aiPromptSubmit') {
                const input = document.getElementById('aiPromptInput');
                handleHomeAiPrompt(input.value.trim());
                input.value = '';
            }
        
            if (e.target.matches('#ai-dynamic-prompts .action-btn')) {
                handleHomeAiPrompt(e.target.dataset.prompt);
            }

            if (e.target.closest('#drawer-delete-playlist-btn')) {
                const button = e.target.closest('#drawer-delete-playlist-btn');
                const playlistId = parseInt(button.dataset.playlistId, 10);
                if (playlistId) {
                    deletePlaylist(playlistId);
                }
            }
        });
        
        setupLongPressListeners(document.getElementById('library-grid'));
        setupLongPressListeners(document.getElementById('search-results-grid'));
        setupLongPressListeners(drawerContent);

        initVisualizer();
        setupMediaSessionActions();

        document.getElementById('shuffleBtn').addEventListener('click', toggleShuffle);
        document.getElementById('repeatBtn').addEventListener('click', toggleRepeat);

        const lyricsQueuePanel = document.getElementById('lyrics-queue-panel');
        isPanelVisible = false;
        panelContent = null; // 'lyrics' or 'queue'

        const togglePanel = (newContent) => {
            const nowPlayingView = document.getElementById('now-playing-view');
            if (isPanelVisible && panelContent === newContent) {
                closePanel();
            } else {
                // Show or switch the panel
                isPanelVisible = true;
                panelContent = newContent;
                
                nowPlayingView.classList.add('panel-is-open');

                if (panelContent === 'lyrics') {
                    renderLyrics();
                } else {
                    renderQueue();
                    scrollToCurrentSongInQueue();
                }
                
                lyricsQueuePanel.classList.add('visible');

                // Only modify .now-playing-wrapper if viewport is 981px or larger
                const nowPlayingWrapper = document.querySelector('.now-playing-wrapper');
                if (nowPlayingWrapper && window.innerWidth >= 981) {
                    nowPlayingWrapper.style.setProperty('padding', '5px 20px 5px 5px', 'important');
                    nowPlayingWrapper.style.setProperty('align-items', 'flex-end', 'important');
                }
            }
            
            document.querySelector('.lyrics-button').classList.toggle('active', isPanelVisible && panelContent === 'lyrics');
            document.querySelector('.queue-button').classList.toggle('active', isPanelVisible && panelContent === 'queue');
        };
        
        document.querySelector('.lyrics-button').addEventListener('click', () => togglePanel('lyrics'));
        document.querySelector('.queue-button').addEventListener('click', () => togglePanel('queue'));
                
        tabBtns.forEach(btn => {
            btn.addEventListener('click', () => {
                if (isDrawerOpen) {
                    closeDrawer();
                    return; 
                }
                const viewName = btn.dataset.view;
                const currentViewElement = document.getElementById(`${activeView}-view`);
                if (currentViewElement) {
                    scrollPositions[activeView] = currentViewElement.scrollTop;
                }
                setView(viewName);
            });
        });
    
        miniplayer.addEventListener('click', (e) => {
            if (e.target.closest('.mini-control-btn')) return;
        
            const currentViewElement = document.getElementById(`${activeView}-view`);
            if (currentViewElement) {
                scrollPositions[activeView] = currentViewElement.scrollTop;
            }
        
            setView('now-playing');
        });
        
        // Wire up miniplayer controls
        miniplayerPlayBtn.addEventListener('click', (e) => {
            e.stopPropagation();
            playPauseBtn.click();
        });
        document.getElementById('miniplayer-next-btn').addEventListener('click', (e) => {
            e.stopPropagation();
            nextBtn.click();
        });
        document.getElementById('miniplayer-prev-btn').addEventListener('click', (e) => {
            e.stopPropagation();
            prevBtn.click();
        });

        const nowPlayingView = document.getElementById('now-playing-view');
        const moreButton = nowPlayingView.querySelector('.more-button');
        const moreOptionsMenu = document.getElementById('moreOptionsMenu');

        moreButton.addEventListener('click', (e) => {
            e.stopPropagation();
            if (!currentSongId || !currentlyPlayingSong) {
                Gurasuraisu.showPopup('No song is currently playing');
                return;
            }
            
            const isLocal = currentlyPlayingSong.storage !== 'tidal';
        
            // Show/hide menu items based on song type
            document.getElementById('menuEditMetadata').style.display = isLocal ? 'flex' : 'none';
            document.getElementById('menuDeleteSong').style.display = isLocal ? 'flex' : 'none';
            document.getElementById('menuAddToPlaylist').style.display = isLocal ? 'flex' : 'none';

            // Show "Save to Library" ONLY for tidal songs.
            document.getElementById('menuSaveToLibrary').style.display = isLocal ? 'none' : 'flex';
                    
            moreOptionsMenu.classList.toggle('visible');
        });

        document.addEventListener('click', (e) => {
            // Close menu if clicking outside of it or its trigger button
            if (!e.target.closest('#moreOptionsMenu') && !e.target.closest('.more-button')) {
                moreOptionsMenu.classList.remove('visible');
            }
        });

        document.getElementById('menuDeleteSong').addEventListener('click', async () => {
            if (currentSongId && confirm('Delete this song? This is permanent.')) await deleteSong(currentSongId);
            moreOptionsMenu.classList.remove('visible');
        });
        
        document.getElementById('menuFullscreenBtn').addEventListener('click', () => {
            isFullscreen = !isFullscreen; // Toggle the state
            toolbar.classList.toggle('hidden', isFullscreen); // Update toolbar based on new state
        
            // Toggle additional styles based on fullscreen state
            const albumArt = document.querySelector('.album-art');
            const playerControls = document.querySelector('.player-controls');
            const volumeControl = document.querySelector('.volume-control');
            
            if (albumArt) {
                albumArt.style.setProperty('margin-top', isFullscreen ? '0px' : '', 'important');
            }
            
            if (playerControls) {
                playerControls.style.display = isFullscreen ? 'none' : '';
            }
        
            if (volumeControl) {
                volumeControl.style.display = isFullscreen ? 'none' : '';
            }
        });
        
        document.getElementById('menuEditMetadata').addEventListener('click', () => { if (currentSongId) openEditModal(currentSongId); moreOptionsMenu.classList.remove('visible'); });
        document.getElementById('menuCrossfade').addEventListener('click', toggleCrossfade);
        document.getElementById('menuSleepTimer').addEventListener('click', () => { openModal(sleepTimerModal); moreOptionsMenu.classList.remove('visible'); });
        document.getElementById('menuAddToPlaylist').addEventListener('click', () => { if (currentSongId) openPlaylistModal(); moreOptionsMenu.classList.remove('visible'); });
        document.getElementById('menuEqualizer').addEventListener('click', () => { openModal(equalizerModal); moreOptionsMenu.classList.remove('visible'); });

        document.getElementById('shuffleBtn').addEventListener('click', toggleShuffle);
        document.getElementById('repeatBtn').addEventListener('click', toggleRepeat);

        document.getElementById('manageFoldersBtn').addEventListener('click', openManageFoldersModal);
        document.getElementById('saveIntegrations').addEventListener('click', saveIntegrationSettings);

        const tidalSearchInput = document.getElementById('tidalSearchInput');
        tidalSearchInput.addEventListener('input', () => {
            clearTimeout(tidalSearchTimeout);
            tidalSearchTimeout = setTimeout(searchtidal, 300);
        });
        
        document.getElementById('tidal-results-grid').addEventListener('click', e => {
            if (e.target && e.target.id === 'loadMoreBtn') {
                e.target.innerHTML = 'Loading...';
                e.target.disabled = true;
                searchtidal({ loadMore: true });
                return;
            }

            const trackCard = e.target.closest('.item-card[data-track-id]');
            const cachedCard = e.target.closest('.music-item[data-cached-id]');
            const artistCard = e.target.closest('.item-card[data-artist-id]');
            const albumCard = e.target.closest('.item-card[data-album-id]');
        
            if (trackCard) {
                const playContext = lasttidalSearchResults.map(track => ({
                    id: track.id,
                    name: track.title,
                    artist: track.artist.name,
                    album: track.album.title,
                    albumArt: getHighResArtwork(track.album.cover),
                    storage: 'tidal'
                }));
                playtidalTrack(trackCard.dataset.trackId, playContext);
            } else if (cachedCard) {
                const trackId = parseFloat(cachedCard.dataset.cachedId);
                const contextNodes = document.querySelectorAll('#tidal-results-grid .music-item[data-cached-id]');
                const playContext = Array.from(contextNodes).map(node => {
                    return {
                        id: parseFloat(node.dataset.cachedId),
                        name: node.querySelector('.song-title').textContent,
                        artist: node.querySelector('.album-artist').textContent,
                        albumArt: node.querySelector('img').src,
                        storage: 'tidal'
                    };
                });
                playtidalTrack(trackId, playContext);
            } else if (artistCard) {
                const artistId = artistCard.dataset.artistId;
                const artistName = artistCard.dataset.artistName;
                openArtistView(artistId, artistName);
            } else if (albumCard) {
                const albumId = albumCard.dataset.albumId;
                const albumName = albumCard.dataset.albumName;
                const artistName = albumCard.dataset.albumArtistName;
                openAlbumView(albumId, albumName, artistName);
            }
        });
    
        // Add the new listener for the offline toggle
        document.getElementById('tidalOfflineToggle').addEventListener('click', () => {
            istidalOfflineMode = !istidalOfflineMode;
            rendertidalPage();
        });

        setupDrawerInteractions();
    } catch (error) {
        console.error('Failed to initialize application:', error);
    }
});

// Call the AI initializer on page load
initializeMusicAi();

document.getElementById('uploadBtn').addEventListener('click', async () => {
    if ('showDirectoryPicker' in window) {
        try {
            const handle = await window.showDirectoryPicker();
            
            for (const existingHandle of directoryHandles) {
                if (await handle.isSameEntry(existingHandle)) {
                    Gurasuraisu.showPopup("This folder has already been added.");
                    return;
                }
            }

            if (await verifyPermission(handle, true)) {
                directoryHandles.push(handle);
                const tx = db.transaction('config', 'readwrite');
                tx.objectStore('config').put({ key: 'directoryHandles', value: directoryHandles });
                await tx.done;
                await processDirectory(handle);
            }
        } catch (err) {
            if (err.name !== 'AbortError') console.error('Error picking directory:', err);
        }
    } else {
        document.getElementById('musicUpload').click();
    }
});

        musicUpload.addEventListener('change', (e) => {
            if (e.target.files.length > 0) addSongs(e.target.files, 'indexeddb');
        });
        
        async function processDirectory(handle) {
            const filesToAdd = [];
            const existingSongNames = new Set(songs.map(s => s.handleName));

            for await (const entry of handle.values()) {
                if (entry.kind === 'file' && isAudioFile({ name: entry.name }) && !existingSongNames.has(entry.name)) {
                    filesToAdd.push(entry);
                }
            }

            if (filesToAdd.length > 0) {
                Gurasuraisu.showPopup(`${filesToAdd.length} new songs added to Library`);
                await addSongs(filesToAdd, 'filesystem');
            } else {
                Gurasuraisu.showPopup('No new songs found in the selected directory.');
            }
        }

        function toggleCrossfade() {
            crossfadeEnabled = !crossfadeEnabled;
            document.getElementById('crossfadeStatus').textContent = crossfadeEnabled ? 'On' : 'Off';
        }

        function setSleepTimer(minutes) {
            clearTimeout(sleepTimerId);
            if (minutes > 0) {
                sleepTimerId = setTimeout(() => {
                    audioPlayer.pause();
                    playPauseIcon.textContent = 'play_arrow';
                    playPauseBtn.classList.remove('playing');
                }, minutes * 60 * 1000);
                Gurasuraisu.showPopup(`Sleep timer set for ${minutes} minutes.`);
            } else {
                Gurasuraisu.showPopup('Sleep timer cancelled.');
            }
            closeModal(sleepTimerModal);
        }
        
async function loadSongsAndPlaylists() {
    try {
        const songTx = db.transaction('songs', 'readonly');
        const songRequest = songTx.objectStore('songs').getAll();
        const loadedSongs = await new Promise((resolve, reject) => {
            songRequest.onsuccess = () => resolve(songRequest.result);
            songRequest.onerror = () => reject(songRequest.error);
        });
        
        songs = Array.isArray(loadedSongs) ? loadedSongs : [];
        songs.forEach(song => { if (!song.dateAdded) song.dateAdded = song.id; });
        processAndSortSongs();
        updateLocalSongLookup(songs, { clear: true });

        isrcToLocalSongMap.clear();
        songs.forEach(song => {
            if (song.isrc) {
                isrcToLocalSongMap.set(song.isrc, song);
            }
        });

        const playlistTx = db.transaction('playlists', 'readonly');
        const playlistRequest = playlistTx.objectStore('playlists').getAll();
        const loadedPlaylists = await new Promise((resolve, reject) => {
            playlistRequest.onsuccess = () => resolve(playlistRequest.result);
            playlistRequest.onerror = () => reject(playlistRequest.error);
        });
        playlists = Array.isArray(loadedPlaylists) ? loadedPlaylists : [];
        
        console.log(`Loaded ${songs.length} songs and ${playlists.length} playlists.`);

    } catch (error) {
        console.error("Failed to load data from IndexedDB:", error);
        songs = []; playlists = [];
    }
}

        async function createPlaylistAndAddSong() {
            const newName = document.getElementById('newPlaylistName').value.trim();
            if (!newName) return;
            if (!currentSongId) return Gurasuraisu.showPopup("Please play a song first.");
        
            const newPlaylist = { name: newName, songIds: [currentSongId] };
            
            try {
                const tx = db.transaction('playlists', 'readwrite');
                const request = tx.objectStore('playlists').add(newPlaylist);
                await new Promise((resolve, reject) => {
                    request.onerror = () => reject(request.error);
                    tx.oncomplete = () => {
                        newPlaylist.id = request.result;
                        resolve();
                    };
                });
        
                playlists.push(newPlaylist);
                document.getElementById('newPlaylistName').value = '';
                closeModal(playlistModal);
                Gurasuraisu.showPopup(`Added song to new playlist "${newName}"`);
            } catch (error) {
                console.error("Failed to create playlist:", error);
            }
        }

        async function addSongToPlaylist(playlistId) {
            const playlist = playlists.find(p => p.id === playlistId);
            if (!playlist || !currentlyPlayingSong) return;
        
            const songToAdd = currentlyPlayingSong;
            
            if (!playlist.songIds.includes(songToAdd.id)) {
                playlist.songIds.push(songToAdd.id);
                
                if (songToAdd.storage === 'tidal') {
                    const tx = db.transaction('tidalCache', 'readonly');
                    const checkReq = await promiseIDBRequest(tx.objectStore('tidalCache').get(songToAdd.id));
                    if (!checkReq) {
                        await processAndCachetidalTrack(songToAdd);
                    }
                }
                
                const writeTx = db.transaction('playlists', 'readwrite');
                writeTx.objectStore('playlists').put(playlist);
                await writeTx.done;
                Gurasuraisu.showPopup(`Added to "${playlist.name}"`);
            } else {
                Gurasuraisu.showPopup(`Song is already in "${playlist.name}"`);
            }
            closeModal(playlistModal);
        }

        Gurasuraisu.onMediaControl({
            playPause: () => playPauseBtn.click(),
            next: () => nextBtn.click(),
            prev: () => prevBtn.click()
        });
    </script>
</body>
</html>
