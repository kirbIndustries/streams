<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
    <title>Music</title>
    <link id="favicon" rel="icon" type="image/png" href="favicon.png">
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Material+Symbols+Rounded:opsz,wght,FILL,GRAD@24,700,1,0">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jsmediatags/3.9.5/jsmediatags.min.js"></script>
    <script src="/assets/gurapp/api/gurasuraisu-api.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>
    <style>
        :root {
            --edge-refraction-filter: url('#edge-refraction-only');
            
            /* Dark Theme (Default) Variables */
            --background-color-dark: #1c1c1c;
            --text-color-dark: #f9f9f9;
            --secondary-text-color-dark: rgba(255, 255, 255, 0.7);
            --modal-background-dark: rgba(51, 51, 51, 0.8);
            --modal-transparent-dark: rgba(51, 51, 51, 0.7);
            --search-background-dark: rgba(51, 51, 51, 0.5);
            --dark-overlay: rgba(51, 51, 51, 0.2);
            --dark-transparent: rgba(255, 255, 255, 0.1); 
            --glass-border-dark: rgba(100, 100, 100, 0.2);
            
            /* Light Theme Variables */
            --background-color-light: #f0f0f0;
            --text-color-light: #333333;
            --secondary-text-color-light: rgba(0, 0, 0, 0.7);
            --modal-background-light: rgba(220, 220, 220, 0.8);
            --modal-transparent-light: rgba(240, 240, 240, 0.7);
            --search-background-light: rgba(220, 220, 220, 0.5);
            --light-overlay: rgba(220, 220, 220, 0.2);
            --light-transparent: rgba(255, 255, 255, 0.1);
            --glass-border-light: rgba(200, 200, 200, 0.2);
            
            /* Default to Dark Theme */
            --background-color: var(--background-color-dark);
            --text-color: var(--text-color-dark);
            --secondary-text-color: var(--secondary-text-color-dark);
            --modal-background: var(--modal-background-dark);
            --modal-transparent: var(--modal-transparent-dark);
            --search-background: var(--search-background-dark);
            --overlay-color: var(--dark-overlay);
            --transparent-color: var(--dark-transparent);
            --glass-border: var(--glass-border-dark);
        }
        
        body.light-theme {
            --background-color: var(--background-color-light);
            --text-color: var(--text-color-light);
            --secondary-text-color: var(--secondary-text-color-light);
            --modal-background: var(--modal-background-light);
            --modal-transparent: var(--modal-transparent-light);
            --search-background: var(--search-background-light);
            --overlay-color: var(--light-overlay);
            --transparent-color: var(--light-transparent);
            --glass-border: var(--glass-border-light);
        }
        
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: 'Inter', sans-serif;
            -webkit-tap-highlight-color: transparent;
            cursor: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="20px" height="20px" viewBox="0 0 10.04 10.04"><circle cx="5.02" cy="5.02" r="4.52" style="fill:rgba(0,0,0,0.5);stroke:rgba(255,255,255,0.5);stroke-width:1"/></svg>') 10 10, auto !important;
        }
        
        body {
            background-color: var(--background-color);
            min-height: 100vh;
            display: flex;
            user-select: none;
            position: relative;
            overflow: hidden;
            transition: background-color 0.3s, color 0.3s, background-image 0.5s;
            color: var(--text-color);
        }

        .toolbar {
            display: flex;
            justify-content: center;
            align-content: center;
            flex-direction: row;
            gap: 10px;
            padding: 15px 20px;
            background-color: transparent;
            border: none;
            position: fixed;
            top: 0px;
            left: 50%;
            transform: translateX(-50%);
            z-index: 1000;
            transition: top 0.3s ease;
            width: 100%;
            flex-wrap: wrap;
            height: 80px;
        }

        .toolbar.hidden {
            display: none;
        }

        .toolbar::before {
            content: "";
            position: absolute;
            inset: 0;
            z-index: -1;
        }

        .toolbar::after {
            content: "";
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: -2;
            backdrop-filter: blur(2.5px);
            mask-image: linear-gradient( to bottom, rgba(0, 0, 0, 1) 0%, rgba(0, 0, 0, 1) 90%, rgba(0, 0, 0, 0) 100% );
            -webkit-mask-image: linear-gradient( to bottom, rgba(0, 0, 0, 1) 0%, rgba(0, 0, 0, 1) 90%, rgba(0, 0, 0, 0) 100% );
        }

        .tab-btn {
            background-color: var(--search-background);
            color: transparent;
            border: none;
            border-radius: 25px;
            padding: 10px 9px 10px 18px;
            font-size: 0;
            cursor: pointer;
            transition: all 0.3s cubic-bezier(.3,1.2,.64,1) !IMPORTANT;
            display: flex;
            align-items: center;
            gap: 8px;
            backdrop-filter: blur(5px) saturate(2) var(--edge-refraction-filter);
            border: 1px solid var(--glass-border);
        }

        .tab-btn.active {
            background-color: var(--secondary-text-color);
            color: var(--background-color);
            border-radius: 15px;
            font-family: 'Open Runde';
            font-weight: 500;
            padding: 10px 18px 10px 16px;
            font-size: revert;
        }

        .toolbar .tab-btn .material-symbols-rounded {
            transition: color 0.3s;
            color: var(--text-color);
            font-size: 20px;
        }

        .toolbar .tab-btn.active .material-symbols-rounded {
            color: var(--background-color) !important;
        }

        .view-container {
            flex-grow: 1;
            width: 100%;
            padding: 80px 20px 0 20px;
            overflow-y: auto;
            overflow-x: hidden;
            min-height: 0;
        }

        .view-container::-webkit-scrollbar { width: 8px; }
        .view-container::-webkit-scrollbar-track { background: transparent; }
        .view-container::-webkit-scrollbar-thumb { background-color: var(--search-background); border-radius: 50px; }

        #now-playing-view {
            padding-top: 0;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        #bottom-miniplayer {
            position: fixed;
            bottom: 24px;
            left: 50%;
            transform: translateX(-50%);
            width: 95%;
            max-width: 528px;
            height: 64px;
            background-color: var(--search-background);
            border: 1px solid var(--glass-border);
            border-radius: 22px;
            backdrop-filter: blur(5px) saturate(2) var(--edge-refraction-filter);
            display: flex;
            align-items: center;
            padding: 8px;
            gap: 12px;
            z-index: 1001;
            cursor: pointer;
            overflow: hidden;
            transition: all 0.3s cubic-bezier(.3,1.2,.64,1);
            box-shadow: 0 0 50px rgba(0, 0, 0, 0.2);
        }
        #bottom-miniplayer:active {
            transform: translateX(-50%) scale(1.05);
            transition: all 0.1s cubic-bezier(0.2, 0, 0.38, 0.9);
            filter: brightness(1.5);
        }
        #bottom-miniplayer.hidden {
            bottom: -100px;
            opacity: 0;
            pointer-events: none;
        }
        #miniplayer-art {
            width: 48px;
            height: 48px;
            border-radius: 12px;
            box-shadow: 0 0 0 1px var(--glass-border);
            flex-shrink: 0;
        }
        .miniplayer-info {
            display: flex;
            flex-direction: column;
            gap: 2px;
            flex-grow: 1;
            min-width: 0;
            color: var(--text-color);
        }
        #miniplayer-title, #miniplayer-artist {
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }
        #miniplayer-title { font-weight: bold; font-size: 16px; font-family: 'Open Runde'; }
        #miniplayer-artist { font-size: 16px; color: var(--secondary-text-color); }

        .miniplayer-controls { display: flex; align-items: center; gap: 4px; padding-right: 8px; }
        .mini-control-btn {
            background: none;
            border: none;
            color: var(--text-color);
            width: 40px;
            height: 40px;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        .miniplayer-progress {
            position: absolute;
            bottom: 0;
            left: 3.5%;
            max-width: 93%;
            height: 2px;
            background-color: var(--secondary-text-color);
            width: 0%; /* JS will control this */
            transition: width 0.25s ease;
            border-radius: 5px;
        }

        /* Responsive miniplayer */
        #miniplayer-prev-btn, #miniplayer-next-btn { display: none; }
        @media (min-width: 500px) {
            #miniplayer-prev-btn, #miniplayer-next-btn { display: flex; }
        }

        /* Generic Grid for Home/Library/Search */
        .page-content-wrapper {
            width: 100%;
            max-width: 1400px;
            margin: 0 auto;
            display: flex;
            flex-direction: column;
            height: 0;
        }
        .item-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(160px, 1fr));
            gap: 20px;
            padding-bottom: 125px;
        }
        .item-card {
            background-color: transparent; /* Cards will be minimal */
            border-radius: 12px;
            transition: all 0.2s ease;
            cursor: pointer;
            display: flex;
            flex-direction: column;
            gap: 10px;
            cursor: pointer;
            transform: scale(1);
            transition: all 0.15s cubic-bezier(0.2, 0, 0.38, 0.9);
        }
        .item-card-art {
            width: 100%;
            aspect-ratio: 1 / 1;
            box-shadow: 0 0 0 1px var(--glass-border);
            border-radius: 12px;
            object-fit: cover;
        }
        .item-card-info { padding: 0 0 4px 0; }
        .item-card-title { font-weight: 500; font-family: 'Open Runde'; }
        .item-card-subtitle { font-size: 14px; color: var(--secondary-text-color); }
        .section-title {
            font-size: 1.5rem;
            font-weight: 600;
            margin-bottom: 20px;
        }
        .item-card:active {
            transform: scale(0.96);
            transition: all 0.1s cubic-bezier(0.2, 0, 0.38, 0.9);
            filter: brightness(1.5);
        }

        .library-controls {
            display: flex;
            flex-wrap: nowrap;
            gap: 10px;
            flex-direction: row;
            justify-content: center;
            align-content: center;
            position: fixed;
            left: 50%;
            transform: translateX(-50%);
            z-index: 1002;
            background-color: var(--search-background);
            backdrop-filter: blur(5px) saturate(2) var(--edge-refraction-filter);
            padding: 10px 12px;
            border-radius: 32px;
            border: 1px solid var(--glass-border);
            box-shadow: 0 0 15px rgba(0, 0, 0, 0.05);
            bottom: 100px;
        }

        @media (max-width: 630px) {
            .library-controls {
                flex-wrap: wrap;
            }
        }

        .search-container {
            position: relative;
            flex-grow: 1;
            min-width: 200px;
            margin-bottom: 10px;
        }

        .library-search-input {
            width: 100%;
            padding: 10px 15px 10px 40px;
            border-radius: 25px;
            border: 1px solid var(--glass-border);
            background: var(--search-background);
            color: var(--text-color);
            backdrop-filter: blur(5px) saturate(2) var(--edge-refraction-filter);
            font-size: 14px;
            outline: none;
        }
        
        .search-icon {
            font-size: 22px;
            position: absolute;
            left: 15px;
            top: 50%;
            transform: translateY(-50%);
            color: var(--secondary-text-color);
            pointer-events: none;
        }

        .filter-container, .view-controls, .library-actions {
            display: flex;
            gap: 10px;
        }

        .filter-container .filter-btn, .filter-container .filter-btn-sc {
            padding: 8px 16px;
            height: 42px;
            border-radius: 10px;
        }

        .filter-container .filter-btn:active, .filter-container .filter-btn-sc:active {
            transform: scale(1);
            padding: 8px 20px;
            filter: brightness(1.5);
        }

        .filter-container .filter-btn.active, .filter-container .filter-btn-sc.active {
            background: var(--secondary-text-color);
            color: var(--background-color);
            border-radius: 25px !important;
            font-family: 'Open Runde';
            font-weight: 500;
        }
        
        .filter-container .filter-btn .material-symbols-rounded, .filter-container .filter-btn-sc .material-symbols-rounded{
            font-size: 22px;
        }
        
        .action-btn {
            background-color: var(--search-background);
            color: var(--text-color);
            border: none;
            border-radius: 50px;
            padding: 8px 16px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            height: 42px;
            backdrop-filter: blur(5px) saturate(2) var(--edge-refraction-filter);
            border: 1px solid var(--glass-border);
        }

        .library-action-btn {
            background-color: transparent;
            color: var(--text-color);
            border: none;
            border-radius: 50px;
            padding: 10px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            height: 42px;
        }

        .library-action-btn.active {
            background-color: var(--secondary-text-color);
            color: var(--background-color);
        }

          @keyframes fadeInOut {
            0% { opacity: 0; transform: translate(-50%, 20px); }
            10% { opacity: 1; transform: translate(-50%, 0); }
            90% { opacity: 1; transform: translate(-50%, 0); }
            100% { opacity: 0; transform: translate(-50%, -20px); }
          }
        
        .music-list::-webkit-scrollbar,
        #lyrics-queue-panel::-webkit-scrollbar,
        .lyrics-container::-webkit-scrollbar {
            width: 4px;
        }
                
        .music-list::-webkit-scrollbar-track,
        #lyrics-queue-panel::-webkit-scrollbar-track,
        .lyrics-container::-webkit-scrollbar-track {
            background: rgba(255, 255, 255, .0);
        }
        
        .music-list::-webkit-scrollbar-thumb,
        #lyrics-queue-panel::-webkit-scrollbar-thumb,
        .lyrics-container::-webkit-scrollbar-thumb {
            background: var(--modal-transparent);
            border-radius: 4px;
        } 

        #queue-list-container {
            gap: 10px;
            display: flex;
            flex-direction: column;
        }
        
        .upload-btn {
            background-color: var(--search-background);
            color: var(--text-color);
            backdrop-filter: blur(5px) saturate(2) var(--edge-refraction-filter);
            border-radius: 25px;
            padding: 10px 16px;
            cursor: pointer;
            transition: background-color 0.2s;
            display: flex; 
            align-items: center;
            border: 1px solid var(--glass-border);
            gap: 6px;
        }
        
        .music-list {
            display: flex;
            flex-direction: column;
            gap: 10px;
            overflow-y: auto;
            flex-grow: 1;
            border-radius: 10px;
        }

        .music-item.dragging, .album-section.dragging, .queue-item.dragging {
          opacity: 0.5;
          background-color: var(--modal-background);
          box-shadow: 0 0 15px rgba(0, 0, 0, 0.3);
          position: relative;
          z-index: 1000;
          transition: transform 0.1s ease;
        }
        
        .music-item {
            padding: 12px 16px;
            background-color: var(--search-background);
            border: none;
            border-radius: 20px;
            color: var(--text-color);
            cursor: pointer;
            transition: all 0.3s ease;
            border: 1px solid var(--glass-border);
            cursor: grab;
            touch-action: pan-y;
            overflow: hidden;
            min-height: fit-content;
            position: relative;
        }

        .queue-item {
            padding: 8px 1px;
            background-color: transparent;
            border: none;
            border-radius: 0;
            color: var(--text-color);
            cursor: pointer;
            transition: all 0.3s ease;
            cursor: grab;
            touch-action: pan-y;
            overflow: hidden;
            min-height: fit-content;
            position: relative;
        }
        
        .music-item.active {
            background-color: var(--background-color) !important;
            font-weight: bold;
            border-radius: 40px;
            transition: all 0.3s ease;
        }

        .queue-item.active {
            background-color: var(--search-background) !important;
            font-weight: bold;
            border-radius: 11px;
            transition: all 0.3s ease;
            padding: 5px 1px;
            border: 1px solid var(--glass-border);
            margin: 3px 0;
            backdrop-filter: blur(5px) saturate(2) var(--edge-refraction-filter);
        }

        .queue-item.active .song-title {
            font-family: 'Open Runde';
        }
            
        .album-art {
            border-radius: 12px;
            background-color: var(--modal-transparent);
            display: flex;
            align-items: center;
            justify-content: center;
            overflow: hidden;
            transition: transform 0.5s ease, opacity 0.3s ease;
            max-width: 500px;
            max-height: 500px;
            aspect-ratio: 1 / 1;
            box-shadow: 0 0 15px rgba(0, 0, 0, 0.05);
            margin-top: 80px;
            outline: 1px solid var(--glass-border);
        }

        .album-art.fade-out {
            opacity: 0;
            transform: scale(0.95);
        }
        
        .album-art img {
            width: 100%;
            height: 100%;
            object-fit: cover;
            border-radius: 12px;
        }

        /* Generic Modal Styling */
        .modal-overlay {
            position: fixed;
            inset: 0;
            background-color: var(--overlay-color);
            z-index: 1003;
            display: flex;
            align-items: center;
            justify-content: center;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.3s ease;
        }

        .modal-overlay.visible {
            opacity: 1;
            pointer-events: auto;
        }
        
        .music-info {
            display: flex;
            justify-content: space-between;
            align-items: center;
            color: var(--text-color);
            text-align: left;
            max-width: 500px;
            width: 100%;
        }
        
        .music-text {
            display: flex;
            flex-direction: column;
            flex-grow: 1;
            gap: 8px;
            min-width: 0;
            padding-right: 16px;
            width: 0
        }
        
        .music-title {
            font-size: 1.3rem;
            word-wrap: break-word;
            font-weight: bold;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            line-height: 1.3;
            font-family: 'Open Runde';
        }
        
        .music-artist {
            color: var(--text-color);
            font-size: 0.9em;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            line-height: 1.3;
        }
        
        .more-button {
            background: var(--overlay-color);
            border: 1px solid var(--glass-border);
            cursor: pointer;
            color: var(--text-color);
            padding: 8px;
            border-radius: 50%;
            transition: background 0.2s ease;
            backdrop-filter: blur(5px) saturate(2) var(--edge-refraction-filter);
        }
        
        .quality-badge {
            display: inline-block;
            padding: 4px 12px;
            border-radius: 12px;
            font-size: 0.8em;
            font-weight: 500;
            margin-top: 5px;
            background: var(--search-background);
            color: var(--text-color);
        }
        
        .quality-lossless {
            background: rgba(189, 214, 255, .2);
            color: #bdd6ff;
        }
        
        .quality-enhanced {
            background: rgba(144, 238, 144, .2);
            color: #90ee90;
        }
        
        .quality-normal {
            background: rgba(255, 255, 255, .2);
            color: var(--text-color);
        }
                
        .player-controls {
            display: flex;
            align-items: center;
            justify-content: center;
            max-width: 500px;
            box-sizing: border-box;
            width: 100%;
            justify-content: space-between;
            margin-bottom: 80px;
        }
        
        .player-controls button:nth-child(2),
        .player-controls button:nth-child(3),
        .player-controls button:nth-child(4) {
            order: 1; /* Middle group gets priority */
        }
        
        .player-controls button:nth-child(1) {
            order: 0; /* Shuffle on the left */
        }
        
        .player-controls button:nth-child(5) {
            order: 2; /* Repeat on the right */
        }
                
        .control-btn {
            background: var(--search-background);
            border: none;
            color: var(--text-color);
            width: 50px;
            height: 50px;
            border-radius: 35px;
            cursor: pointer;
            font-size: 1.2rem;
            transition: all 0.2s;
            display: flex;
            justify-content: center;
            align-items: center;
            line-height: 0;
            backdrop-filter: blur(5px) saturate(2) var(--edge-refraction-filter);
            border: 1px solid var(--glass-border);
        }
        
        .control-btn.play-pause {
            background-color: var(--search-background);
            width: 70px;
            height: 70px;
            font-size: 1.5rem;
            transition: all 0.3s ease;
            border-radius: 35px;
            display: flex;
            justify-content: center;
            align-items: center;
            line-height: 0;
        }
        
        .control-btn.play-pause.playing {
            border-radius: 25px;
        }
        
        .progress-container {
            display: flex;
            flex-direction: column;
            gap: 12px;
            width: 100%;
            max-width: 500px;
        }
        
        .progress-bar {
            width: 100%;
            height: 8px;
            background: var(--search-background);
            border-radius: 25px;
            cursor: pointer;
            transition: all 0.25s ease;
            backdrop-filter: blur(5px) saturate(2) var(--edge-refraction-filter);
            box-shadow: 0 0 0 1px var(--glass-border);
            overflow: hidden;
        }
        
        .progress {
            height: 100%;
            background: var(--secondary-text-color);
            border-radius: 25px;
            width: 0%;
            transition: all 0.25s ease;
            border: 1px solid var(--glass-border);
        }
        
        .time-info {
            display: flex;
            justify-content: space-between;
            color: var(--text-color);
            font-variant-numeric: tabular-nums;
            font-size: 0.9rem;
        }
        
        .controls-container {
            display: flex;
            align-items: center;
            gap: 8px;
            position: fixed;
            bottom: 30px;
            z-index: 10;
        }
        
        .controls-container span {
            color: var(--text-color);
            font-size: 18px;
        }

        #visualizerCanvas {
            width: 28px;
            height: 28px;
            vertical-align: middle;
        }

        .lyrics-button, .queue-button, .more-button {
            background: var(--search-background);
            border: 1px solid var(--glass-border);
            cursor: pointer;
            width: 37px;
            height: 37px;
            color: var(--text-color);
            border-radius: 50%;
            transition: all 0.2s;
            backdrop-filter: blur(5px) saturate(2) var(--edge-refraction-filter);
        }

        .goto-btn {
            background: var(--search-background);
            border: 1px solid var(--glass-border);
            cursor: pointer;
            padding: 10px 16px;
            color: var(--text-color);
            border-radius: 25px;
            transition: background 0.2s ease;
            backdrop-filter: blur(5px) saturate(2) var(--edge-refraction-filter);
        }

        .lyrics-button.active, .queue-button.active {
            background: var(--secondary-text-color);
            color: var(--background-color);
            border-radius: 14px;
        }

        .lyrics-button.active .material-symbols-rounded, .queue-button.active .material-symbols-rounded {
            color: var(--background-color);
        }

        .volume-control {
            display: flex;
            align-items: center;
            gap: 10px;
            background: var(--search-background);
            border-radius: 25px;
            padding: 5px 10px 5px 10px;
            backdrop-filter: blur(5px) saturate(2) var(--edge-refraction-filter);
            border: 1px solid var(--glass-border);
            height: 37px;
            width: 100px;
        }
        
        .volume-control span {
            color: var(--text-color);
            font-size: 20px;
        }
        
        .volume-slider {
            width: 100%;
            height: 25px;
            -webkit-appearance: none;
            background: rgba(0, 0, 0, .0);
            outline: none;
        }
        
        .volume-slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 15px;
            height: 15px;
            background: var(--text-color);
            border-radius: 50%;
            cursor: pointer;
            border: 1px solid var(--glass-border);
            transition: width 0.3s, height 0.3s, transform 0.3s;
        }

        .volume-slider::-webkit-slider-thumb:active {
            width: 21px;
            height: 21px;
            transform: scale(1.1);
        }

        .volume-slider::-moz-range-thumb {
            width: 15px;
            height: 15px;
            border-radius: 50%;
            background: var(--text-color);
            cursor: pointer;
            border: 1px solid var(--glass-border);
            transition: width 0.3s, height 0.3s, transform 0.3s;
        }

        .volume-slider::-moz-range-thumb:active {
            width: 21px;
            height: 21px;
            transform: scale(1.1);
        }
        
        .album-section {
            padding: 20px 0 10px;
            border-top: 1.5px solid var(--glass-border);
        }

        .album-section::after {
          content: '';
          position: absolute;
          left: 0;
          right: 0;
          height: 2px;
          background: transparent;
          transition: background 0.3s;
        }
        
        .album-section.drag-over::after {
          background: var(--text-color);
        }
        
        .album-header {
            display: flex;
            align-items: center;
            gap: 15px;
            margin-bottom: 15px;
            cursor: grab;
            position: relative;
        }
        
        .album-thumbnail {
            width: 60px;
            height: 60px;
            border-radius: 15px;
            object-fit: cover;
            box-shadow: 0 0 0 1px var(--glass-border);
        }
        
        .album-info {
            color: var(--text-color);
        }
        
        .album-name {
            font-weight: 600;
            font-size: 1.1em;
        }
        
        .album-artist, .album-year {
            color: var(--text-color);
            font-size: 0.9em;
        }
        
        .album-songs {
            display: flex;
            flex-direction: column;
            gap: 5px;
        }
        
        .song-info {
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        .track-number {
            color: var(--secondary-text-color);
            min-width: 25px;
            text-align: center;
            font-variant-numeric: tabular-nums;
        }
        
        .album-actions {
            position: absolute;
            right: 10px;
            top: 10px;
        }
        
        .delete-album {
            background: rgba(255, 0, 0, 0.8);
            color: white;
            border: none;
            border-radius: 50%;
            width: 36px;
            height: 36px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: background 0.2s;
        }
        
        .song-title {
            flex-grow: 1;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .drag-placeholder {
          height: 2px;
          background-color: var(--text-color);
          transition: all 0.2s ease;
        }
        
        @keyframes pulse {
          0% { box-shadow: 0 0 0 0 rgba(255, 255, 255, 0.4); }
          70% { box-shadow: 0 0 0 10px rgba(255, 255, 255, 0); }
          100% { box-shadow: 0 0 0 0 rgba(255, 255, 255, 0); }
        }
        
        .music-item.dragging, .album-section.dragging, .queue-item.dragging {
          animation: pulse 1.5s infinite;
        }
        
        .background-container {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            overflow: hidden;
            z-index: -9999;
        }
                        
        #distortion-container {
            position: fixed;
            inset: 0;
            overflow: hidden;
            z-index: -9998;
            filter: blur(50px) saturate(2) brightness(0.6);
            scale: 1.3;
            opacity: 1;
        }

        body.light-theme #distortion-container {
            opacity: 0.6; /* 60% opacity for light theme */
            filter: blur(50px) saturate(2) brightness(1);
        }

        @media (min-width: 2000px) {
            #distortion-container {
                filter: blur(75px) saturate(2) brightness(0.6);
            }

            body.light-theme #distortion-container {
                filter: blur(75px) saturate(2) brightness(1);
            }
        }
        
        #distortionCanvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
        }
        
        @keyframes rotate {
            from {
                transform: scale(1.42) rotate(0deg);
            }
            to {
                transform: scale(1.42) rotate(360deg);
            }
        }
        
        .search-container {
            position: relative;
        }
        
        .search-input {
            width: 100%;
            padding: 10px 15px 10px 40px;
            border-radius: 25px;
            border: 1px solid var(--glass-border);
            background: var(--search-background);
            color: var(--text-color);
            backdrop-filter: blur(5px) saturate(2) var(--edge-refraction-filter);
            font-size: 14px;
            outline: none;
            transition: border-color 0.2s;
            flex-grow: 1;
        }
        
        .search-input:focus {
            border-color: var(--modal-background);
        }
        
        .search-input::placeholder {
            color: var(--secondary-text-color);
        }
        
        .search-icon {
            font-size: 20px;
            position: absolute;
            left: 12px;
            top: 50%;
            transform: translateY(-50%);
            color: var(--secondary-text-color);
            pointer-events: none;
            z-index: 1;
        }

        .filter-container {
            display: flex;
            gap: 6px;
            max-width: 340px;
            justify-content: center;
        }
        
        .filter-btn, .filter-btn-sc {
            flex: 1;
            padding: 8px 10px;
            border-radius: 20px;
            border: 1px solid var(--glass-border);
            background: var(--search-background);
            color: var(--secondary-text-color);
            font-size: 14px;
            cursor: pointer;
            transition: all 0.2s ease;
            backdrop-filter: blur(5px) saturate(2) var(--edge-refraction-filter);
        }
        
        .filter-btn.active, .filter-btn-sc.active {
            background: var(--secondary-text-color);
            color: var(--background-color);
        }

        .filter-separator {
            width: 3px;
            background: var(--search-background);
            border-radius: 5px;
            margin: 10px 5px;
        }
        
        #shuffleBtn, #repeatBtn {
            background: transparent;
            border: none;
            color: var(--text-color);
            width: 50px;
            height: 50px;
            border-radius: 50%;
            cursor: pointer;
            font-size: 1.2rem;
            transition: all 0.3s ease;
            display: flex;
            justify-content: center;
            align-items: center;
            line-height: 0;
            backdrop-filter: none;
            border: 1px solid transparent;
        }
        
        #shuffleBtn.active, #repeatBtn.active {
            backdrop-filter: blur(5px) saturate(2) var(--edge-refraction-filter);
            background: var(--search-background);
            border: 1px solid var(--glass-border);
        }
                
        .material-symbols-rounded {
          font-variation-settings:
          'FILL' 1,
          'wght' 700,
          'GRAD' 0,
          'opsz' 24;
          vertical-align: middle;
        }
        
        .no-results {
            color: var(--text-color);
            text-align: center;
            padding: 20px;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 10px;
        }
        
        .no-results .material-symbols-rounded {
            font-size: 48px;
        }
        
        .no-results p {
            font-size: 14px;
        }
        
        /* For all clickable elements */
        [onclick], 
        button, 
        a, 
        input[type="button"], 
        input[type="submit"],
        .clickable {
          cursor: pointer;
          transform: scale(1);
          transition: all 0.15s cubic-bezier(0.2, 0, 0.38, 0.9);
        }
        
        /* Active effect (when clicking down) */
        [onclick]:active, 
        button:active, 
        a:active, 
        input[type="button"]:active, 
        input[type="submit"]:active,
        .clickable:active {
          transform: scale(0.96);
          transition: all 0.1s cubic-bezier(0.2, 0, 0.38, 0.9);
          filter: brightness(1.5);
        }

        #soundcloudToggle, #lrclibToggle {
            appearance: none;
            width: 50px;
            height: 32px;
            background-color: rgba(0, 0, 0, 0.1);
            border-radius: 16px;
            position: relative;
            cursor: pointer;
            transition: background-color 0.3s;
            border: 1px solid var(--glass-border);
            cursor: pointer;
        }
        
        #soundcloudToggle::before, #lrclibToggle::before {
            content: '';
            position: absolute;
            width: 18px;
            height: 18px;
            background-color: var(--secondary-text-color);
            border-radius: 50%;
            top: 50%;
            left: 6px;
            transform: translateY(-50%);
            transition: transform 0.3s, background-color 0.3s, width 0.3s, height 0.3s, left 0.3s, right 0.3s;
            border: 1px solid var(--glass-border);
        }
        
        #soundcloudToggle:checked, #lrclibToggle:checked {
            background-color: var(--secondary-text-color);
        }
        
        #soundcloudToggle:checked::before, #lrclibToggle:checked::before {
            width: 22px;
            height: 22px;
            background-color: var(--background-color);
            left: 21px;
            transform: translateY(-50%);
        }

        @media (min-width: 560px) {
            .controls-container {
                position: fixed;
                bottom: 30px;
                right: 30px;
            }

            #lyrics-queue-panel {
                transform-origin: right bottom !important;
            }
        }
        
        @media (max-width: 800px) {
            .player-controls {
                gap: 15px;
            }
        }

        @media (min-width: 600px) {
            .drawer {
                left: 5vw !important;
                width: 90vw !important;
                border: 1px solid var(--glass-border);
            }
        }

        @media (min-width: 800px) {
            .drawer {
                left: 15vw !important;
                width: 70vw !important;
                border: 1px solid var(--glass-border);
            }
        }

        @media (min-width: 1000px) {
            .drawer {
                left: 25vw !important;
                width: 50vw !important;
                border: 1px solid var(--glass-border);
            }
        }

        @media (max-width: 560px) {
            #now-playing-view {
                padding: 0 10px 0 10px;
            }

            .music-info, .progress-container, .player-controls {
                padding: 0 10px !important;
            }
            
            .now-playing-wrapper {
                gap: 4vh !important;
            }

            #shuffleBtn, #repeatBtn {
                width: 30px;
                height: 30px;
                border-radius: 10px;
            }
            
            .drawer {
                height: calc(100% - 80px); /* Full height minus top toolbar */
            }

            .player-controls {
                margin-bottom: 110px;
            }

            @media (max-height: 900px) {
                .now-playing-wrapper {
                    gap: 2vh !important;
                }

                .player-controls {
                    margin-bottom: 95px;
                }
            }
        }

        @media (max-width: 590px) {
            .toolbar {
                justify-content: flex-start;
            }

            .tab-btn {
                font-size: 0;
                padding: 12px 11px 12px 20px;
            }

            .tab-btn.active {
                font-size: 0;
                padding: 12px 11px 12px 20px;
            }
        }
        
        /* When animations are disabled */
        .reduce-animations * {
            /* Disable all animations */
            animation: none !important;
        
            /* Disable all transitions except opacity */
            transition: opacity 0.3s ease !important;
            transition-property: opacity !important;
        }
        
        /* Special handling for clickable elements */
        .reduce-animations [onclick],
        .reduce-animations button,
        .reduce-animations a,
        .reduce-animations input[type="button"],
        .reduce-animations input[type="submit"],
        .reduce-animations .clickable {
            /* Keep initial state but remove transition */
            transform: scale(1) !important;
            transition: opacity 0.3s ease !important;
        }
        
        /* Keep active state functional but without animation */
        .reduce-animations [onclick]:active,
        .reduce-animations button:active,
        .reduce-animations a:active,
        .reduce-animations input[type="button"]:active,
        .reduce-animations input[type="submit"]:active,
        .reduce-animations .clickable:active {
            /* Apply scale instantly without transition */
            transform: scale(0.98) !important;
            transition: none !important;
            filter: brightness(1.5) !important;
        }
        
        /* Adjust for background image with light/dark theme */
        body[style*="background-image"] .music-title,
        body[style*="background-image"] .music-artist,
        body[style*="background-image"] .music-album,
        body[style*="background-image"] .time-info {
            text-shadow: 0 0 10px rgba(0, 0, 0, 0.5);
        }
        
        body.light-theme[style*="background-image"] .music-title,
        body.light-theme[style*="background-image"] .music-artist,
        body.light-theme[style*="background-image"] .music-album,
        body.light-theme[style*="background-image"] .time-info {
            text-shadow: 0 0 10px rgba(255, 255, 255, 0.5);
        }

        /* Lyrics and Queue styles */
        .sidebar-back-btn {
            background: var(--search-background);
            border: 1px solid var(--glass-border);
            backdrop-filter: blur(5px) saturate(2) var(--edge-refraction-filter);
            color: var(--text-color);
            cursor: pointer;
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 14px;
            padding: 8px 15px;
            border-radius: 20px;
            width: fit-content;
        }

        .lyrics-container {
            height: 100%;
            overflow-y: auto;
            scroll-behavior: smooth;
            scroll-padding-top: 30vh;
            padding-bottom: 70vh; /* Ensures last line can also scroll to the sweet spot */
        }

        .lyrics-container p {
            white-space: pre-wrap;
            transition: all 0.4s ease-out; /* Smooth transition for filter and opacity */
            margin: 18px 0;
            padding: 0 10px;
            border-radius: 14px;
            cursor: pointer;
            font-size: 1.5rem;
            font-weight: 600;
            line-height: 1.4; /* Improves readability */
            font-family: 'Open Runde';
        }

        .lyrics-container p.active {
            background: var(--search-background);
            scale: 0.96;
        }
 
        .queue-item .song-info {
            display: flex;
            align-items: center;
            width: 100%;
            gap: 8px;
        }
        
        .queue-item .song-title {
            flex-grow: 1;
        }
        
        .queue-item .song-artist-queue {
            color: var(--secondary-text-color);
            font-size: 0.9em;
            flex-shrink: 0;
            max-width: 100px;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }
        
        .remove-from-queue-btn {
            background: none;
            border: none;
            color: var(--secondary-text-color);
            cursor: pointer;
            padding: 10px 5px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            flex-shrink: 0;
            opacity: 0.5;
        }
        
        .queue-list-container {
            display: flex;
            flex-direction: column;
            gap: 10px; /* This adds the required space between queue items */
        }

        .more-options-menu {
            position: absolute;
            background-color: var(--search-background);
            border-radius: 25px;
            padding: 8px;
            backdrop-filter: blur(5px) saturate(2) var(--edge-refraction-filter);
            border: 1px solid var(--glass-border);
            z-index: 100;
            width: 200px;
            box-shadow: 0 4px 20px rgba(0,0,0,0.2);
            opacity: 0;
            transform: translateY(10px) scale(0.95) scaleY(0.9);
            pointer-events: none;
            transition: opacity 0.2s ease, transform 0.2s ease;
            transform-origin: bottom;
        }

        .more-options-menu.visible {
            opacity: 1;
            transform: translateY(0) scale(1);
            pointer-events: auto;
        }

        .context-menu {
            position: absolute;
            background-color: var(--search-background);
            border-radius: 25px;
            padding: 8px;
            backdrop-filter: blur(5px) saturate(2) var(--edge-refraction-filter);
            border: 1px solid var(--glass-border);
            z-index: 10001;
            width: auto;
            box-shadow: 0 4px 20px rgba(0,0,0,0.2);
            opacity: 0;
            transform: translateY(10px) scale(0.95) scaleY(0.9);
            pointer-events: none;
            transition: opacity 0.2s ease, transform 0.2s ease;
            transform-origin: top;
            margin: 10px;
        }

        .context-menu.visible {
            opacity: 1;
            transform: translateY(0) scale(1);
            pointer-events: auto;
        }

        .menu-item {
            display: flex;
            align-items: center;
            gap: 12px;
            padding: 10px;
            border-radius: 8px;
            cursor: pointer;
            transition: background-color 0.2s ease;
        }

        .menu-item .material-symbols-rounded {
            font-size: 20px;
        }

        .menu-separator {
            height: 1px;
            background-color: var(--glass-border);
            margin: 8px 0;
        }

        .view-controls {
            display: flex;
            gap: 10px;
            align-items: center;
        }

        .now-playing-wrapper {
            flex-grow: 1;
            display: flex;
            flex-direction: column;
            gap: 2vh;
            justify-content: center;
            align-items: center;
            height: 100vh;
            width: 100%;
            max-width: 100vw;
            box-sizing: border-box;
            padding: 5px;
        }

        .player-column {
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            gap: 2vh;
            max-width: 500px;
            transition: max-width 0.4s ease;
        }
        
        #lyrics-queue-panel {
            height: 100%;
            max-height: 100vh;
            flex-shrink: 0;
            padding: 130px 5px 150px 20px;
            display: none;
            flex-direction: column;
            gap: 15px;
            opacity: 0;
            transform: translateX(20px);
            transition: all 0.3s cubic-bezier(.3,1.2,.64,1);
            pointer-events: none;
            overflow: auto;
            transform: translateX(20px) scale(0.9) scaleX(0.9);
            z-index: 5;
            width: 50%;
            transform-origin: right;
            filter: blur(1px);
            align-items: flex-start;
        }
        
        #lyrics-queue-panel.visible {
            display: flex;
            opacity: 1;
            transform: translateX(0);
            pointer-events: auto;
            filter: none;
        }

        @media (min-width: 981px) {
            .lyrics-container {
                width: 100%;
                max-width: 500px;
            }

            .now-queue {
                width: 100%;
                max-width: 500px;
            }
        }

        @media (max-width: 980px) {
            #lyrics-queue-panel {
                width: 450px;
                height: calc(100vh - 160px);
                background-color: var(--search-background);
                border: 1px solid var(--glass-border);
                box-shadow: 0 0 50px rgba(0, 0, 0, 0.2);
                border-radius: 25px;
                backdrop-filter: blur(10px) saturate(2) var(--edge-refraction-filter);
                flex-shrink: 0;
                padding: 20px;
                display: flex;
                flex-direction: column;
                gap: 15px;
                opacity: 0;
                transform: translateX(20px);
                transition: all 0.3s cubic-bezier(.3,1.2,.64,1);
                pointer-events: none;
                overflow: auto;
                position: absolute;
                top: 50%;
                transform: translateY(-50%) scale(0.9) scaleY(0.9);
                z-index: 5;
                width: 100%;
                max-width: -webkit-fill-available;
                transform-origin: bottom;
                filter: blur(1px);
                margin: 0 2vw;
                align-items: center;
            }
            
            #lyrics-queue-panel.visible {
                opacity: 1;
                transform: translateY(-50%);
                pointer-events: auto;
                filter: none;
            }

            .lyrics-container {
                width: 100%;
                max-width: none;
            }

            .now-queue {
                width: 100%;
                max-width: none;
            }
        }

        /* --- Grid View Styles --- */
        .music-list.grid-view {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(140px, 1fr));
            gap: 15px;
            align-content: start;
        }

        .music-list.grid-view .music-item {
            height: max-content;
        }

        .music-list.grid-view .album-section {
            padding: 0;
            border-top: none; /* No dividers in grid view */
            display: flex;
            flex-direction: column;
            cursor: pointer; /* Albums are clickable in grid view */
        }
        
        .music-list.grid-view .album-header {
            margin-bottom: 8px;
            flex-direction: column;
            gap: 8px;
            cursor: default; /* No dragging albums in grid view */
        }

        .music-list.grid-view .album-thumbnail {
            width: 100%;
            height: auto;
            aspect-ratio: 1 / 1;
        }

        .music-list.grid-view .album-info {
            width: 100%;
            text-align: left;
        }

        .music-list.grid-view .album-name {
            font-size: 1em;
            white-space: normal;
        }
        
        .music-list.grid-view .album-artist {
            font-size: 0.85em;
        }
        
        .music-list.grid-view .album-year {
            display: none; /* Hide year in grid view for space */
        }

        .music-list.grid-view .album-songs {
            display: none; /* Hide individual songs in album grid view */
        }

        /* Song-level grid view */
        .music-list.grid-view.songs-mode .music-item,
        .music-list.grid-view.artists-mode .music-item {
             padding: 8px;
             display: flex;
             flex-direction: column;
             gap: 8px;
             align-items: center;
             text-align: center;
        }
        .music-list.grid-view.songs-mode .song-info,
        .music-list.grid-view.artists-mode .song-info {
            flex-direction: column;
            gap: 8px;
        }
        .music-list.grid-view.songs-mode .album-thumbnail,
        .music-list.grid-view.artists-mode .album-thumbnail {
            width: 100%;
            height: auto;
            aspect-ratio: 1 / 1;
            margin-right: 0;
        }
        .music-list.grid-view.songs-mode .song-title,
        .music-list.grid-view.artists-mode div[style*="font-size: 1em;"] {
            white-space: normal;
        }

        .item-list {
            display: flex;
            flex-direction: column;
            gap: 5px;
            padding-bottom: 125px;
        }
        .album-section-list {
            border-radius: 12px;
            cursor: pointer;
            padding: 10px;
        }
        .album-header-list {
            display: flex;
            align-items: center;
            gap: 15px;
        }

        /* --- Song Context Menu Styles --- */
        .music-item .song-actions,
        .album-header .song-actions {
            position: absolute;
            right: 8px;
            top: 50%;
            transform: translateY(-50%);
            color: var(--secondary-text-color);
            background: none;
            border: none;
            border-radius: 50%;
            width: 28px;
            height: 28px;
            display: flex;
            align-items: center;
            justify-content: center;
            opacity: 0.5;
            transition: opacity 0.2s, background-color 0.2s;
            z-index: 5;
        }

        /* App Drawer Styles */
        .drawer {
            position: fixed;
            bottom: -100%; /* Initially hidden */
            left: 0;
            width: 100%;
            background-color: var(--search-background); 
            z-index: 1004;
            overflow: hidden;
            touch-action: none;
            user-select: none;
            backdrop-filter: blur(10px) saturate(2) var(--edge-refraction-filter);
            border-top: 1px solid var(--glass-border);
            border-radius: 25px 25px 0 0;
            transform-origin: bottom;
            will-change: transform, opacity, bottom;
            transition: all 0.3s cubic-bezier(.3,1.2,.64,1);
            max-height: calc(100% - 80px);
        }

        .drawer.open {
            bottom: 0;
        }

        .drawer-handle {
            width: 50px;
            height: 5px;
            background-color: var(--secondary-text-color);
            border-radius: 3px;
            position: absolute;
            top: 15px;
            left: 50%;
            transform: translateX(-50%);
            cursor: grab;
        }

        .drawer-content {
            max-height: calc(100vh - 150px);
            overflow-y: auto;
            user-select: none;
            padding: 20px 20px 0 20px;
        }
        
        .drawer-content::-webkit-scrollbar { width: 4px; }
        .drawer-content::-webkit-scrollbar-track { background: transparent; }
        .drawer-content::-webkit-scrollbar-thumb { background: var(--modal-transparent); border-radius: 4px; }
        
        .drawer-header {
            padding: 40px 20px 10px 20px;
            text-align: center;
        }
        #drawer-title { font-size: 1.5rem; }
        #drawer-subtitle { color: var(--secondary-text-color); }

        .highlight-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 20px;
            margin-bottom: 40px;
        }
        .highlight-card {
            background: linear-gradient(135deg, rgba(255,255,255,0.1), rgba(255,255,255,0));
            border: 1px solid var(--glass-border);
            border-radius: 25px;
            padding: 10px 15px 10px 12px;
            display: flex;
            align-items: center;
            gap: 15px;
            cursor: pointer;
            transition: all 0.3s cubic-bezier(.3,1.2,.64,1);
        }
        .highlight-card:active {
            transform: scale(0.96);
            transition: all 0.1s cubic-bezier(0.2, 0, 0.38, 0.9);
            filter: brightness(1.5);
        }
        .highlight-card img {
            width: 80px;
            height: 80px;
            border-radius: 12px;
            box-shadow: 0 0 0 1px var(--glass-border);
            flex-shrink: 0;
            transition: all 0.3s cubic-bezier(.3,1.2,.64,1);
        }
        .highlight-card-info {
            flex-grow: 1;
            min-width: 0;
            display: flex;
            flex-direction: column;
            justify-content: center;
            gap: 4px;
            transition: all 0.3s cubic-bezier(.3,1.2,.64,1);
        }
        .highlight-card-label {
            font-size: 12px;
            color: var(--secondary-text-color);
        }
        .highlight-card-title {
            font-size: 1.2rem;
            font-weight: 600;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            font-family: 'Open Runde';
        }
        .highlight-card-subtitle {
            color: var(--secondary-text-color);
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }
        .highlight-card-play {
            margin-left: auto;
            font-size: 36px;
            transition: all 0.3s cubic-bezier(.3,1.2,.64,1);
        }
        
        .song-item-actions {
            background: none;
            border: none;
            color: var(--secondary-text-color);
            margin-left: auto;
            padding: 5px;
            border-radius: 50%;
            cursor: pointer;
        }

        .loading-message {
            position: absolute;
            left: 50%;
            top: 50%;
        }

        #autoplayToggle {
            appearance: none;
            width: 38px;
            height: 24px;
            background-color: rgba(0, 0, 0, 0.1);
            border-radius: 12px;
            position: relative;
            cursor: pointer;
            transition: background-color 0.3s;
            border: 1px solid var(--glass-border);
        }
        
        #autoplayToggle::before {
            content: '';
            position: absolute;
            width: 15px;
            height: 15px;
            background-color: var(--secondary-text-color);
            border-radius: 50%;
            top: 50%;
            left: 3.5px;
            transform: translateY(-50%);
            transition: all 0.3s cubic-bezier(.3,1.2,.64,1);
        }
        
        #autoplayToggle:checked {
            background-color: var(--secondary-text-color);
        }
        
        #autoplayToggle:checked::before {
            background-color: var(--background-color);
            left: 16px;
            width: 18px;
            height: 18px;
        }

        #drawer-delete-playlist-btn {
            background: none;
            border: none;
            cursor: pointer;
            padding: 5px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: opacity 0.2s, background-color 0.2s;
            color: var(--text-color);
        }
    </style>
</head>
<body data-app-name="Music">
    <svg style="position: absolute; width: 0; height: 0;">
        <filter id="albumArtDistortion">
            <feTurbulence 
                id="turbulence"
                type="turbulence" 
                baseFrequency="0.01 0.02" 
                numOctaves="1" 
                seed="0"
            />
            <feGaussianBlur stdDeviation="30" result="blurredTurbulence"/>
            <feDisplacementMap 
                id="displacement"
                in="SourceGraphic" 
                in2="blurredTurbulence" 
                scale="0" 
                xChannelSelector="R" 
                yChannelSelector="G"
            />
        </filter>
    </svg>

    <svg style="display: none">
        <filter id="edge-refraction-only" color-interpolation-filters="linearRGB">
            <!-- Part 1: Create the turbulence that will only be used at the edges -->
            <feTurbulence type="fractalNoise" baseFrequency="0.01 0.04" numOctaves="2" result="turbulence"/>
        
            <!-- Part 2: Create a mask that is only opaque at the edges -->
            <feMorphology in="SourceGraphic" operator="erode" radius="4" result="eroded"/>
            <feComposite in="SourceGraphic" in2="eroded" operator="out" result="border_mask"/>
            <feComposite in="turbulence" in2="border_mask" operator="in" result="edge_turbulence"/>
        
            <!-- Part 3: Create the final displacement map -->
            <!-- First, create the 50% gray neutral background -->
            <feFlood flood-color="#808080" result="neutral_base"/>
            
            <!-- Next, use feMerge to explicitly stack the edge turbulence ON TOP of the gray base.
                 This is the key step that prevents the center from shifting. -->
            <feMerge result="displacement_map">
                <feMergeNode in="neutral_base"/>
                <feMergeNode in="edge_turbulence"/>
            </feMerge>
        
            <!-- Part 4: Apply the final, perfectly centered displacement map -->
            <feDisplacementMap in="SourceGraphic" in2="displacement_map" scale="40" xChannelSelector="R" yChannelSelector="G"/>
        </filter>
    </svg>

    <div class="toolbar">
        <button class="tab-btn active" data-view="home">
            <span class="material-symbols-rounded">home</span>
            Home
        </button>
        <button class="tab-btn" data-view="library">
            <span class="material-symbols-rounded">newsstand</span>
            Library
        </button>
        <button class="tab-btn" data-view="soundcloud" id="soundcloud-tab" style="display: none;">
            <span class="material-symbols-rounded">podcasts</span>
            New
        </button>
        <button class="tab-btn" data-view="search">
            <span class="material-symbols-rounded">search</span>
            Search
        </button>
    </div>

    <div id="home-view" class="view-container">
        <!-- Home page content will be rendered here -->
        <div class="loading-message"><svg width="24" height="24" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg" style="color: var(--text-color);"><style>.spinner_V8m1{transform-origin:center;animation:spinner_zKoa 2s linear infinite}.spinner_V8m1 circle{stroke-linecap:round;animation:spinner_YpZS 1.5s ease-in-out infinite}@keyframes spinner_zKoa{100%{transform:rotate(360deg)}}@keyframes spinner_YpZS{0%{stroke-dasharray:0 150;stroke-dashoffset:0}47.5%{stroke-dasharray:42 150;stroke-dashoffset:-16}95%,100%{stroke-dasharray:42 150;stroke-dashoffset:-59}}</style><g class="spinner_V8m1"><circle cx="12" cy="12" r="9.5" fill="none" stroke-width="3"></circle></g></svg></div>
    </div>
    <div id="library-view" class="view-container" style="display: none;">
        <div class="page-content-wrapper">
            <div class="library-controls">
                <div class="filter-container">
                    <button class="filter-btn active" data-filter="albums" style="border-radius: 25px 10px 10px 25px;">Albums</button>
                    <button class="filter-btn" data-filter="artists">Artists</button>
                    <button class="filter-btn" data-filter="songs">Songs</button>
                    <button class="filter-btn" data-filter="playlists" style="border-radius: 10px 25px 25px 10px;">Playlists</button>
                </div>
                <div class="view-controls">
                    <button id="sortBtn" class="library-action-btn"><span class="material-symbols-rounded">history</span><span id="sort-mode-display"></span></button>
                </div>
                 <div class="library-actions">
                    <button class="library-action-btn" id="uploadBtn"><span class="material-symbols-rounded">add</span></button>
                    <button class="library-action-btn" id="manageFoldersBtn"><span class="material-symbols-rounded">folder_managed</span></button>
                </div>
            </div>
            <div id="library-grid" class="item-grid" style="padding-bottom: 240px;">
                <!-- Library content will be rendered here -->
            </div>
             <input type="file" accept="audio/*" style="display: none" id="musicUpload" multiple webkitdirectory>
        </div>
    </div>
    <div id="soundcloud-view" class="view-container" style="display: none;">
        <div class="page-content-wrapper">
            <div class="library-controls" id="soundcloud-controls">
                <div class="filter-container" id="soundcloud-filter-container" style="max-width: 246px;">
                    <button class="filter-btn-sc" data-filter="albums" style="border-radius: 25px 10px 10px 25px;">Albums</button>
                    <button class="filter-btn-sc" data-filter="artists">Artists</button>
                    <button class="filter-btn-sc active" data-filter="tracks" style="border-radius: 10px 25px 25px 10px;">Songs</button>
                </div>
                <div class="search-container" id="soundcloud-offline-search-container" style="display: none; max-width: 246px; margin: 0px;">
                    <span class="material-symbols-rounded search-icon">search</span>
                    <input type="text" id="soundcloudOfflineSearchInput" placeholder="Search your cached songs" class="library-search-input">
                </div>
                <div class="library-actions">
                    <button class="library-action-btn" id="soundcloudOfflineToggle">
                        <span class="material-symbols-rounded">history</span>
                    </button>
                </div>
            </div>

            <div class="search-container" id="soundcloud-search-container" style="position: absolute; width: 90%; z-index: 1; left: 50%; transform: translateX(-50%);">
                <span class="material-symbols-rounded search-icon" style="padding-left: 2px;">search</span>
                <input type="text" id="soundcloudSearchInput" placeholder="Search SoundCloud" class="library-search-input" style="box-shadow: 0 0 15px rgba(0, 0, 0, 0.05); padding: 12px 17px 12px 42px;">
            </div>
            
            <div id="soundcloud-results-grid" class="item-grid" style="padding-top: 60px; padding-bottom: 240px;">
                <!-- SoundCloud search/offline results will be rendered here -->
            </div>
        </div>
    </div>
    <div id="search-view" class="view-container" style="display: none;">
        <div class="page-content-wrapper">
            <div class="search-container" style="position: absolute; width: 90%; z-index: 1; left: 50%; transform: translateX(-50%);">
                <span class="material-symbols-rounded search-icon" style="padding-left: 2px;">search</span>
                <input type="text" id="searchInput" placeholder="Search your Library" class="library-search-input" style="box-shadow: 0 0 15px rgba(0, 0, 0, 0.05); padding: 12px 17px 12px 42px;">
            </div>
            <div id="search-results-grid" class="item-grid" style="padding-top: 60px;">
                <!-- Search results will be rendered here -->
            </div>
        </div>
    </div>
    <div id="now-playing-view" class="view-container" style="display: none;">
        <div id="distortion-container">
            <canvas id="distortionCanvas"></canvas>
        </div>
        <div class="now-playing-wrapper">
            <div class="album-art">
                <img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAfQAAAH0CAYAAADL1t+KAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsMAAA7DAcdvqGQAAAPgSURBVHhe7cEBAQAAAIIg/69uSEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACcqAFFFQAB8Dl/nAAAAABJRU5ErkJggg==" alt="Album Art" id="albumArtImg">
            </div>
            <div class="music-info">
                <div class="music-text">
                    <div class="music-title">No song playing</div>
                    <div class="music-artist">&nbsp;</div>
                </div>
                <canvas id="visualizerCanvas"></canvas>
            </div>
            <div class="progress-container">
                <div class="progress-bar">
                    <div class="progress"></div>
                </div>
                <div class="time-info">
                    <span id="currentTime">&nbsp;</span>
                    <span id="duration">&nbsp;</span>
                </div>
            </div>
            <div class="player-controls">
                <button class="control-btn" id="shuffleBtn">
                    <span class="material-symbols-rounded">shuffle</span>
                </button>
                <button class="control-btn" id="prevBtn">
                    <span class="material-symbols-rounded">skip_previous</span>
                </button>
                <button class="control-btn play-pause" id="playPauseBtn">
                    <span class="material-symbols-rounded" id="playPauseIcon">play_arrow</span>
                </button>
                <button class="control-btn" id="nextBtn">
                    <span class="material-symbols-rounded">skip_next</span>
                </button>
                <button class="control-btn" id="repeatBtn">
                    <span class="material-symbols-rounded">repeat</span>
                </button>
            </div>
            <div class="controls-container">
                <button class="lyrics-button">
                    <span class="material-symbols-rounded" style="font-size: 18px;">tooltip_2</span>
                </button>
                <button class="queue-button">
                    <span class="material-symbols-rounded" style="font-size: 18px;">format_list_bulleted</span>
                </button>
                <button class="more-button">
                    <span class="material-symbols-rounded" style="font-size: 18px;">more_horiz</span>
                </button>
                <div class="volume-control">
                    <span class="material-symbols-rounded" id="volumeIcon">volume_up</span>
                    <input type="range" class="volume-slider" min="0" max="100" value="100">
                </div>
            </div>
            <div id="moreOptionsMenu" class="more-options-menu" style="right: 30px; bottom: 90px;">
                <div class="menu-item" id="menuFullscreenBtn">
                    <span class="material-symbols-rounded">fullscreen</span>
                    <span>Fullscreen</span>
                </div>
                <div class="menu-separator"></div>
                <div class="menu-item" id="menuEditMetadata">
                    <span class="material-symbols-rounded">edit</span>
                    <span>Edit Info</span>
                </div>
                <div class="menu-item" id="menuSaveToLibrary">
                    <span class="material-symbols-rounded">save</span>
                    <span>Save to Library</span>
                </div>
                <div class="menu-item" id="menuAddToPlaylist">
                    <span class="material-symbols-rounded">playlist_add</span>
                    <span>Add to Playlist</span>
                </div>
                <div class="menu-separator"></div>
                <div class="menu-item" id="menuCrossfade">
                    <span class="material-symbols-rounded">swap_horiz</span>
                    <span>Crossfade</span>
                    <span id="crossfadeStatus" style="margin-left: auto; font-size: 0.8em; color: var(--secondary-text-color);">Off</span>
                </div>
                <div class="menu-item" id="menuEqualizer">
                    <span class="material-symbols-rounded">equalizer</span>
                    <span>Equalizer</span>
                </div>
                <div class="menu-item" id="menuSleepTimer">
                    <span class="material-symbols-rounded">timer</span>
                    <span>Sleep Timer</span>
                </div>
                <div class="menu-separator"></div>
                <div class="menu-item" id="menuDeleteSong" style="color: #ff6b6b;">
                    <span class="material-symbols-rounded">delete</span>
                    <span>Delete Song</span>
                </div>
            </div>
        </div>
        <div id="lyrics-queue-panel" class="hidden">
            <!-- Lyrics or Queue content will be rendered here by JS -->
        </div>
    </div>

    <div id="bottom-miniplayer" class="hidden">
        <div class="miniplayer-progress"></div>
        <img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAfQAAAH0CAYAAADL1t+KAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsMAAA7DAcdvqGQAAAPgSURBVHhe7cEBAQAAAIIg/69uSEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACcqAFFFQAB8Dl/nAAAAABJRU5ErkJggg==" alt="mini-art" id="miniplayer-art">
        <div class="miniplayer-info">
            <div id="miniplayer-title">No song playing</div>
            <div id="miniplayer-artist"></div>
        </div>
        <div class="miniplayer-controls">
            <button id="miniplayer-prev-btn" class="mini-control-btn"><span class="material-symbols-rounded">skip_previous</span></button>
            <button id="miniplayer-play-btn" class="mini-control-btn"><span class="material-symbols-rounded">play_arrow</span></button>
            <button id="miniplayer-next-btn" class="mini-control-btn"><span class="material-symbols-rounded">skip_next</span></button>
        </div>
    </div>

    <!-- Manage Folders Modal -->
    <div id="manageFoldersModal" class="modal-overlay">
        <div style="background: var(--modal-background); padding: 25px; border-radius: 40px; width: 90%; max-width: 450px; backdrop-filter: blur(10px) saturate(2) var(--edge-refraction-filter); border: 1px solid var(--glass-border);">
            <h2 style="margin-bottom: 20px;">Connected Folders</h2>
            <div id="folderList" style="max-height: 250px; overflow-y: auto; margin-bottom: 15px;">
                <!-- Folder list will be populated here -->
            </div>
            
            <div class="menu-separator"></div>
            
            <h2 style="margin-top: 20px; margin-bottom: 15px;">Integrations</h2>
            If you enable a third-party service, you agree to the Terms of Service and other polices of that service.
            <div style="display: flex; flex-direction: column; gap: 15px; padding-top: 15px;">
                <div style="display: flex; align-items: center; justify-content: space-between;">
                    <label for="soundcloudToggle">Enable SoundCloud Streaming</label>
                    <input type="checkbox" id="soundcloudToggle">
                </div>
                <input type="text" id="soundcloudClientId" placeholder="SoundCloud Client ID" class="search-input" style="padding-left: 15px;">
                <small>You will need to disable CORS to use SoundCloud streaming. A browser extension may be required.</small>

                <div style="display: flex; align-items: center; justify-content: space-between;">
                    <label for="lrclibToggle">Search LRCLIB for missing lyrics</label>
                    <input type="checkbox" id="lrclibToggle">
                </div>
            </div>

            <div style="display: flex; justify-content: flex-end; margin-top: 25px; gap: 10px;">
                <button id="saveIntegrations" class="filter-btn">Save</button>
                <button id="closeFoldersModal" class="filter-btn active">Close</button>
            </div>
        </div>
    </div>

    <!-- Edit Song Modal -->
    <div id="editModal" class="modal-overlay">
        <div id="editModalContent" style="background: var(--modal-background); padding: 25px; border-radius: 40px; width: 90%; max-width: 400px; backdrop-filter: blur(10px) saturate(2) var(--edge-refraction-filter); border: 1px solid var(--glass-border);">
            <h2 style="margin-bottom: 20px;">Edit Song Info</h2>
            <input type="hidden" id="editSongId">
            <div style="display: flex; flex-direction: column; gap: 15px;">
                <input type="text" id="editTitle" placeholder="Title" class="search-input" style="padding-left: 15px;">
                <input type="text" id="editArtist" placeholder="Artist" class="search-input" style="padding-left: 15px;">
                <input type="text" id="editAlbum" placeholder="Album" class="search-input" style="padding-left: 15px;">
            </div>
            <div style="display: flex; justify-content: flex-end; gap: 10px; margin-top: 25px;">
                <button id="cancelEdit" class="filter-btn">Cancel</button>
                <button id="saveEdit" class="filter-btn active">Save</button>
            </div>
        </div>
    </div>

    <!-- Manual Lyrics Search Modal -->
    <div id="manualLyricsSearchModal" class="modal-overlay">
        <div style="background: var(--modal-background); padding: 25px; border-radius: 40px; width: 90%; max-width: 450px; backdrop-filter: blur(10px) saturate(2) var(--edge-refraction-filter); border: 1px solid var(--glass-border);">
            <h2 style="margin-bottom: 20px;">Lyrics Search</h2>
            <div style="display: flex; gap: 10px; margin-bottom: 15px;">
                <input type="text" id="manualLyricsSearchInput" placeholder="Artist - Title" class="search-input" style="padding-left: 15px;">
                <button id="manualLyricsSearchBtn" class="filter-btn active" style="flex-shrink: 0;"><span class="material-symbols-rounded" style="font-size: 18px;">arrow_forward</span></button>
            </div>
            <div id="manualLyricsResults" style="max-height: 250px; overflow-y: auto;">
                <!-- Search results will be populated here -->
            </div>
            <div style="display: flex; justify-content: flex-end; margin-top: 25px;">
                <button id="closeManualLyricsModal" class="filter-btn">Close</button>
            </div>
        </div>
    </div>

    <!-- Sleep Timer Modal -->
    <div id="sleepTimerModal" class="modal-overlay">
        <div style="background: var(--modal-background); padding: 25px; border-radius: 40px; width: 90%; max-width: 300px; backdrop-filter: blur(10px) saturate(2) var(--edge-refraction-filter); border: 1px solid var(--glass-border);">
            <h2 style="margin-bottom: 20px;">Sleep Timer</h2>
            <p style="margin-bottom: 15px; color: var(--secondary-text-color);">Playback will stop after:</p>
            <div style="display: flex; flex-direction: column; gap: 10px;">
                <button class="filter-btn" onclick="setSleepTimer(15)">15 Minutes</button>
                <button class="filter-btn" onclick="setSleepTimer(30)">30 Minutes</button>
                <button class="filter-btn" onclick="setSleepTimer(60)">1 Hour</button>
            </div>
            <div class="menu-separator"></div>
            <button id="cancelSleepTimer" class="filter-btn active" style="width: 100%;">Cancel Timer</button>
        </div>
    </div>

    <!-- Playlist Modal -->
    <div id="playlistModal" class="modal-overlay">
         <div style="background: var(--modal-background); padding: 25px; border-radius: 40px; width: 90%; max-width: 400px; backdrop-filter: blur(10px) saturate(2) var(--edge-refraction-filter); border: 1px solid var(--glass-border);">
            <h2 style="margin-bottom: 20px;">Add to playlist</h2>
            <div id="playlistList" style="max-height: 200px; overflow-y: auto; margin-bottom: 15px;"></div>
            <div class="menu-separator"></div>
            <input type="text" id="newPlaylistName" placeholder="Create new playlist" class="search-input" style="padding-left: 15px; margin-bottom: 10px;">
            <div style="display: flex; justify-content: flex-end; gap: 10px;">
                <button id="closePlaylistModal" class="filter-btn">Cancel</button>
                <button id="createPlaylistBtn" class="filter-btn active">Create & Add</button>
            </div>
        </div>
    </div>
    
    <!-- Equalizer Modal -->
    <div id="equalizerModal" class="modal-overlay">
        <div style="background: var(--modal-background); padding: 25px; border-radius: 40px; width: 90%; max-width: 400px; backdrop-filter: blur(10px) saturate(2) var(--edge-refraction-filter); border: 1px solid var(--glass-border);">
            <h2 style="margin-bottom: 20px;">Equalizer</h2>
            
            <div id="eq-bands-container" style="display: flex; flex-direction: column; gap: 20px; margin-bottom: 25px;">
                <!-- Bass Slider -->
                <div class="eq-band">
                    <label for="bass-slider" style="display: block; margin-bottom: 5px; color: var(--secondary-text-color);">Bass</label>
                    <input type="range" id="bass-slider" class="volume-slider" min="-10" max="10" value="0" step="1">
                </div>
                <!-- Mid Slider -->
                <div class="eq-band">
                    <label for="mid-slider" style="display: block; margin-bottom: 5px; color: var(--secondary-text-color);">Mid</label>
                    <input type="range" id="mid-slider" class="volume-slider" min="-10" max="10" value="0" step="1">
                </div>
                <!-- Treble Slider -->
                <div class="eq-band">
                    <label for="treble-slider" style="display: block; margin-bottom: 5px; color: var(--secondary-text-color);">Treble</label>
                    <input type="range" id="treble-slider" class="volume-slider" min="-10" max="10" value="0" step="1">
                </div>
            </div>

            <div style="display: flex; justify-content: space-between; gap: 10px;">
                <button id="resetEq" class="filter-btn">Reset</button>
                <button id="closeEqModal" class="filter-btn active">Close</button>
            </div>
        </div>
    </div>

    <div id="songContextMenu" class="context-menu">
        <div class="menu-item" id="menuAddToQueueNext">
            <span class="material-symbols-rounded">playlist_play</span>
            <span>Play Next</span>
        </div>
        <div class="menu-item" id="menuAddToQueueLast">
            <span class="material-symbols-rounded">playlist_add</span>
            <span>Add to Queue</span>
        </div>
    </div>

    <div id="drawer" class="drawer">
        <div class="drawer-handle"></div>
        <div class="drawer-header">
            <h2 id="drawer-title"></h2>
            <p id="drawer-subtitle"></p>
        </div>
        <div class="drawer-content" id="drawer-content">
            <!-- Content will be injected here -->
        </div>
    </div>
    <div id="drawer-overlay" class="modal-overlay"></div>

    <script>
        const musicList = document.querySelector('.music-list');
        const musicUpload = document.getElementById('musicUpload');
        const audioPlayer = new Audio();
        const playPauseBtn = document.getElementById('playPauseBtn');
        const prevBtn = document.getElementById('prevBtn');
        const nextBtn = document.getElementById('nextBtn');
        const progressBar = document.querySelector('.progress-bar');
        const progress = document.querySelector('.progress');
        const currentTimeDisplay = document.getElementById('currentTime');
        const durationDisplay = document.getElementById('duration');
        const volumeSlider = document.querySelector('.volume-slider');
        const musicTitle = document.querySelector('.music-title');
        const musicArtist = document.querySelector('.music-artist');
        const albumArtImg = document.getElementById('albumArtImg');
        const playPauseIcon = document.getElementById('playPauseIcon');
        const volumeIcon = document.getElementById('volumeIcon');
        const body = document.body;
        const menuBtn = document.createElement('button');
        const storedLightMode = localStorage.getItem('theme') || 'dark';
        const isMobile = /Mobi|Android/i.test(navigator.userAgent);

        let activeView = 'home'; // 'home', 'library', 'search', 'nowPlaying'
        let isPanelVisible = false;
        let panelContent = null; // 'lyrics' or 'queue'
        let libraryScrollPosition = 0;
        let isFullscreen = false;
        let lastMainView = 'home'; // To remember where to return after playback ends
        let lastScrollPosition = 0; // To remember scroll position when entering Now Playing
        let scrollPositions = { home: 0, library: 0, search: 0 };
        const viewContainers = document.querySelectorAll('.view-container');
        const tabBtns = document.querySelectorAll('.tab-btn');
        const miniplayer = document.getElementById('bottom-miniplayer');
        const miniplayerArt = document.getElementById('miniplayer-art');
        const miniplayerTitle = document.getElementById('miniplayer-title');
        const miniplayerArtist = document.getElementById('miniplayer-artist');
        const miniplayerPlayBtn = document.getElementById('miniplayer-play-btn');
        const miniplayerProgress = document.querySelector('.miniplayer-progress');
        const toolbar = document.querySelector('.toolbar');
        
        const drawer = document.getElementById('drawer');
        const drawerContent = document.getElementById('drawer-content');
        const drawerOverlay = document.getElementById('drawer-overlay');
        let isDrawerOpen = false;
        let closeDrawerTimeout = null;
        
        let listenAgainIndex = parseInt(localStorage.getItem('listenAgainIndex') || '0');
        let currentMediaSessionArtBlobUrl = null;
        let lastOriginalImageUrl = null;
        let lastResizedImageUrl = null;
        let distortionCanvas, ctx;
        let currentResizedArt = new Image();
        let oldResizedArt = new Image();
        let blobs = [];
        let animationFrameId;
        let backgroundRotation = 0;
        let currentBeatIntensity = 0; // The smoothly animated intensity used for rendering
        const NUM_BLOBS_PERF = 15; // Increased for better canvas coverage
        let noise; // This will hold our noise generator function
        let beatIntensity = 0;
        let isTransitioning = false;
        let transitionProgress = 0;
        const TRANSITION_DURATION = 15; // in frames (approx. 0.25 seconds)
        let visualizerFrameId = null;
        let visualizerDraw = () => {};
        let songs = [];
        let currentSongId = null;
        let isPlayerLoading = false;
        let db;
        let directoryHandles = []; // For File System Access API
        let isShuffleEnabled = false;
        let repeatMode = 'none'; // 'none', 'all', or 'one'
        let playQueue = [];
        let isQueueUserModified = false;
        let currentQueueIndex = -1;
        let isAutoplayEnabled = false;
        let autoplaySongIds = new Set(); // Use a Set for efficient add/delete/check operations
        let searchTimeout;
        let searchInput;
        let longPressTimer;
        let isLongPress = false;
        const LONG_PRESS_DURATION = 500;
        let isDragging = false;
        let draggedItem = null;
        let isDraggingAlbum = false;
        let touchStartY = 0;
        let initialY = 0;
        let touchTarget = null;
        let audioContext;
        let analyser;
        let isVisualizerInitialized = false;
        let source;
        let currentFilter = 'albums'; // 'albums', 'artists', 'songs'
        let editModal, editSongId, editTitle, editArtist, editAlbum, saveEdit, cancelEdit, equalizerModal, manageFoldersModal;
        let crossfadeEnabled = false;
        let sleepTimerId = null;
        let eqBass, eqMid, eqTreble; // Add these for the EQ
        let playlists = [];
        let playlistModal, sleepTimerModal;
        let currentSortMode = 'dateAdded'; // 'dateAdded', 'alpha'
        let activeAlbum = null; // Will store { artist, name } of the selected album

        // --- SoundCloud variables ---
        let soundcloudClientId = '';
        let isSoundcloudEnabled = false;
        let soundcloudSearchTimeout;
        let currentlyPlayingSong = null;
        let isSoundcloudOfflineMode = false;
        let soundcloudFilter = 'tracks';
        let lastSoundcloudSearchResults = []; // To store API results for filtering
        const SOUNDCLOUD_CACHE_LIMIT = 200 * 1024 * 1024; // 200MB
        let localSongLookup = new Map();

        // --- LRCLIB variables ---
        let isLrclibEnabled = false;
        let lastLrclibSearchResults = [];

        function sanitize(str) {
            if (!str) return '';
            return str.toString().replace(/</g, "<").replace(/>/g, ">");
        }

        function openModal(modal) {
            if (modal) modal.classList.add('visible');
        }
        
        function closeModal(modal) {
            if (modal) modal.classList.remove('visible');
        }

        function shuffleArray(array) {
            for (let i = array.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [array[i], array[j]] = [array[j], array[i]];
            }
            return array;
        }

function openDrawer(title, subtitle, contentHtml, context = {}) {
    clearTimeout(closeDrawerTimeout);

    const drawerTitleEl = document.getElementById('drawer-title');
    const drawerSubtitleEl = document.getElementById('drawer-subtitle');

    drawerTitleEl.textContent = sanitize(title);
    
    // Check the context to see if we should add a delete button
    if (context.type === 'playlist' && context.id) {
        // If it's a playlist, add the subtitle and the delete button side-by-side
        drawerSubtitleEl.innerHTML = `
            <div style="display: flex; align-items: center; justify-content: center; gap: 10px;">
                <span>${sanitize(subtitle)}</span>
                <button id="drawer-delete-playlist-btn" data-playlist-id="${context.id}" title="Delete Playlist">
                    <span class="material-symbols-rounded">delete_forever</span>
                </button>
            </div>
        `;
    } else {
        // Otherwise, just show the normal subtitle
        drawerSubtitleEl.textContent = sanitize(subtitle);
    }

    drawerContent.innerHTML = contentHtml;
    drawer.classList.add('open');
    drawerOverlay.classList.add('visible');
    isDrawerOpen = true;
}

function closeDrawer() {
    drawer.classList.remove('open');
    drawerOverlay.classList.remove('visible');
    isDrawerOpen = false;
    // Clear content after animation
    closeDrawerTimeout = setTimeout(() => {
        drawer.style.transform = '';
        drawerContent.innerHTML = '';
    }, 400);
}
        
function setupDrawerInteractions() {
    let startY = 0;
    let currentY = 0;
    let isDragging = false;
    const handle = document.querySelector('.drawer-handle');
    const drawer = document.getElementById('drawer');

    const startDrag = (y) => {
        if (!isDrawerOpen) return;
        isDragging = true;
        startY = y;
        drawer.style.transition = 'none';
    };

    const moveDrag = (y) => {
        if (!isDragging) return;
        currentY = y;
        const deltaY = currentY - startY;
        if (deltaY > 0) { // Only allow dragging down
            drawer.style.transform = `translateY(${deltaY}px)`;
        }
    };

    const endDrag = () => {
        if (!isDragging) return;
        isDragging = false;
        drawer.style.transition = '';
        drawer.style.transform = ''; // Reset transform to allow CSS transition
        
        const deltaY = currentY - startY;
        if (deltaY > 100) { // Close threshold
            closeDrawer();
        } else {
            drawer.style.bottom = '0';
        }
    };

    handle.addEventListener('mousedown', (e) => startDrag(e.clientY));
    document.addEventListener('mousemove', (e) => moveDrag(e.clientY));
    document.addEventListener('mouseup', endDrag);
    document.addEventListener('mouseleave', endDrag);

    handle.addEventListener('touchstart', (e) => startDrag(e.touches[0].clientY), { passive: true });
    document.addEventListener('touchmove', (e) => moveDrag(e.touches[0].clientY), { passive: true });
    document.addEventListener('touchend', endDrag);

    document.getElementById('drawer-overlay').addEventListener('click', closeDrawer);
}

function getHighResArtwork(url) {
    if (!url) {
        return generateRandomGradient(); // Fallback for tracks with no artwork
    }
    // This is a more robust replacement that handles multiple small sizes
    return url.replace('-large.jpg', '-t500x500.jpg')
              .replace('-t300x300.jpg', '-t500x500.jpg')
              .replace('-badge.jpg', '-t500x500.jpg');
}
        
function renderSearchResults() {
    const searchGrid = document.getElementById('search-results-grid');
    const query = document.getElementById('searchInput').value.toLowerCase();
    if (!query) {
        searchGrid.innerHTML = '';
        return;
    }

    const results = songs.filter(s => 
        s.name.toLowerCase().includes(query) ||
        s.artist.toLowerCase().includes(query) ||
        s.album.toLowerCase().includes(query)
    );

    if (results.length === 0) {
        searchGrid.innerHTML = `<div class="no-results" style="grid-column: 1 / -1;"><p>No results found for "${query}"</p></div>`;
        return;
    }
    
    // For now, just show a list of matching songs
    const resultsHtml = results.map(song => `
        <div class="music-item" data-id="${song.id}" style="cursor: pointer;">
             <div class="song-info">
                <img src="${song.albumArt}" class="album-thumbnail" style="width: 40px; height: 40px; border-radius: 8px; margin-right: 6px;">
                <div>
                    <div class="song-title" style="white-space: normal;">${sanitize(song.name)}</div>
                    <div class="album-artist" style="font-size: 0.8em;">${sanitize(song.artist)}</div>
                </div>
            </div>
        </div>
    `).join('');
    searchGrid.className = 'item-list'; // Search results are a list
    searchGrid.innerHTML = resultsHtml;

    requestAnimationFrame(() => {
        const searchView = document.getElementById('search-view');
        searchView.scrollTop = scrollPositions.search;
    });
}

function renderSoundcloudSearchResults() {
    const resultsGrid = document.getElementById('soundcloud-results-grid');
    if (lastSoundcloudSearchResults.length === 0) {
        resultsGrid.innerHTML = '<div class="no-results" style="grid-column: 1 / -1;"><p>No results found.</p></div>';
        return;
    }

    let resultsHtml = '';
    switch (soundcloudFilter) {
        case 'artists':
            resultsGrid.className = 'item-grid';
            const artists = lastSoundcloudSearchResults.reduce((acc, track) => {
                const artistName = track.user.username;
                if (!acc[artistName]) {
                    acc[artistName] = getHighResArtwork(track.artwork_url) || track.user.avatar_url || generateRandomGradient();
                }
                return acc;
            }, {});
            resultsHtml = Object.entries(artists).map(([name, art]) => `
                <div class="item-card" data-artist-name="${sanitize(name)}">
                    <img src="${art}" class="item-card-art" style="border-radius: 50%;">
                    <div class="item-card-info" style="text-align: center;"><div class="item-card-title">${sanitize(name)}</div></div>
                </div>`).join('');
            break;
        case 'albums':
            resultsGrid.className = 'item-grid';
            const albums = lastSoundcloudSearchResults.reduce((acc, track) => {
                const albumName = track.title.split('-')[0].trim(); // Simple album name parsing
                if (!acc[albumName]) {
                    acc[albumName] = { art: getHighResArtwork(track.artwork_url), artist: track.user.username };
                }
                return acc;
            }, {});
             resultsHtml = Object.entries(albums).map(([name, data]) => `
                <div class="item-card" data-album-name="${sanitize(name)}">
                    <img src="${data.art}" class="item-card-art">
                    <div class="item-card-info"><div class="item-card-title">${sanitize(name)}</div><div class="item-card-subtitle">${sanitize(data.artist)}</div></div>
                </div>`).join('');
            break;
        case 'tracks':
        default:
            resultsGrid.className = 'item-grid';
            resultsHtml = lastSoundcloudSearchResults.map(track => `
                <div class="item-card" data-track-id="${track.id}">
                    <img src="${getHighResArtwork(track.artwork_url)}" class="item-card-art">
                    <div class="item-card-info">
                        <div class="item-card-title">${sanitize(track.title)}</div>
                        <div class="item-card-subtitle">${sanitize(track.user.username)}</div>
                    </div>
                </div>`).join('');
            break;
    }
    resultsGrid.innerHTML = resultsHtml;
}

function setView(viewName) {
    activeView = viewName;
    const isNowPlaying = (viewName === 'now-playing');

    if (isNowPlaying) {
        if (!animationFrameId) {
            animateCanvas();
        }
        // Much cleaner start logic:
        if (!visualizerFrameId && visualizerDraw) {
            visualizerDraw();
        }
    } else {
        if (animationFrameId) {
            cancelAnimationFrame(animationFrameId);
            animationFrameId = null;
        }
        if (visualizerFrameId) {
            cancelAnimationFrame(visualizerFrameId);
            visualizerFrameId = null;
        }
    }
    
    tabBtns.forEach(btn => {
        btn.classList.toggle('active', btn.dataset.view === viewName);
    });

    viewContainers.forEach(container => {
        const isVisible = container.id === `${viewName}-view`;
        container.style.display = isVisible ? 'flex' : 'none';

        if (isVisible) {
            if (viewName === 'library') { renderLibraryPage(); } 
            else if (viewName === 'home') { renderHomePage(); } 
            else if (viewName === 'search') { renderSearchResults(); }
        }
    });
    
    if (isNowPlaying && currentSongId) {
        const song = currentlyPlayingSong; 
        if (song) updatePlayerUI(song);
    }

    if (viewName !== 'search') {
        document.getElementById('searchInput').value = '';
        if(activeView === 'search') renderSearchResults(); // Clear results visually
    }
    
    toolbar.classList.toggle('hidden', isNowPlaying && isFullscreen);
    updateMiniplayerUI(currentlyPlayingSong, audioPlayer.paused ? 'paused' : 'playing');

    document.getElementById('distortion-container').classList.toggle('active', isNowPlaying);
    if (isVisualizerInitialized && isNowPlaying && audioContext.state === 'suspended') {
        audioContext.resume();
    }
}
     
const initDB = () => {
    return new Promise((resolve, reject) => {
        // DB version bumped to 7
        const request = indexedDB.open('musicDB', 7);

        request.onerror = (event) => {
            console.error('IndexedDB error:', event.target.error);
            reject(event.target.error);
        };

        request.onupgradeneeded = (event) => {
            db = event.target.result;
            if (!db.objectStoreNames.contains('musicFiles')) {
                db.createObjectStore('musicFiles', { keyPath: 'id' });
            }
            if (!db.objectStoreNames.contains('songs')) {
                const songStore = db.createObjectStore('songs', { keyPath: 'id' });
                songStore.createIndex('albumArtist', 'albumArtist');
                // Add new index for play count
                songStore.createIndex('playCount', 'playCount');
            } else {
                // Ensure playCount index exists on existing stores
                const songStore = event.target.transaction.objectStore('songs');
                if (!songStore.indexNames.contains('playCount')) {
                    songStore.createIndex('playCount', 'playCount');
                }
            }
            if (!db.objectStoreNames.contains('playlists')) {
                db.createObjectStore('playlists', { keyPath: 'id', autoIncrement: true });
            }
            if (!db.objectStoreNames.contains('config')) {
                db.createObjectStore('config', { keyPath: 'key' });
            }
            // Create new store for play history
            if (!db.objectStoreNames.contains('playHistory')) {
                db.createObjectStore('playHistory', { keyPath: 'timestamp' });
            }
            if (!db.objectStoreNames.contains('soundcloudCache')) {
                const cacheStore = db.createObjectStore('soundcloudCache', { keyPath: 'id' });
                cacheStore.createIndex('timestamp', 'timestamp');
            }
        };

        request.onsuccess = (event) => {
            db = event.target.result;
            resolve();
        };
    });
};

function promiseIDBRequest(request) {
    return new Promise((resolve, reject) => {
        request.onsuccess = () => resolve(request.result);
        request.onerror = () => reject(request.error);
    });
}

function createPlayQueue() {
    if (isShuffleEnabled) {
        let availableSongs = [...songs];
        let currentSong = null;
        
        if (currentSongId) {
            currentSong = availableSongs.find(s => s.id === currentSongId);
            availableSongs = availableSongs.filter(s => s.id !== currentSongId);
        }
        
        for (let i = availableSongs.length - 1; i > 0; i--) {
            const j = Math.floor(Math.random() * (i + 1));
            [availableSongs[i], availableSongs[j]] = [availableSongs[j], availableSongs[i]];
        }
        
        return currentSong ? [currentSong, ...availableSongs] : availableSongs;
    }
    
    return [...songs];
}

function resetPlayer() {
    audioPlayer.pause();
    audioPlayer.currentTime = 0;
    currentSongId = null;
    currentlyPlayingSong = null; // Clear the currently playing song object
    updateMiniplayerUI(null);
    playQueue = [];
    currentQueueIndex = -1;

    isShuffleEnabled = false;
    updateShuffleButtonState();

    const defaultImage = "/music/favicon.png";
    const defaultImageBig = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAfQAAAH0CAYAAADL1t+KAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsMAAA7DAcdvqGQAAAPgSURBVHhe7cEBAQAAAIIg/69uSEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACcqAFFFQAB8Dl/nAAAAABJRU5ErkJggg==";

    albumArtImg.src = defaultImageBig;

    updateAllBackgrounds('');
    
    musicTitle.textContent = 'No song playing';
    musicArtist.innerHTML = '&nbsp;';
    
    updateTimeDisplays();
    playPauseIcon.textContent = 'play_arrow';
    playPauseBtn.classList.remove('playing');
    Gurasuraisu.updatePlaybackState({ playbackState: 'paused' });
    document.title = 'Music';
    updateFavicon(defaultImage);

    Gurasuraisu.clearMediaSession();

    // Revoke any existing blob URL to prevent memory leaks
    if (currentMediaSessionArtBlobUrl) {
        URL.revokeObjectURL(currentMediaSessionArtBlobUrl);
        currentMediaSessionArtBlobUrl = null;
    }

    if ('mediaSession' in navigator) {
        navigator.mediaSession.metadata = null;
        navigator.mediaSession.playbackState = 'none';
    }

    connectAudioGraph();
    document.querySelector('.lyrics-button').style.display = ''; // Ensure lyrics button is visible on reset
    
    if (activeView === 'now-playing') {
        setView(lastMainView);
    }
}
    
        function formatTime(seconds) {
            if (isNaN(seconds) || seconds < 0) return "-:--";
            const minutes = Math.floor(seconds / 60);
            const remainingSeconds = Math.floor(seconds % 60);
            return `${minutes}:${remainingSeconds.toString().padStart(2, '0')}`;
        }
        
function makeElementsDraggable() {
      // This function is intentionally left blank to disable drag-and-drop for the library view.
      // Drag-and-drop for the queue is handled by a separate function.
}

// Function to update the songs array based on the DOM order
function updateSongsArrayFromDOM() {
  const newSongsOrder = [];
  const albumOrder = [];
  
  document.querySelectorAll('.album-section').forEach((albumSection, albumIndex) => {
    const albumName = albumSection.querySelector('.album-name').textContent;
    const albumArtist = albumSection.querySelector('.album-artist').textContent;
    
    albumOrder.push({
      name: albumName,
      index: albumIndex
    });
    
    albumSection.querySelectorAll('.music-item').forEach((musicItem, songIndex) => {
      const songId = parseFloat(musicItem.dataset.id);
      const song = songs.find(s => s.id === songId);
      
      if (song) {
        song.trackNumber = songIndex + 1;
        song.albumOrder = albumIndex;
        newSongsOrder.push(song);
      }
    });
  });
  
  songs = newSongsOrder;
  
  updatePlayQueue();
  
  saveSongs();
}

function loadAndPlaySong(song) {
    if (!song) return;
    playSong(song);
}
        
function updatePageTitle() {
    if (currentSongId) {
        const song = currentlyPlayingSong;
        if (song) {
            const currentTime = formatTime(audioPlayer.currentTime);
            document.title = `${currentTime} | ${sanitize(song.name)}  ${sanitize(song.artist)}`;
        }
    } else {
        document.title = 'Music'; // Default title when no song is playing
    }
}

function setupLongPressListeners(container) {
    let longPressTimer;
    let isLongPress = false;
    let startX, startY;
    let moved = false; // Flag to track if the touch/mouse has moved significantly
    const LONG_PRESS_DURATION = 500;
    const MOVE_THRESHOLD = 10; // Pixels a user can move before it's considered a scroll

    const handlePressStart = (e) => {
        const musicItem = e.target.closest('.music-item[data-id], .item-card[data-id]');
        if (!musicItem) return;

        startX = e.touches ? e.touches[0].clientX : e.clientX;
        startY = e.touches ? e.touches[0].clientY : e.clientY;
        isLongPress = false;
        moved = false; // Reset on new touch start

        longPressTimer = setTimeout(() => {
            if (!moved) { // Only trigger long press if user hasn't scrolled
                isLongPress = true;
                const songId = parseFloat(musicItem.dataset.id);
                openSongContextMenu(musicItem, songId);
            }
        }, LONG_PRESS_DURATION);
    };

    const handlePressMove = (e) => {
        // If the timer has already been cleared (e.g., by a long press), we don't need to do anything
        if (!longPressTimer) return;

        const currentX = e.touches ? e.touches[0].clientX : e.clientX;
        const currentY = e.touches ? e.touches[0].clientY : e.clientY;

        // Check if the movement exceeds our threshold
        if (Math.abs(currentX - startX) > MOVE_THRESHOLD || Math.abs(currentY - startY) > MOVE_THRESHOLD) {
            moved = true; // It's a scroll
            clearTimeout(longPressTimer); // Cancel the long press timer
            longPressTimer = null;
        }
    };

    const handlePressEnd = (e) => {
        clearTimeout(longPressTimer);

        // If it was a long press, stop the event from bubbling up as a click
        if (isLongPress) {
            e.preventDefault();
            e.stopPropagation();
            return;
        }
        
        // If the touch moved, it was a scroll, not a click, so do nothing.
        if (moved) {
            return;
        }

        // This is a regular click/tap
        const musicItem = e.target.closest('.music-item[data-id], .item-card[data-id]');
        if (musicItem) {
            const songId = parseFloat(musicItem.dataset.id);
            const song = songs.find(s => s.id === songId);
            if (song) {
                const contextSongs = Array.from(container.querySelectorAll('.music-item[data-id], .item-card[data-id]'))
                    .map(item => songs.find(s => s.id === parseFloat(item.dataset.id)))
                    .filter(Boolean);
                playSong(song, contextSongs.length > 0 ? contextSongs : [song]);
            }
        }
    };
    
    // Remove old listeners to prevent duplicates if this function is called multiple times
    container.removeEventListener('mousedown', handlePressStart);
    container.removeEventListener('touchstart', handlePressStart, { passive: true });
    container.removeEventListener('mousemove', handlePressMove);
    container.removeEventListener('touchmove', handlePressMove, { passive: true });
    container.removeEventListener('mouseup', handlePressEnd);
    container.removeEventListener('touchend', handlePressEnd);
    container.removeEventListener('mouseleave', handlePressEnd); // Handle mouse leaving the element
    container.removeEventListener('touchcancel', handlePressEnd); // Handle cancelled touches

    // Add new listeners
    container.addEventListener('mousedown', handlePressStart);
    container.addEventListener('touchstart', handlePressStart, { passive: true });
    container.addEventListener('mousemove', handlePressMove);
    container.addEventListener('touchmove', handlePressMove, { passive: true });
    container.addEventListener('mouseup', handlePressEnd);
    container.addEventListener('touchend', handlePressEnd);
    container.addEventListener('mouseleave', handlePressEnd);
    container.addEventListener('touchcancel', handlePressEnd);
}
        
        function isAudioFile(file) {
            const allowedTypes = [
                'audio/mpeg', 'audio/wav', 'audio/wave', 'audio/x-wav', 'audio/flac', 
                'audio/ogg', 'audio/opus', 'audio/x-m4a', 'audio/aac', 'audio/webm', 'audio/x-flac'
            ];
            const allowedExtensions = /\.(mp3|wav|flac|ogg|opus|m4a|aac)$/i;
            
            return allowedTypes.includes(file.type) || (file.name && file.name.match(allowedExtensions));
        }
        
function generateRandomGradient() {
    const colors = [
        '#ff6b6b', '#4ecdc4', '#45b7d1', '#96ceb4', '#ffeead',
        '#d4a5a5', '#9b59b6', '#3498db', '#e74c3c', '#2ecc71',
        '#f1c40f', '#1abc9c', '#e67e22', '#7f8c8d', '#2c3e50'
    ];
    
    const color1 = colors[Math.floor(Math.random() * colors.length)];
    let color2;
    do {
        color2 = colors[Math.floor(Math.random() * colors.length)];
    } while (color1 === color2);
    
    const angle = Math.floor(Math.random() * 360);
    
    const canvas = document.createElement('canvas');
    canvas.width = 500;
    canvas.height = 500;
    const ctx = canvas.getContext('2d');
    
    const gradient = ctx.createLinearGradient(0, 0, 500, 500);
    gradient.addColorStop(0, color1);
    gradient.addColorStop(1, color2);
    
    ctx.fillStyle = gradient;
    ctx.fillRect(0, 0, 500, 500);
    
    return canvas.toDataURL('image/jpeg', 0.9);
}

function updateLocalSongLookup(songsToAdd, options = {}) {
    if (options.clear) {
        localSongLookup.clear();
        console.log("Local song lookup map cleared.");
    }
    if (!Array.isArray(songsToAdd)) return; // Safety check

    for (const song of songsToAdd) {
        const uniqueKey = `${(song.artist || '').toLowerCase().trim()}::${(song.name || '').toLowerCase().trim()}`;
        // Only add the song if this key doesn't already exist.
        // This prioritizes the first-added version in case of library inconsistencies.
        if (!localSongLookup.has(uniqueKey)) {
            localSongLookup.set(uniqueKey, song);
        }
    }
}
        
async function preloadSongs(files) {
    const allowedTypes = [
        'audio/mpeg',        // MP3
        'audio/wav',         // WAV
        'audio/flac',        // FLAC
        'audio/ogg',         // OGG
        'audio/opus',        // OPUS
        'audio/x-m4a',       // M4A
        'audio/aac',         // AAC
        'audio/webm',        // WEBM audio
        'audio/x-flac'       // Alternative FLAC MIME type
    ];

    const filesArray = Array.from(files).filter(file => 
        allowedTypes.includes(file.type) || 
        file.name.match(/\.(mp3|wav|flac|ogg|opus|m4a|aac)$/i)
    );
    
    if (filesArray.length === 0) {
        console.warn('No valid audio files found');
        return;
    }

    for (const file of filesArray) {
        try {
            const arrayBuffer = await file.arrayBuffer();
            
            await new Promise((resolve, reject) => {
                const transaction = db.transaction(['musicFiles'], 'readwrite');
                const store = transaction.objectStore('musicFiles');
                
                const song = {
                    id: Date.now() + Math.random(),
                    file: new Blob([arrayBuffer], { type: file.type })
                };
                
                const request = store.put(song);
                
                transaction.oncomplete = () => resolve();
                transaction.onerror = (event) => reject(event.target.error);
            });
        } catch (error) {
            console.error('Error processing file:', error);
        }
    }
}

function updateFavicon(albumArt) {
  if (!albumArt) return;
  const canvas = document.createElement('canvas');
  const ctx = canvas.getContext('2d');
  const size = 32; 
  const radius = 10;

  canvas.width = size;
  canvas.height = size;

  const img = new Image();
  if (!albumArt.startsWith('data:')) {
    img.crossOrigin = 'anonymous';
  }

  img.onload = function() {
    ctx.clearRect(0, 0, size, size);
    ctx.beginPath();
    if (ctx.roundRect) {
        ctx.roundRect(0, 0, size, size, radius);
    } else { // Fallback for older browsers
        ctx.rect(0, 0, size, size);
    }
    ctx.closePath();
    ctx.clip();
    ctx.drawImage(img, 0, 0, size, size);

    const roundedImageURL = canvas.toDataURL('image/png');
    const existingFavicon = document.getElementById('favicon');
    if (existingFavicon) {
        existingFavicon.href = roundedImageURL;
    }
  };

  img.onerror = function() {
    console.error('Error loading album art for favicon');
  };
  img.src = albumArt;
}

async function loadSong(song) {
    playSong(song);
}
        
async function extractMetadata(file) {
    return new Promise((resolve) => {
        new jsmediatags.Reader(file)
            .read({
                onSuccess: async function(tag) {
                    let albumArt;
                    if (tag.tags.picture) {
                        const { data, format } = tag.tags.picture;
                        const base64String = data.reduce((acc, curr) => acc + String.fromCharCode(curr), '');
                        albumArt = `data:${format};base64,${btoa(base64String)}`;
                    } else {
                        albumArt = generateRandomGradient();
                    }

                    let lyricsText = null;
                    let lrcData = null;
                    let foundSyncedLyrics = false;
                    const lrcCandidates = [
                        tag.tags.USLT?.lyrics,
                        (typeof tag.tags.lyrics === 'object' ? tag.tags.lyrics.lyrics : tag.tags.lyrics),
                        tag.tags.LYRICS
                    ];
                    for (const candidate of lrcCandidates) {
                        if (candidate) {
                            const parsed = parseLRC(candidate);
                            if (parsed) {
                                lrcData = parsed;
                                lyricsText = candidate;
                                foundSyncedLyrics = true;
                                break;
                            }
                        }
                    }
                    if (!foundSyncedLyrics) {
                        lyricsText = lrcCandidates.find(text => typeof text === 'string' && text.trim() !== '') || null;
                    }

                    const parseComplexTag = (rawTag) => {
                        if (!rawTag) return null;
                        const value = rawTag.data || rawTag;
                        if (typeof value === 'object' && value.no) {
                            return parseInt(value.no, 10);
                        }
                        const parsed = parseInt(String(value).split('/')[0], 10);
                        return isNaN(parsed) ? null : parsed;
                    };

                    const discNumber = parseComplexTag(tag.tags.DISCNUMBER || tag.tags.disk || tag.tags.TPOS);
                    const trackNumber = parseComplexTag(tag.tags.TRACKNUMBER || tag.tags.track);
                    
                    const albumArtist = tag.tags.TPE2?.data || tag.tags.album_artist || tag.tags.artist || 'Unknown Artist';

                    const genreTag = tag.tags.TCON || tag.tags.genre;
                    const genre = genreTag ? (genreTag.data || genreTag) : null;

                    resolve({
                        title: tag.tags.title || file.name.replace(/\.[^/.]+$/, ""),
                        artist: tag.tags.artist || 'Unknown Artist',
                        album: tag.tags.album || 'Unknown Album',
                        albumArtist: albumArtist,
                        year: tag.tags.year || '',
                        albumArt: albumArt,
                        trackNumber: trackNumber,
                        discNumber: discNumber,
                        lyrics: lyricsText,
                        lrcData: lrcData,
                        genre: genre
                    });
                },
                onError: (error) => {
                    console.error("jsmediatags ERROR for:", file.name, error);
                    resolve({
                        title: file.name.replace(/\.[^/.]+$/, ""),
                        artist: 'Unknown Artist',
                        album: 'Unknown Album',
                        albumArtist: 'Unknown Artist',
                        year: '',
                        albumArt: generateRandomGradient(),
                        trackNumber: null,
                        discNumber: null,
                        lyrics: null,
                        lrcData: null,
                        genre: null
                    });
                }
            });
    });
}
        
async function addSongs(files, storageType) {
    const newSongs = [];
    const songFilesToStore = [];

    for (let fileHandleOrFile of files) {
        try {
            const file = storageType === 'filesystem' ? await fileHandleOrFile.getFile() : fileHandleOrFile;
            if (!isAudioFile(file)) continue;

            const metadata = await extractMetadata(file);
            const newSongId = Date.now() + Math.random();

            newSongs.push({
                id: newSongId,
                name: metadata.title,
                artist: metadata.artist,
                album: metadata.album,
                albumArtist: metadata.albumArtist,
                storage: storageType,
                handleName: file.name,
                dateAdded: Date.now(),
                year: metadata.year,
                albumArt: metadata.albumArt,
                trackNumber: metadata.trackNumber,
                discNumber: metadata.discNumber,
                lyrics: metadata.lyrics,
                lrcData: metadata.lrcData,
                genre: metadata.genre,
                playCount: 0 // Initialize playCount
            });

            if (storageType === 'indexeddb') {
                songFilesToStore.push({ id: newSongId, file: file });
            }

        } catch (error) {
            console.error("Could not process file:", fileHandleOrFile.name, error);
        }
    }

    if (newSongs.length > 0) {
        songs.push(...newSongs);
        processAndSortSongs();
        await saveSongs();

        if (songFilesToStore.length > 0) {
            const tx = db.transaction(['musicFiles'], 'readwrite');
            songFilesToStore.forEach(item => tx.objectStore('musicFiles').put(item));
            await tx.done;
        }
    }

    // Re-render the current view to show the new songs
    if (activeView === 'library') {
        renderLibraryPage();
    } else if (activeView === 'home') {
        renderHomePage();
    }
    updateLocalSongLookup(newSongs);
}

async function scanForNewSongs() {
    if (directoryHandles.length === 0) return false;

    console.log("Scanning for new songs in existing directories...");
    const filesToAdd = [];
    
    const existingSongNames = new Set(songs.map(s => s.handleName));

    for (const handle of directoryHandles) {
        try {
            for await (const entry of handle.values()) {
                if (entry.kind === 'file' && isAudioFile({ name: entry.name }) && !existingSongNames.has(entry.name)) {
                    filesToAdd.push(entry);
                }
            }
        } catch (e) {
            console.error(`Could not scan directory "${handle.name}". It may need to be re-added.`, e);
        }
    }

    if (filesToAdd.length > 0) {
        console.log(`Found ${filesToAdd.length} new songs. Adding them to the library...`);
        await addSongs(filesToAdd, 'filesystem');
        return true; 
    }
    
    console.log("No new songs found.");
    return false;
}

function parseLRC(lrcText) {
    if (!lrcText || !lrcText.includes('[')) {
        return null;
    }

    const lrcData = [];
    const timeRegex = /\[(\d{2}):(\d{2})\.(\d{2,3})\]/g;
    
    const matches = [...lrcText.matchAll(timeRegex)];

    if (matches.length === 0) {
        return null;
    }

    matches.forEach((match, index) => {
        const minutes = parseInt(match[1], 10);
        const seconds = parseInt(match[2], 10);
        const milliseconds = parseInt(match[3].padEnd(3, '0'), 10);
        const time = minutes * 60 + seconds + milliseconds / 1000;

        const textStartIndex = match.index + match[0].length;
        
        const nextMatch = matches[index + 1];
        const textEndIndex = nextMatch ? nextMatch.index : lrcText.length;
        
        const text = lrcText.substring(textStartIndex, textEndIndex).trim();

        lrcData.push({ time, text });
    });

    return lrcData.length > 0 ? lrcData : null;
}
        
async function loadSongsFromStorage() {
    try {
        const tx = db.transaction(['songs'], 'readonly');
        const songStore = tx.objectStore('songs');
        const songsRequest = songStore.getAll();
        
        const loadedSongs = await new Promise((resolve, reject) => {
            songsRequest.onsuccess = () => resolve(songsRequest.result);
            songsRequest.onerror = (e) => reject(e.target.error);
        });
        
        songs = loadedSongs || [];
        processAndSortSongs();
        updatePlayQueue();
    } catch (error) {
        console.error('Error loading songs from storage:', error);
    }
}
        
async function saveSongs() {
    const transaction = db.transaction(['songs'], 'readwrite');
    const store = transaction.objectStore('songs');
    
    return new Promise((resolve, reject) => {
        transaction.onerror = (event) => {
            console.error("Transaction error while saving songs:", event.target.error);
            reject(event.target.error);
        }
        
        store.clear();
        songs.forEach(song => {
            const songToStore = {
                id: song.id, name: song.name, artist: song.artist, album: song.album,
                albumArtist: song.albumArtist, year: song.year, albumArt: song.albumArt, 
                trackNumber: song.trackNumber, discNumber: song.discNumber,
                lyrics: song.lyrics, lrcData: song.lrcData, storage: song.storage,
                handleName: song.handleName, dateAdded: song.dateAdded,
                genre: song.genre,
                playCount: song.playCount || 0
            };
            store.add(songToStore);
        });
        
        transaction.oncomplete = () => {
            console.log(`Songs saved. Total count: ${songs.length}`);
            resolve();
        };
    });
}

async function migrateToFSA() {
    if (directoryHandles.length === 0) return;

    const songsToMigrate = songs.filter(s => s.storage === 'indexeddb');
    if (songsToMigrate.length === 0) {
        console.log("No songs to migrate.");
        return;
    }

    console.log(`Starting migration for ${songsToMigrate.length} songs...`);
    const blobIdsToDelete = [];
    let migrationOccurred = false;

    for (const song of songsToMigrate) {
        let foundInHandles = false;
        for (const handle of directoryHandles) {
            try {
                await handle.getFileHandle(song.handleName);
                foundInHandles = true;
                break;
            } catch (e) { /* Not in this handle */ }
        }
        
        if (foundInHandles) {
            song.storage = 'filesystem';
            blobIdsToDelete.push(song.id);
            migrationOccurred = true;
            console.log(`Migrated "${song.name}" to File System Access.`);
        } else {
            console.warn(`Could not find "${song.handleName}" in the directory. It will remain in browser storage.`);
        }
    }

    if (migrationOccurred) {
        if (blobIdsToDelete.length > 0) {
            const deleteTx = db.transaction('musicFiles', 'readwrite');
            blobIdsToDelete.forEach(id => deleteTx.objectStore('musicFiles').delete(id));
            await deleteTx.done;
        }
        
        await saveSongs();
        Gurasuraisu.showPopup(`Successfully migrated ${blobIdsToDelete.length} songs to use direct file access, freeing up browser storage!`);
    }
}

        // --- GuraAI Music Assistant Integration ---
        const isGuraAiEnabled = localStorage.getItem('aiAssistantEnabled') === 'true';
        let geminiApiKey = localStorage.getItem('geminiApiKey') || '';
        let genAI;
        let musicAiModel;

        // Utility function to format the user's library for the AI prompt
        function formatLibraryForPrompt(songList = songs) {
            if (songList.length === 0) return "The user's library is empty.";
            // Create a concise string representation of the music library
            return songList.map(s => `${s.artist} - ${s.name}`).join('\n');
        }

async function initializeMusicAi() {
    if (!isGuraAiEnabled) return;

    if (!geminiApiKey) {
        console.warn("GuraAI is enabled, but no API key is set. AI features will be disabled.");
        return;
    }

    try {
        // Dynamically import the AI library only if needed
        const { GoogleGenerativeAI } = await import("https://esm.sh/@google/generative-ai");
        genAI = new GoogleGenerativeAI(geminiApiKey);

        const systemInstruction = `You are GuraAI, an intelligent music assistant integrated into a music player. Your goal is to help users discover music and manage their library. You will be given a list of songs from the user's library as context. Based on the user's prompt, you must call one of the available functions. Your primary task is to select relevant songs from the provided library list. Do not respond with conversational text; only use function calls.`;

        const tools = [{
            "functionDeclarations": [
                {
                    "name": "createPlaylist",
                    "description": "Creates a new playlist.",
                    "parameters": {
                        "type": "OBJECT",
                        "properties": {
                            "playlistName": { "type": "STRING", "description": "A suitable name for the new playlist, derived from the user's prompt." },
                            "songs": { "type": "ARRAY", "items": { "type": "STRING" }, "description": "An array of song titles selected from the user's library that match the prompt's theme. Format each string as 'Artist - Title'." }
                        },
                        "required": ["playlistName", "songs"]
                    }
                },
                {
                    "name": "getSongRecommendations",
                    "description": "Selects and returns a list of songs from the user's library based on a theme, genre, artist, or the user's listening history.",
                    "parameters": {
                        "type": "OBJECT",
                        "properties": {
                            "songs": { "type": "ARRAY", "items": { "type": "STRING" }, "description": "An array of recommended song titles from the user's library. Format each string as 'Artist - Title'." }
                        },
                        "required": ["songs"]
                    }
                }
            ]
        }];
        
        musicAiModel = genAI.getGenerativeModel({
            model: "gemini-2.5-flash-lite", // Using a powerful model for better selections
            tools: tools,
            systemInstruction: systemInstruction,
        });

        console.log("GuraAI Music Assistant Initialized.");
    } catch (error) {
        console.error("GuraAI Music Assistant Initialization failed:", error);
    }
}

// Helper function to find a song object from a string like "Artist - Title"
function findSongByString(artistTitleString, additionalSongs = []) {
    if (!artistTitleString) return null;

    const fullLibrary = [...songs, ...additionalSongs];
    const cleanInput = artistTitleString.trim().toLowerCase();

    // --- New, More Robust Matching Logic ---

    // 1. First, try for a perfect "Artist - Title" match.
    const lastHyphenIndex = cleanInput.lastIndexOf(' - ');
    if (lastHyphenIndex > 0) {
        const artist = cleanInput.substring(0, lastHyphenIndex).trim();
        const title = cleanInput.substring(lastHyphenIndex + 3).trim();
        const perfectMatch = fullLibrary.find(song =>
            song.artist.toLowerCase() === artist && song.name.toLowerCase() === title
        );
        if (perfectMatch) return perfectMatch;
    }

    // 2. If no perfect match, fall back to a more flexible "contains" search.
    // This is great for when the AI returns just a title or a slightly incorrect format.
    const partialMatch = fullLibrary.find(song => 
        song.name.toLowerCase().includes(cleanInput) || 
        cleanInput.includes(song.name.toLowerCase())
    );
    if (partialMatch) return partialMatch;

    return null; // Return null if no match is found after all attempts.
}

const availableMusicFunctions = {
    createPlaylist: async ({ playlistName, songs: songStrings }) => {
        const songIds = songStrings.map(s => findSongByString(s)).filter(Boolean).map(s => s.id);
        
        if (songIds.length === 0) {
            Gurasuraisu.showPopup(`GuraAI couldn't find matching songs.`);
            return;
        }

        const newPlaylist = { name: playlistName, songIds: songIds };
        const tx = db.transaction('playlists', 'readwrite');
        const request = tx.objectStore('playlists').add(newPlaylist);
        
        await new Promise(resolve => {
            tx.oncomplete = () => {
                newPlaylist.id = request.result;
                resolve();
            };
        });

        playlists.push(newPlaylist);
        Gurasuraisu.showPopup(`GuraAI created playlist: "${playlistName}"`);
        if (activeView === 'library') renderLibraryPage();
    }
    // getSongRecommendations is handled directly by the calling function, so it doesn't need an entry here.
};

        /**
         * Takes an image source URL and creates a new, small, downscaled version of it.
         * This is the key to the performance improvement, as the animation loop
         * will only ever process these small images.
         * @param {string} src - The source URL of the high-resolution image.
         * @param {number} maxSize - The maximum width or height of the output image.
         * @returns {Promise<HTMLImageElement>} A promise that resolves with the new, loaded, resized image.
         */
        function createResizedImage(src, maxSize) {
            return new Promise((resolve, reject) => {
                const highResImage = new Image();
                highResImage.crossOrigin = 'Anonymous';
                highResImage.onload = () => {
                    const canvas = document.createElement('canvas');
                    const context = canvas.getContext('2d');
                    let { width, height } = highResImage;

                    // Calculate new dimensions while maintaining aspect ratio
                    if (width > height) {
                        if (width > maxSize) {
                            height *= maxSize / width;
                            width = maxSize;
                        }
                    } else {
                        if (height > maxSize) {
                            width *= maxSize / height;
                            height = maxSize;
                        }
                    }
                    canvas.width = width;
                    canvas.height = height;

                    // Draw the high-res image onto the small canvas
                    context.drawImage(highResImage, 0, 0, width, height);
                    
                    // Create a new Image object from the small canvas data
                    const resizedImage = new Image();
                    resizedImage.onload = () => resolve(resizedImage);
                    resizedImage.onerror = reject;
                    resizedImage.src = canvas.toDataURL('image/jpeg', 0.8); // Use JPEG for better compression
                };
                highResImage.onerror = reject;
                highResImage.src = src;
            });
        }

        /**
         * A self-contained 3D Perlin noise generator.
         * Using a third dimension (z) for time allows the blob shapes to continuously evolve.
         */
        function createNoiseGenerator() {
            const p = new Uint8Array(512);
            for (let i = 0; i < 256; i++) p[i] = i;
            for (let i = 255; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [p[i], p[j]] = [p[j], p[i]];
            }
            for (let i = 0; i < 256; i++) p[i + 256] = p[i];

            const fade = t => t * t * t * (t * (t * 6 - 15) + 10);
            const lerp = (a, b, t) => a + t * (b - a);
            const grad = (hash, x, y, z) => {
                const h = hash & 15;
                const u = h < 8 ? x : y;
                const v = h < 4 ? y : h === 12 || h === 14 ? x : z;
                return ((h & 1) === 0 ? u : -u) + ((h & 2) === 0 ? v : -v);
            };

            return (x, y, z) => {
                const X = Math.floor(x) & 255, Y = Math.floor(y) & 255, Z = Math.floor(z) & 255;
                x -= Math.floor(x); y -= Math.floor(y); z -= Math.floor(z);
                const u = fade(x), v = fade(y), w = fade(z);
                const a = p[X] + Y, b = p[X + 1] + Y;
                const a1 = p[a] + Z, a2 = p[a + 1] + Z;
                const b1 = p[b] + Z, b2 = p[b + 1] + Z;

                return lerp(
                    lerp(
                        lerp(grad(p[a1], x, y, z), grad(p[b1], x - 1, y, z), u),
                        lerp(grad(p[a2], x, y - 1, z), grad(p[b2], x - 1, y - 1, z), u),
                    v),
                    lerp(
                        lerp(grad(p[a1 + 1], x, y, z - 1), grad(p[b1 + 1], x - 1, y, z - 1), u),
                        lerp(grad(p[a2 + 1], x, y - 1, z - 1), grad(p[b2 + 1], x - 1, y - 1, z - 1), u),
                    v),
                w) * 0.5 + 0.5; // Return in 0-1 range
            };
        }

        /**
         * Initializes a LOW-RESOLUTION canvas and starts the animation. The canvas element
         * itself will be stretched by CSS to fill the screen.
         */
        function initDistortionCanvas() {
            // This constant defines our rendering resolution. 0.25 means 25% of the screen size.
            // A lower number means better performance but a more pixelated (though blurred) source.
            const RENDER_SCALE = 0.25;

            distortionCanvas = document.getElementById('distortionCanvas');
            if (!distortionCanvas) {
                console.error("Distortion Canvas not found in the DOM.");
                return;
            }
            
            ctx = distortionCanvas.getContext('2d'); 
            if (!ctx) {
                console.error("Failed to get 2D context from the canvas.");
                return;
            }
            
            noise = createNoiseGenerator();

            currentResizedArt.crossOrigin = 'Anonymous';
            oldResizedArt.crossOrigin = 'Anonymous';
            currentResizedArt.onerror = () => console.error("Failed to load current resized album art image.");
            oldResizedArt.onerror = () => console.error("Failed to load old resized album art image for transition.");

            const resizeCanvas = () => {
                // Set the canvas's actual drawing buffer size to be a fraction of the window size.
                // For a 1920x1080 screen, this creates a tiny 480x270 canvas to draw on.
                distortionCanvas.width = window.innerWidth * RENDER_SCALE;
                distortionCanvas.height = window.innerHeight * RENDER_SCALE;

                // The CSS `width: 100%` will stretch this small buffer to fill the screen.
                
                if (currentResizedArt.src) {
                    setTimeout(initBlobs, 100);
                }
            };
            window.addEventListener('resize', resizeCanvas);
            resizeCanvas();
        }

        /**
         * Asynchronously loads, resizes, and initiates a smooth transition for new album art.
         * This version includes a full state reset when imageUrl is empty, fixing the bug after resetPlayer.
         * @param {string} imageUrl - The URL of the new high-resolution album art.
         */
        async function loadAlbumArtForCanvas(imageUrl) {
            // If imageUrl is empty, it's a hard reset call from resetPlayer().
            if (!imageUrl) {
                // Clear both image sources to prevent any drawing.
                currentResizedArt.src = '';
                oldResizedArt.src = '';
                // Clear the blobs array.
                blobs = [];
                // Explicitly stop any ongoing transition and reset its progress.
                isTransitioning = false;
                transitionProgress = 0;
                return; // End the function here.
            }

            // The rest of the function only runs if we have a valid imageUrl.
            if (currentResizedArt.src && currentResizedArt.dataset.originalUrl === imageUrl) return;

            try {
                if (currentResizedArt.complete && currentResizedArt.src) {
                    oldResizedArt = currentResizedArt;
                }

                const newResized = await createResizedImage(imageUrl, 64);
                newResized.dataset.originalUrl = imageUrl;
                currentResizedArt = newResized;

                // Start a new transition.
                isTransitioning = true;
                transitionProgress = 0;
                initBlobs();

            } catch (error) {
                console.error("Failed to resize and load album art:", error);
            }
        }

        /**
         * Creates a large number of smaller blobs, with each blob being assigned a
         * unique, random section of the source album art for maximum visual variety.
         */
        function initBlobs() {
            if (!distortionCanvas || !ctx || !currentResizedArt.complete) return;
            blobs = [];
            const { width: imgWidth, height: imgHeight } = currentResizedArt;
            const { width: canvasWidth, height: canvasHeight } = distortionCanvas;
            const maxSpeed = 0.5;

            for (let i = 0; i < NUM_BLOBS_PERF; i++) {
                const radius = (Math.random() * 0.1 + 0.15) * Math.min(canvasWidth, canvasHeight);

                // --- THE FIX: Calculate a unique source rectangle for each blob ---
                // 1. Determine a random size for the crop, e.g., 30% to 60% of the source image's smaller dimension.
                const sourceSize = Math.min(imgWidth, imgHeight) * (Math.random() * 0.3 + 0.3);
                // 2. Determine a random X start position, ensuring the crop doesn't go out of bounds.
                const sourceX = Math.random() * (imgWidth - sourceSize);
                // 3. Determine a random Y start position, also ensuring it stays in bounds.
                const sourceY = Math.random() * (imgHeight - sourceSize);
                // --- End of Fix ---

                blobs.push({
                    x: Math.random() * canvasWidth,
                    y: Math.random() * canvasHeight,
                    vx: (Math.random() - 0.5) * maxSpeed,
                    vy: (Math.random() - 0.5) * maxSpeed,
                    radius: radius,
                    rotation: Math.random() * Math.PI * 2,
                    rotationSpeed: (Math.random() - 0.5) * 0.002,
                    
                    // Use the newly calculated unique source rectangle for this blob
                    sourceX: sourceX,
                    sourceY: sourceY,
                    sourceSize: sourceSize,

                    time: Math.random() * 1000,
                    warpAmount: 0,
                    baseWarp: radius * 0.1,
                    contrast: 1,
                    scale: 1,
                });
            }
        }

        /**
         * Draws a single blob, adding animations based on the global beat intensity.
         * Each blob will now pulse in size and get a rotational "kick" on the beat.
         * @param {CanvasRenderingContext2D} context - The canvas context to draw on.
         * @param {object} blob - The blob object containing its properties.
         * @param {HTMLImageElement} imageToDraw - The pre-resized album art.
         * @param {number} currentBeatIntensity - The global beat intensity (0 to 1).
         */
        function drawOrganicBlob(context, blob, imageToDraw, currentBeatIntensity) {
            context.save();
            
            // --- Apply Beat Animations ---
            // 1. Calculate an effective scale for the blob (base size + beat pulse).
            const effectiveScale = 1 + currentBeatIntensity * 0.05; // 5% size increase on beat
            // 2. Calculate an effective rotation (base rotation + beat kick).
            const effectiveRotation = blob.rotation + currentBeatIntensity * 0.075; // Add a rotational nudge

            context.translate(blob.x, blob.y);
            context.rotate(effectiveRotation); // Use the animated rotation
            
            context.beginPath();
            const points = 20;
            const noiseFrequency = 1.8;
            const noiseSpeed = 0.004;
            
            for (let i = 0; i < points; i++) {
                const angle = (i / points) * Math.PI * 2;
                const x = Math.cos(angle);
                const y = Math.sin(angle);
                const noiseVal = noise((x + 1) * noiseFrequency, (y + 1) * noiseFrequency, blob.time * noiseSpeed);
                
                // Use the animated scale to calculate the radius for this frame
                const radius = blob.radius * effectiveScale + (noiseVal * blob.radius * 0.3);

                const pointX = x * radius;
                const pointY = y * radius;
                if (i === 0) context.moveTo(pointX, pointY);
                else context.lineTo(pointX, pointY);
            }
            context.closePath();
            context.clip();
            
            // The liquid strip effect (unchanged)
            const totalWarp = blob.baseWarp + Math.sin(blob.time * 0.1) * (blob.baseWarp * 0.5);
            const numStrips = 30;
            const stripWidth = (blob.radius * 2 * effectiveScale) / numStrips; // Use effectiveScale here too
            for (let i = 0; i < numStrips; i++) {
                const stripX = -blob.radius * effectiveScale + i * stripWidth;
                const sinInput = (i / numStrips) * Math.PI + blob.time * 0.1;
                const yOffset = Math.sin(sinInput) * totalWarp;
                
                context.drawImage(
                    imageToDraw,
                    blob.sourceX + (blob.sourceSize / numStrips) * i, blob.sourceY,
                    blob.sourceSize / numStrips, blob.sourceSize,
                    stripX, -blob.radius * effectiveScale + yOffset,
                    stripWidth + 1, blob.radius * 2 * effectiveScale
                );
            }

            context.restore();
        }

        /**
         * The animation loop, now featuring a global canvas distortion on beat
         * and passing the beat intensity down to each blob for synchronized animation.
         */
        function animateCanvas() {
            animationFrameId = requestAnimationFrame(animateCanvas);
            if (!ctx) return;
            
            const { width: canvasWidth, height: canvasHeight } = distortionCanvas;
            
            ctx.clearRect(0, 0, canvasWidth, canvasHeight);

            // --- Beat Effect Logic ---
            const BEAT_DECAY_SPEED = 0.95; // Controls how fast the effect fades out (closer to 1 is slower)

            // If a beat is active, smoothly decay the intensity on every frame.
            if (beatIntensity > 0.001) {
                beatIntensity *= BEAT_DECAY_SPEED;
            } else {
                beatIntensity = 0; // Clamp to zero to prevent tiny residual values
            }

            // --- Background Rotation and Drawing (Unchanged) ---
            backgroundRotation += 0.002;
            if (isTransitioning) {
                transitionProgress += 1 / TRANSITION_DURATION;
                if (transitionProgress >= 1) {
                    transitionProgress = 1; isTransitioning = false; oldResizedArt = new Image();
                }
            }
            const drawRotatingBackground = (image) => {
                const scale = 1.5; // Draw larger to prevent corners from appearing during rotation
                ctx.save();
                ctx.translate(canvasWidth / 2, canvasHeight / 2);
                ctx.rotate(backgroundRotation);
                ctx.drawImage(image, 
                    -canvasWidth * scale / 2, -canvasHeight * scale / 2, 
                    canvasWidth * scale, canvasHeight * scale
                );
                ctx.restore();
            };
            if (isTransitioning && oldResizedArt.complete && oldResizedArt.src) {
                ctx.globalAlpha = 1 - transitionProgress;
                drawRotatingBackground(oldResizedArt);
            }
            if (currentResizedArt.complete && currentResizedArt.src) {
                ctx.globalAlpha = isTransitioning ? transitionProgress : 1;
                drawRotatingBackground(currentResizedArt);
            }
            ctx.globalAlpha = 1;
            
            // --- Update and Draw Blobs ---
            blobs.forEach(blob => {
                // Blob movement logic is unchanged
                blob.x += blob.vx;
                blob.y += blob.vy;
                blob.rotation += blob.rotationSpeed;
                const radius = blob.radius * (1 + beatIntensity * 0.1); // Use an effective radius for wrapping
                if (blob.x - radius > canvasWidth) { blob.x = -radius; } 
                else if (blob.x + radius < 0) { blob.x = canvasWidth + radius; }
                if (blob.y - radius > canvasHeight) { blob.y = -radius; } 
                else if (blob.y + radius < 0) { blob.y = canvasHeight + radius; }

                blob.time += 0.1;

                // --- Draw Blobs with Transition and Beat Intensity ---
                // Pass the decaying `beatIntensity` to the drawing function
                if (isTransitioning && oldResizedArt.complete && oldResizedArt.src) {
                    ctx.globalAlpha = 1 - transitionProgress;
                    drawOrganicBlob(ctx, blob, oldResizedArt, beatIntensity);
                }
                if (currentResizedArt.complete && currentResizedArt.src) {
                    ctx.globalAlpha = isTransitioning ? transitionProgress : 1;
                    drawOrganicBlob(ctx, blob, currentResizedArt, beatIntensity);
                }
                ctx.globalAlpha = 1;
            });

            // 3. If a beat was active, restore the canvas from the global distortion.
            if (beatIntensity > 0.001) {
                ctx.restore();
            }
        }
        
        /**
         * Triggers the global beat effect by setting the intensity to its maximum.
         * The animateCanvas function will handle the decay and animation.
         */
        function triggerBeatEffect() {
            beatIntensity = 1;
        }
        
async function createResizedImageURL(imageUrl, width, height) {
    return new Promise((resolve, reject) => {
        const img = new Image();
        if (!imageUrl.startsWith('data:')) {
            img.crossOrigin = 'Anonymous';
        }
        
        img.onload = () => {
            const canvas = document.createElement('canvas');
            canvas.width = width;
            canvas.height = height;
            const ctx = canvas.getContext('2d');
            ctx.drawImage(img, 0, 0, width, height);
            resolve(canvas.toDataURL('image/jpeg', 0.8)); 
        };
        
        img.onerror = (err) => {
            console.error("Failed to load image for resizing.", err);
            reject(imageUrl); 
        };
        
        img.src = imageUrl;
    });
}

async function updateAllBackgrounds(imageUrl) {
    loadAlbumArtForCanvas(imageUrl);
}

class BeatDetector {
    constructor(frequencyBands, historySize = 60, minThreshold = 5) {
        this.frequencyBands = frequencyBands;
        this.historySize = historySize;
        this.minFluxThreshold = minThreshold;
        this.fluxHistories = this.frequencyBands.map(() => []);
        this.lastEnergies = new Array(this.frequencyBands.length).fill(0);
        this.beatValue = 0.0;
        this.decayRate = 0.96;
        this.dynamicSensitivity = 1.4;
        this.minSensitivity = 1.2;
        this.maxSensitivity = 2.4;
        this.increaseFactor = 1.05;
        this.decreaseFactor = 0.999;
    }

    _calculateStandardDeviation(array, mean) {
        if (array.length < 2) return 0;
        const variance = array.reduce((acc, val) => acc + (val - mean) ** 2, 0) / array.length;
        return Math.sqrt(variance);
    }

    update(dataArray) {
        let beatDetectedThisFrame = false;

        for (let i = 0; i < this.frequencyBands.length; i++) {
            const band = this.frequencyBands[i];
            const history = this.fluxHistories[i];
            
            let currentEnergy = 0;
            for (let j = band[0]; j <= band[1]; j++) currentEnergy += dataArray[j];
            currentEnergy /= (band[1] - band[0] + 1);

            const flux = Math.max(0, currentEnergy - this.lastEnergies[i]);
            this.lastEnergies[i] = currentEnergy;

            if (history.length < this.historySize) {
                history.push(flux);
                continue;
            }
            
            const averageFlux = history.reduce((a, b) => a + b, 0) / history.length;
            const stdDev = this._calculateStandardDeviation(history, averageFlux);
            const dynamicThreshold = averageFlux + (this.dynamicSensitivity * stdDev);

            if (flux > dynamicThreshold && flux > this.minFluxThreshold) {
                beatDetectedThisFrame = true;
            }

            history.push(flux);
            history.shift();
        }

        if (beatDetectedThisFrame) {
            this.beatValue = 1.0;
            this.dynamicSensitivity *= this.increaseFactor;
        } else {
            this.beatValue *= this.decayRate;
            this.dynamicSensitivity *= this.decreaseFactor;
        }
        
        this.dynamicSensitivity = Math.max(this.minSensitivity, Math.min(this.maxSensitivity, this.dynamicSensitivity));
        return this.beatValue;
    }
}

function initVisualizer() {
    if (document.body.classList.contains('reduce-animations')) {
        const canvas = document.getElementById('visualizerCanvas');
        if (canvas) canvas.style.display = 'none';
        return; 
    }

    if (isVisualizerInitialized) return;

    try {
        audioContext = new (window.AudioContext || window.webkitAudioContext)();
        
        eqBass = audioContext.createBiquadFilter();
        eqMid = audioContext.createBiquadFilter();
        eqTreble = audioContext.createBiquadFilter();
        eqBass.type = 'lowshelf'; eqBass.frequency.value = 300; 
        eqMid.type = 'peaking'; eqMid.frequency.value = 1000; eqMid.Q.value = 1; 
        eqTreble.type = 'highshelf'; eqTreble.frequency.value = 3000;
        
        analyser = audioContext.createAnalyser();
        
        source = audioContext.createMediaElementSource(audioPlayer);

        source.connect(eqBass);
        eqBass.connect(eqMid);
        eqMid.connect(eqTreble);
        eqTreble.connect(analyser);
        analyser.connect(audioContext.destination);

        if (isMobile) {
            analyser.fftSize = 64;
        } else {
            analyser.fftSize = 2048;
        }
        
        analyser.smoothingTimeConstant = 0.8;
        const bufferLength = analyser.frequencyBinCount;
        const dataArray = new Uint8Array(bufferLength);
        
        const displacementFilter = document.getElementById('displacement');
        const turbulenceFilter = document.getElementById('turbulence');

        const baselineDistortion = 80;
        const peakDistortion = 250;

        let beatDetector;
        if (!isMobile) {
            beatDetector = new BeatDetector([[0, 10], [20, 50], [80, 120]]);
        }
        
        const canvas = document.getElementById('visualizerCanvas');
        const canvasCtx = canvas.getContext('2d');
        
        // Define separate bar indices for desktop and mobile to match their FFT sizes.
        const desktopBarIndices = [5, 10, 30, 100, 200, 400];
        const mobileBarIndices = [1, 3, 6, 12, 20, 28]; // Mapped to a 32-bin array
        const numBars = 6;
        
        const sensitivityMultipliers = [1, 1.05, 1.1, 1.15, 1.25, 1.4];
        const powerCurve = 2.2;
        
        let smoothedPulse = 0.0; 
        const smoothingFactor = 0.2;

        visualizerDraw = () => {
            visualizerFrameId = requestAnimationFrame(visualizerDraw);
            analyser.getByteFrequencyData(dataArray);

            if (!isMobile) {
                const beatPulseTarget = beatDetector.update(dataArray);
                
                // --- Beat Detection Integration ---
                // If the beat detector returns a strong pulse, trigger our canvas effect.
                if(beatPulseTarget > 0.9) { // 0.9 is a good threshold for a clear beat
                    triggerBeatEffect();
                }

                smoothedPulse += (beatPulseTarget - smoothedPulse) * smoothingFactor;
            }
            
            if (canvas.width !== canvas.clientWidth) canvas.width = canvas.clientWidth;
            if (canvas.height !== canvas.clientHeight) canvas.height = canvas.clientHeight;
            canvasCtx.clearRect(0, 0, canvas.width, canvas.height);
            
            const gap = 2;
            const barWidth = (canvas.width - (numBars - 1) * gap) / numBars;
            const style = getComputedStyle(document.body);
            const textColor = style.getPropertyValue('--text-color').trim() || '#FFFFFF';
            canvasCtx.fillStyle = textColor;

            const indicesToUse = isMobile ? mobileBarIndices : desktopBarIndices;

            for (let i = 0; i < numBars; i++) {
                const x = i * (barWidth + gap);
                const value = Math.min(dataArray[indicesToUse[i]] * sensitivityMultipliers[i], 255);
                const barHeight = Math.pow(value / 255, powerCurve) * canvas.height;
                
                const pillRadius = Math.max(0, barWidth / 2);
                if (barHeight < pillRadius * 2) {
                    const dotRadius = barHeight / 2;
                    if (dotRadius < 1) continue;
                    canvasCtx.globalAlpha = barHeight / (pillRadius * 2);
                    canvasCtx.beginPath();
                    canvasCtx.arc(x + pillRadius, canvas.height / 2, dotRadius, 0, 2 * Math.PI);
                    canvasCtx.fill();
                } else {
                    const y = (canvas.height - barHeight) / 2;
                    canvasCtx.globalAlpha = 1.0;
                    canvasCtx.beginPath();
                    if (canvasCtx.roundRect) {
                        canvasCtx.roundRect(x, y, barWidth, barHeight, pillRadius);
                    } else { // Fallback
                        canvasCtx.rect(x, y, barWidth, barHeight);
                    }
                    canvasCtx.fill();
                }
            }
            canvasCtx.globalAlpha = 1.0;
        }

        isVisualizerInitialized = true;

    } catch(e) {
        console.error("Failed to initialize AudioContext/Visualizer:", e);
    }
}

function processAndSortSongs() {
    const songsByAlbum = songs.reduce((acc, song) => {
        const albumArtistKey = song.albumArtist || 'Unknown Artist';
        const albumKey = `${albumArtistKey}::${song.album || 'Unknown Album'}`;
        if (!acc[albumKey]) acc[albumKey] = [];
        acc[albumKey].push(song);
        return acc;
    }, {});

    for (const albumKey in songsByAlbum) {
        const albumSongs = songsByAlbum[albumKey];
        albumSongs.sort((a, b) => (a.handleName || a.name).localeCompare(b.handleName || b.name));

        let inferredDisc = 1;
        let lastTrack = 0;
        
        albumSongs.forEach(song => {
            if (song.trackNumber !== null && song.trackNumber < lastTrack) {
                inferredDisc++;
            }
            song.effectiveDiscNumber = song.discNumber || inferredDisc;
            lastTrack = song.trackNumber || 0;
        });
    }
}

async function getArtColors(imageUrl) {
    return new Promise((resolve) => {
        const img = new Image();
        img.crossOrigin = 'Anonymous';
        img.src = imageUrl;
        img.onload = () => {
            const canvas = document.createElement('canvas');
            canvas.width = img.width;
            canvas.height = img.height;
            const ctx = canvas.getContext('2d', { willReadFrequently: true });
            ctx.drawImage(img, 0, 0);
            
            // Get colors from top-left and bottom-right for a simple gradient
            const topLeft = ctx.getImageData(0, 0, 1, 1).data;
            const bottomRight = ctx.getImageData(img.width - 1, img.height - 1, 1, 1).data;

            const color1 = `rgba(${topLeft[0]}, ${topLeft[1]}, ${topLeft[2]}, 0.4)`;
            const color2 = `rgba(${bottomRight[0]}, ${bottomRight[1]}, ${bottomRight[2]}, 0.1)`;
            resolve(`linear-gradient(135deg, ${color1}, ${color2})`);
        };
        img.onerror = () => {
            // Fallback for failed image loads
            resolve('linear-gradient(135deg, rgba(255,255,255,0.1), rgba(255,255,255,0))');
        };
    });
}

async function renderHomePage() {
    const homeView = document.getElementById('home-view');
    if (!homeView) return;

    // --- 1. Fetch all necessary data asynchronously ---
    const topSongsPromise = new Promise(resolve => {
        const tx = db.transaction('songs', 'readonly');
        const index = tx.objectStore('songs').index('playCount');
        const req = index.getAll();
        req.onsuccess = () => resolve(req.result.sort((a,b) => (b.playCount || 0) - (a.playCount || 0)).slice(0, 10));
    });

    const historyPromise = new Promise(resolve => {
        const tx = db.transaction('playHistory', 'readonly');
        const store = tx.objectStore('playHistory');
        const req = store.getAll();
        req.onsuccess = () => resolve(req.result.sort((a,b) => b.timestamp - a.timestamp));
    });

    const [topSongs, history] = await Promise.all([topSongsPromise, historyPromise]);
    // --- 2. Select 4 unique songs for the highlights ---
    
    const highlightSongs = new Set();
    const listenAgainSongs = [];
    if (topSongs.length > 0) {
        listenAgainIndex = (listenAgainIndex + 1) % Math.min(topSongs.length, 10);
        localStorage.setItem('listenAgainIndex', listenAgainIndex);
        listenAgainSongs.push(topSongs[listenAgainIndex]);
        if (topSongs.length > 1) {
            listenAgainSongs.push(topSongs[(listenAgainIndex + 1) % topSongs.length]);
        }
        if (topSongs.length > 2) {
            listenAgainSongs.push(topSongs[(listenAgainIndex + 2) % topSongs.length]);
        }
        if (topSongs.length > 3) {
            listenAgainSongs.push(topSongs[(listenAgainIndex + 3) % topSongs.length]);
        }
    }
    listenAgainSongs.forEach(s => highlightSongs.add(s));

    const recommendations = songs.filter(s => !listenAgainSongs.some(ls => ls.id === s.id));
    for (let i = 0; i < 4 && recommendations.length > 0; i++) {
        const randomIndex = Math.floor(Math.random() * recommendations.length);
        highlightSongs.add(recommendations.splice(randomIndex, 1)[0]);
    }
    
    // --- 3. Build the HTML ---
    const highlights = Array.from(highlightSongs);
    const highlightsHtml = highlights.map((song, i) => {
        const isListenAgain = listenAgainSongs.includes(song);
        return `
        <div class="highlight-card" data-id="${song.id}" id="highlight-${i+1}">
            <img src="${song.albumArt}">
            <div class="highlight-card-info">
                <div class="highlight-card-label">${isListenAgain ? 'Listen Again' : 'From Your Library'}</div>
                <div class="highlight-card-title">${sanitize(song.name)}</div>
                <div class="highlight-card-subtitle">${sanitize(song.artist)}</div>
            </div>
            <span class="material-symbols-rounded highlight-card-play">play_circle</span>
        </div>`;
    }).join('');

    const recentSongIds = [...new Set(history.map(h => h.songId))];
    const recentlyPlayedSongs = recentSongIds.map(id => songs.find(s => s.id === id)).filter(Boolean);
    const recentAlbums = [];
    const recentAlbumIds = new Set();
    for (const song of recentlyPlayedSongs) {
        const albumId = `${song.albumArtist}::${song.album}`;
        if (!recentAlbumIds.has(albumId)) {
            recentAlbumIds.add(albumId);
            recentAlbums.push(song); // Use the song object as a representative for the album
        }
        if (recentAlbums.length >= 40) break; // Limit to 40 albums
    }
    const recentlyPlayedHtml = recentAlbums.map(song => `
         <div class="item-card" data-album-id="${sanitize(song.albumArtist)}::${sanitize(song.album)}">
            <img src="${song.albumArt}" class="item-card-art">
            <div class="item-card-info">
                <div class="item-card-title">${sanitize(song.album)}</div>
                <div class="item-card-subtitle">${sanitize(song.albumArtist)}</div>
            </div>
        </div>
    `).join('');
    
    const genres = [...new Set(songs.map(s => s.genre).filter(Boolean))];
    const genreSectionsHtml = genres.map(genre => {
        const genreSongs = songs.filter(s => s.genre === genre).slice(0, 8);
        return `
        <div>
            <h2 class="section-title">${sanitize(genre)}</h2>
            <div class="item-grid">${genreSongs.map(song => `
                <div class="item-card" data-album-id="${sanitize(song.albumArtist)}::${sanitize(song.album)}">
                    <img src="${song.albumArt}" class="item-card-art">
                    <div class="item-card-info">
                        <div class="item-card-title">${sanitize(song.album)}</div>
                        <div class="item-card-subtitle">${sanitize(song.albumArtist)}</div>
                    </div>
                </div>
            `).join('')}</div> 
        </div>`;
    }).join('');

    // --- GuraAI Section (Now renders a placeholder INSTANTLY) ---
    let aiPromptAreaHtml = '';
    if (isGuraAiEnabled && musicAiModel && songs.length > 5) {
        aiPromptAreaHtml = `
            <div id="ai-prompt-area" style="text-align:center; margin-bottom: 20px;">
                <div id="ai-prompt-bar" style="display:flex; gap:10px; max-width:600px; margin: auto auto 20px; border-bottom: 1px solid var(--search-background); padding-bottom: 10px;">
                    <input type="text" id="aiPromptInput" placeholder="Ask GuraAI" class="library-search-input" style="padding-left:15px;background: none;border: none;font-size: large;font-weight: bold;">
                    <button id="aiPromptSubmit" class="action-btn" style="height:auto; background: none; border: none;"><span class="material-symbols-rounded" style="font-size: 18px;">send</span></button>
                </div>
                <div id="ai-dynamic-prompts" style="display:flex; flex-wrap:wrap; justify-content:center; gap:10px"></div>
            </div>
        `;
    }

    homeView.innerHTML = `
    <div class="page-content-wrapper">
        ${aiPromptAreaHtml}
        <div class="highlight-grid">${highlightsHtml}</div>
        <div>
            <h2 class="section-title">Recently Played</h2>
            <div class="item-grid">${recentlyPlayedHtml}</div>
        </div>
        ${genreSectionsHtml}
    </div>`;
    
    // --- 4. Asynchronously Apply Gradients ---
    highlights.forEach((song, i) => {
        const card = document.getElementById(`highlight-${i+1}`);
        if (card) {
            getArtColors(song.albumArt).then(gradient => { card.style.background = gradient; });
        }
    });
    
    // --- Asynchronously update AI content ---
    // After the main page has rendered, call the function to fetch and populate AI prompts.
    // We DON'T await this, allowing the UI to be responsive while the AI works.
    if (isGuraAiEnabled && musicAiModel && songs.length > 5) {
        updateAiHomePagePrompts();
    }

    requestAnimationFrame(() => {
        const homeView = document.getElementById('home-view');
        homeView.scrollTop = scrollPositions.home;
    });
}

async function updateAiHomePagePrompts() {
    const promptsContainer = document.getElementById('ai-dynamic-prompts');
    if (!promptsContainer) return;

    promptsContainer.innerHTML = `<button class="action-btn" data-prompt="Create a high-energy playlist">High-energy Playlist</button><button class="action-btn" data-prompt="Find some relaxing songs">Relaxing Songs</button><button class="action-btn" data-prompt="Recommend a genre I might like">Suggest a Genre</button>`;

    let dynamicPromptsHtml = '';
    try {
        // A slightly stronger prompt encouraging the correct format
        const prompt = `Based on the user's library, suggest 3 short, action-oriented prompts for buttons to help them discover music. YOU MUST format your response by calling the 'createPlaylist' function and putting the 3 prompts inside the 'songs' array.

        Library Sample:\n${formatSongsForAiPrompt(songs.slice(0, 50))}`;
        
        const result = await musicAiModel.generateContent(prompt);
        const response = result.response;
        const call = response.functionCalls()?.[0];
        let promptIdeas = [];

        // --- THE FIX: Intelligent Fallback Logic ---
        if (call && call.name === 'createPlaylist' && call.args.songs) {
            // Path 1: The AI worked perfectly and used the function tool.
            console.log("AI responded with a function call.");
            promptIdeas = call.args.songs.slice(0, 3);
        } else {
            // Path 2: The AI responded with plain text. We will parse it.
            console.log("AI responded with plain text, parsing fallback.");
            const textResponse = response.text();
            if (textResponse) {
                // Parse a string like: "Prompt 1", "Prompt 2", "Prompt 3"
                promptIdeas = textResponse.split(',') // Split by comma
                                        .map(p => p.trim().replace(/"/g, '')) // Remove whitespace and quotes
                                        .filter(p => p.length > 5) // Filter out any empty strings
                                        .slice(0, 3);
            }
        }

        if (promptIdeas.length > 0) {
            dynamicPromptsHtml = promptIdeas.map(p => `<button class="action-btn" data-prompt="${sanitize(p)}">${sanitize(p)}</button>`).join('');
        } else {
            // This now only runs if both the function call AND text parsing fail.
            throw new Error("AI did not return any valid prompts in any format.");
        }
    } catch (e) {
        console.error("AI dynamic prompt generation failed:", e);
        // On error, provide useful static fallback prompts
        dynamicPromptsHtml = `<button class="action-btn" data-prompt="Create a high-energy playlist">High-energy Playlist</button><button class="action-btn" data-prompt="Find some relaxing songs">Relaxing Songs</button><button class="action-btn" data-prompt="Recommend a genre I might like">Suggest a Genre</button>`;
    }

    // Update the container with the final HTML (either from AI or fallback)
    promptsContainer.innerHTML = dynamicPromptsHtml;
}

function renderLibraryPage() {
    const libraryView = document.getElementById('library-view');
    const libraryGrid = document.getElementById('library-grid');
    if (!libraryGrid) return;

    // --- RENDER MAIN LIBRARY VIEW ---
    const searchFilteredSongs = songs; // No search bar here anymore

    if (searchFilteredSongs.length === 0) {
        libraryGrid.innerHTML = `<div class="no-results" style="grid-column: 1 / -1;"><span class="material-symbols-rounded">library_music</span><p>Your library is empty.</p><p style="font-size: 0.8em; color: var(--secondary-text-color);">Click "Add Music" to get started.</p></div>`;
        return;
    }
    
    let itemsHtml = ''; // Declare itemsHtml here

    switch (currentFilter) {
        case 'artists':
            libraryGrid.className = 'item-grid';
            const artistsMap = new Map();
            searchFilteredSongs.forEach(song => {
                const artist = song.artist || 'Unknown Artist';
                if (!artistsMap.has(artist)) {
                    artistsMap.set(artist, song.albumArt);
                }
            });
            let artistsList = Array.from(artistsMap.entries());
            if (currentSortMode === 'alpha') artistsList.sort((a, b) => a[0].localeCompare(b[0]));
            
            itemsHtml = artistsList.map(([artist, art]) => `
                <div class="item-card" data-artist-name="${artist}">
                    <img src="${art || generateRandomGradient()}" alt="${artist}" class="item-card-art" style="border-radius: 50%;">
                    <div class="item-card-info" style="text-align: center;">
                        <div class="item-card-title">${sanitize(artist)}</div>
                    </div>
                </div>`).join('');
            break;
        
        case 'songs':
            libraryGrid.className = 'item-list'; // Enforce list view
            const sortedSongs = [...searchFilteredSongs]; // Create a copy to sort
             if (currentSortMode === 'alpha') searchFilteredSongs.sort((a,b) => a.name.localeCompare(b.name));
             else searchFilteredSongs.sort((a,b) => b.dateAdded - a.dateAdded);

            itemsHtml = searchFilteredSongs.map(song => `
                <div class="music-item" data-id="${song.id}" style="cursor: pointer;">
                     <div class="song-info">
                        <img src="${song.albumArt}" class="album-thumbnail" style="width: 40px; height: 40px; border-radius: 8px; margin-right: 6px;">
                        <div>
                            <div class="song-title" style="white-space: normal;">${sanitize(song.name)}</div>
                            <div class="album-artist" style="font-size: 0.8em;">${sanitize(song.artist)}</div>
                        </div>
                    </div>
                </div>
            `).join('');
            break;

        case 'playlists':
            libraryGrid.className = 'item-grid';
            
            // Generate the HTML for the user's existing playlists first
            itemsHtml = playlists.map(p => {
                const playlistSongs = p.songIds.map(id => songs.find(s => s.id === id)).filter(Boolean);
                const art = playlistSongs.length > 0 ? playlistSongs[0].albumArt : generateRandomGradient();
                return `
                <div class="item-card" data-playlist-id="${p.id}">
                    <img src="${art}" alt="${p.name}" class="item-card-art">
                    <div class="item-card-info">
                        <div class="item-card-title">${sanitize(p.name)}</div>
                        <div class="item-card-subtitle">${playlistSongs.length} songs</div>
                    </div>
                </div>`;
            }).join('');
        
            // Now, generate the AI creator section ONLY if AI is enabled
            if (isGuraAiEnabled && musicAiModel) {
                const aiPlaylistSection = `
                    <div id="ai-playlist-creator" style="grid-column: 1 / -1; margin: 20px auto 0 auto; max-width: 600px; text-align: center;">
                        <div style="display: flex; gap: 10px;">
                            <input type="text" id="aiPlaylistPrompt" placeholder="Create a Playlist with GuraAI" class="library-search-input" style="padding-left: 15px;">
                            <button id="aiCreatePlaylistBtn" class="action-btn" style="height: auto;"><span class="material-symbols-rounded" style="font-size: 18px;">add</span></button>
                        </div>
                    </div>
                `;
                // Append the AI section to the end of the playlists HTML
                itemsHtml += aiPlaylistSection;
            }
            break;

        case 'albums':
        default:
            libraryGrid.className = 'item-grid'; // Enforce grid view
            const albums = groupSongsByAlbum(searchFilteredSongs);
            itemsHtml = albums.map(album => {
                const albumId = `${album.artist}::${album.originalAlbum}`;
                return `
                <div class="item-card" data-album-id="${albumId}">
                    <img src="${album.albumArt}" alt="${album.name}" class="item-card-art">
                    <div class="item-card-info">
                        <div class="item-card-title">${sanitize(album.name)}</div>
                        <div class="item-card-subtitle">${sanitize(album.artist)}</div>
                    </div>
                </div>`;
            }).join('');
            break;
    }
    
    libraryGrid.innerHTML = itemsHtml;
    
    // --- SCROLL RESTORATION LOGIC ---
    requestAnimationFrame(() => {
        const libraryView = document.getElementById('library-view');
        libraryView.scrollTop = scrollPositions.library;
    });
}
        
function renderPlaylists() {
    const musicListContainer = document.querySelector('.music-list');
    musicListContainer.innerHTML = ''; 

    if (playlists.length === 0) {
        musicListContainer.innerHTML = '<div class="no-results"><span class="material-symbols-rounded">playlist_add</span><p>No playlists to add to</p><p style="font-size: 0.8em; color: var(--secondary-text-color);">Create one from the "More Options" menu while a song is playing.</p></div>';
        return;
    }

    playlists.forEach(playlist => {
        const playlistSongs = playlist.songIds.map(id => songs.find(s => s.id === id)).filter(Boolean);
        const albumArt = playlistSongs.length > 0 ? playlistSongs[0].albumArt : generateRandomGradient();
        
        const item = document.createElement('div');
        item.className = 'music-item';
        item.style.position = 'relative'; 
        item.innerHTML = `
            <div class="song-info">
                <img src="${albumArt}" class="album-thumbnail" style="width: 40px; height: 40px; border-radius: 8px; margin-right: 5px;">
                <div>
                    <div class="song-title" style="font-size: 1em; margin-bottom: 2px; white-space: normal;">${playlist.name}</div>
                    <div class="album-artist" style="font-size: 0.8em;">${playlistSongs.length} songs</div>
                </div>
            </div>
            <button class="remove-from-queue-btn" onclick="deletePlaylist(${playlist.id}, event)" style="position: absolute; right: 10px; top: 50%; transform: translateY(-50%);">
                <span class="material-symbols-rounded" style="font-size: 14px;">cancel</span>
            </button>`;
        
        item.addEventListener('click', (e) => {
            if (e.target.closest('button')) return; 
            renderPlaylistSongs(playlist.id);
        });

        musicListContainer.appendChild(item);
    });
}

function renderPlaylistSongs(playlistId) {
    activePlaylistId = playlistId;
    const playlist = playlists.find(p => p.id === playlistId);
    if (!playlist) return;

    const musicListContainer = document.querySelector('.music-list');
    musicListContainer.innerHTML = '';

    const playlistSongs = playlist.songIds.map(id => songs.find(s => s.id === id)).filter(Boolean);

    if (playlistSongs.length === 0) {
        musicListContainer.insertAdjacentHTML('beforeend', '<div class="no-results"><p>This playlist is empty.</p></div>');
        return;
    }

    const songsHtml = playlistSongs.map(song => `
        <div class="music-item ${song.id === currentSongId ? "active" : ""}" data-id="${song.id}">
            <div class="song-info">
                <img src="${song.albumArt}" class="album-thumbnail" style="width: 40px; height: 40px; border-radius: 8px; margin-right: 5px;">
                <div>
                    <div class="song-title" style="font-size: 1em; margin-bottom: 2px; white-space: normal;">${song.name}</div>
                    <div class="album-artist" style="font-size: 0.8em;">${sanitize(song.artist)}</div>
                </div>
                <button class="remove-from-queue-btn" onclick="removeSongFromPlaylist(${song.id}, ${playlist.id}, event)" style="margin-left: auto;">
                    <span class="material-symbols-rounded" style="font-size: 14px;">cancel</span>
                </button>
            </div>
        </div>
    `).join('');

    musicListContainer.insertAdjacentHTML('beforeend', songsHtml);
    
    musicListContainer.querySelectorAll('.music-item').forEach(item => {
        item.addEventListener('click', (e) => {
            if (e.target.closest('button')) return;
            const songId = parseFloat(item.dataset.id);
            const songToPlay = songs.find(s => s.id === songId);
            if (songToPlay) playSong(songToPlay);
        });
    });
}
        
async function deletePlaylist(playlistId) {
    const playlist = playlists.find(p => p.id === playlistId);
    if (!playlist) return;

    if (confirm(`Are you sure you want to permanently delete the playlist "${playlist.name}"?`)) {
        // 1. Remove the playlist from the in-memory array.
        playlists = playlists.filter(p => p.id !== playlistId);

        // 2. Remove the playlist from the IndexedDB database.
        const tx = db.transaction('playlists', 'readwrite');
        tx.objectStore('playlists').delete(playlistId);
        await tx.done;

        // 3. Close the drawer, as its content is now invalid.
        closeDrawer();

        // 4. Notify the user and refresh the library view.
        Gurasuraisu.showPopup(`Playlist "${playlist.name}" deleted`);
        if (activeView === 'library') {
            renderLibraryPage(); 
        }
    }
}

async function removeSongFromPlaylist(songId, playlistId, event) {
    event.stopPropagation();
    const playlist = playlists.find(p => p.id === playlistId);
    const song = songs.find(s => s.id === songId);
    if (!playlist || !song) return;

    playlist.songIds = playlist.songIds.filter(id => id !== songId);

    const tx = db.transaction('playlists', 'readwrite');
    tx.objectStore('playlists').put(playlist);
    await tx.done;
    
    showPopupMessage(`Removed "${song.name}" from "${playlist.name}"`);
    renderPlaylistSongs(playlistId);
}
        
function renderSongs(albums, isArtistView = false) {
  const musicListContainer = document.querySelector('.music-list');
  
  if (!albums || albums.length === 0) {
    musicListContainer.innerHTML = '<div class="no-results"><span class="material-symbols-rounded">search_off</span><p>No songs found</p></div>';
    return;
  }
  
  musicListContainer.innerHTML = albums.map(album => `
    <div class="album-section" 
         data-album-artist="${album.artist}" 
         data-album-name="${album.originalAlbum}">
      <div class="album-header">
        <img src="${album.albumArt}" alt="${album.name}" class="album-thumbnail">
        <div class="album-info">
          <div class="album-name">${album.name}</div>
          ${isArtistView ? '' : `<div class="album-artist">${album.artist}</div>`}
          <div class="album-year">${album.year}</div>
        </div>
      </div>
      <div class="album-songs">
        ${album.songs.map(song => `
          <div class="music-item ${song.id === currentSongId ? "active" : ""}" data-id="${song.id}">
            <div class="song-info">
              <span class="track-number">${song.trackNumber ? song.trackNumber + "." : ""}</span>
              <span class="song-title">${song.name}</span>
            </div>
          </div>
        `).join("")}
      </div>
    </div>
  `).join("");
  
  attachSongAndAlbumEventListeners();
}

function renderSongsAsList(songsToRender) {
    const musicListContainer = document.querySelector('.music-list');
    musicListContainer.innerHTML = songsToRender.map(song => `
        <div class="music-item ${song.id === currentSongId ? "active" : ""}" data-id="${song.id}">
            <div class="song-info">
                <img src="${song.albumArt}" class="album-thumbnail" style="width: 40px; height: 40px; border-radius: 8px; margin-right: 5px;">
                <div>
                    <div class="song-title" style="font-size: 1em; margin-bottom: 2px;">${song.name}</div>
                    <div class="album-artist" style="font-size: 0.8em;">${sanitize(song.artist)}</div>
                </div>
            </div>
        </div>
    `).join('');
    attachSongAndAlbumEventListeners();
}
        
async function renderLyrics() {
    const lyricsQueuePanel = document.getElementById('lyrics-queue-panel');
    if (!lyricsQueuePanel) return;

    const lyricsContainer = lyricsQueuePanel.querySelector('.lyrics-container') || 
                            (() => {
                                lyricsQueuePanel.innerHTML = `<div class="lyrics-container" id="lyrics-scroll-container"></div>`;
                                return lyricsQueuePanel.querySelector('.lyrics-container');
                            })();

    if (!currentSongId) {
        lyricsContainer.innerHTML = `<p style="opacity: 1; filter: none;">No song is currently playing.</p>`;
        return;
    }
    
    const song = currentlyPlayingSong;

    if (song.lyrics) {
        // Lyrics already exist, so display them
        if (song.lrcData && song.lrcData.length > 0) {
            lyricsContainer.innerHTML = song.lrcData.map((line, index) => 
                `<p id="lyric-line-${index}" data-time="${line.time}">${line.text || '  '}</p>`
            ).join('');
            lyricsContainer.querySelectorAll('p').forEach(lineEl => {
                lineEl.addEventListener('click', () => {
                    const seekTime = parseFloat(lineEl.dataset.time);
                    if (!isNaN(seekTime)) audioPlayer.currentTime = seekTime;
                });
            });
        } else {
            lyricsContainer.innerHTML = `<p style="opacity: 1; filter: none; white-space: pre-wrap;">${song.lyrics}</p>`;
        }
        return;
    }

    if (isLrclibEnabled) {
        lyricsContainer.innerHTML = `<div class="loading-message"><svg width="24" height="24" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg" style="color: var(--text-color);"><style>.spinner_V8m1{transform-origin:center;animation:spinner_zKoa 2s linear infinite}.spinner_V8m1 circle{stroke-linecap:round;animation:spinner_YpZS 1.5s ease-in-out infinite}@keyframes spinner_zKoa{100%{transform:rotate(360deg)}}@keyframes spinner_YpZS{0%{stroke-dasharray:0 150;stroke-dashoffset:0}47.5%{stroke-dasharray:42 150;stroke-dashoffset:-16}95%,100%{stroke-dasharray:42 150;stroke-dashoffset:-59}}</style><g class="spinner_V8m1"><circle cx="12" cy="12" r="9.5" fill="none" stroke-width="3"></circle></g></svg></div>`;
        const fetchedLyrics = await fetchLyricsFromLrclib(song);

        if (fetchedLyrics) {
            song.lyrics = fetchedLyrics.content;
            if (fetchedLyrics.type === 'lrc') song.lrcData = parseLRC(fetchedLyrics.content);
            
            if (song.storage === 'soundcloud') await updateSoundcloudCacheWithLyrics(song);
            else await saveSongs();
            
            renderLyrics(); // Re-run to display
        } else {
            // Automatic search failed, provide manual option
            lyricsContainer.innerHTML = `
                <div class="no-results">
                    <p>No lyrics found automatically.</p>
                    <button id="manual-search-trigger" class="goto-btn">Search Manually</button>
                </div>`;
            document.getElementById('manual-search-trigger').addEventListener('click', () => {
                const cleaned = cleanMetadataForLyricsSearch(song);
                document.getElementById('manualLyricsSearchInput').value = `${cleaned.artist} - ${cleaned.name}`;
                document.getElementById('manualLyricsResults').innerHTML = ''; // Clear old results
                openModal(manualLyricsSearchModal);
            });
        }
        return;
    }

    // Fallback if LRCLIB is disabled
    lyricsContainer.innerHTML = `<p style="opacity: 1; filter: none;">No lyrics found.</p>`;
}

async function fetchLyricsFromLrclib(song) {
    if (!song) return null;

    // Use the cleaned metadata for the API call
    const cleanedSong = cleanMetadataForLyricsSearch(song);
    const artist = encodeURIComponent(cleanedSong.artist);
    const track = encodeURIComponent(cleanedSong.name);
    const album = encodeURIComponent(cleanedSong.album);

    const url = `https://lrclib.net/api/get?artist_name=${artist}&track_name=${track}&album_name=${album}`;

    try {
        const response = await fetch(url);
        if (!response.ok) {
            console.warn(`LRCLIB request failed with status: ${response.status}`);
            return null;
        }
        
        const data = await response.json();
        if (Object.keys(data).length === 0 || (!data.plainLyrics && !data.syncedLyrics)) {
            return null;
        }

        if (data.syncedLyrics) {
            return { type: 'lrc', content: data.syncedLyrics };
        } else if (data.plainLyrics) {
            return { type: 'plain', content: data.plainLyrics };
        }

    } catch (error) {
        console.error("Error fetching lyrics from LRCLIB:", error);
    }
    return null;
}

// This function cleans metadata before any LRCLIB search
function cleanMetadataForLyricsSearch(song) {
    let cleanTitle = song.name || '';
    let cleanArtist = song.artist || '';

    // Remove common patterns like (feat...), (prod...), [Official Video], etc.
    const patternsToRemove = [
        /\s*\(feat\..*?\)/i,
        /\s*\(prod\..*?\)/i,
        /\s*\[.*?\]/g,
        /\s*\(.*?(official|lyric|audio|video|visualizer).*?\)/i,
        /\s-\s(official|lyric|audio|video|visualizer).*/i,
        /MV/g
    ];

    patternsToRemove.forEach(pattern => {
        cleanTitle = cleanTitle.replace(pattern, '').trim();
    });

    return { name: cleanTitle, artist: cleanArtist, album: song.album };
}

// New function to handle the manual search API call
async function searchLrclibForManualPick() {
    const query = document.getElementById('manualLyricsSearchInput').value;
    const resultsContainer = document.getElementById('manualLyricsResults');
    if (!query) return;

    resultsContainer.innerHTML = `<div class="loading-message"><svg width="24" height="24" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg" style="color: var(--text-color);"><style>.spinner_V8m1{transform-origin:center;animation:spinner_zKoa 2s linear infinite}.spinner_V8m1 circle{stroke-linecap:round;animation:spinner_YpZS 1.5s ease-in-out infinite}@keyframes spinner_zKoa{100%{transform:rotate(360deg)}}@keyframes spinner_YpZS{0%{stroke-dasharray:0 150;stroke-dashoffset:0}47.5%{stroke-dasharray:42 150;stroke-dashoffset:-16}95%,100%{stroke-dasharray:42 150;stroke-dashoffset:-59}}</style><g class="spinner_V8m1"><circle cx="12" cy="12" r="9.5" fill="none" stroke-width="3"></circle></g></svg></div>`;
    const url = `https://lrclib.net/api/search?q=${encodeURIComponent(query)}`;

    try {
        const response = await fetch(url);
        if (!response.ok) throw new Error('API Search failed');
        
        // Store results in our global variable
        lastLrclibSearchResults = await response.json();

        if (lastLrclibSearchResults.length === 0) {
            resultsContainer.innerHTML = '<p>No results found.</p>';
            return;
        }

        resultsContainer.innerHTML = lastLrclibSearchResults.map(track => `
            <div class="menu-item" data-id="${track.id}" style="cursor: pointer;">
                <div>
                    <div>${sanitize(track.trackName)}</div>
                    <div style="font-size: 0.8em; color: var(--secondary-text-color);">${sanitize(track.artistName)}</div>
                </div>
            </div>
        `).join('');

        // Add click listeners to each new result item
        resultsContainer.querySelectorAll('.menu-item').forEach(item => {
            item.addEventListener('click', async () => {
                const trackId = parseInt(item.dataset.id, 10);
                const selectedTrack = lastLrclibSearchResults.find(t => t.id === trackId);
                
                if (!selectedTrack) return; // Safety check

                const song = currentlyPlayingSong;
                if (!song) return;

                // Apply lyrics directly from the selected search result
                if (selectedTrack.syncedLyrics) {
                    song.lyrics = selectedTrack.syncedLyrics;
                    song.lrcData = parseLRC(selectedTrack.syncedLyrics);
                } else if (selectedTrack.plainLyrics) {
                    song.lyrics = selectedTrack.plainLyrics;
                    song.lrcData = null;
                } else {
                    Gurasuraisu.showPopup("Selected track has no lyrics.");
                    return;
                }

                // Save the newly found lyrics
                if (song.storage === 'soundcloud') {
                    await updateSoundcloudCacheWithLyrics(song);
                } else {
                    await saveSongs();
                }
                
                // Close modal and re-render the lyrics panel
                closeModal(manualLyricsSearchModal);
                await renderLyrics();
            });
        });

    } catch (error) {
        resultsContainer.innerHTML = `<p>Error during search.</p>`;
        console.error("Manual LRCLIB search error:", error);
    }
}
    
async function renderOfflineSoundcloudView() {
    const resultsGrid = document.getElementById('soundcloud-results-grid');
    const query = document.getElementById('soundcloudOfflineSearchInput').value.toLowerCase();
    resultsGrid.innerHTML = '';
    
    try {
        const tx = db.transaction('soundcloudCache', 'readonly');
        const store = tx.objectStore('soundcloudCache');
        const allCachedItems = await promiseIDBRequest(store.getAll());

        let filteredItems = allCachedItems;
        if (query) {
            filteredItems = allCachedItems.filter(item => 
                item.metadata.name.toLowerCase().includes(query) ||
                item.metadata.artist.toLowerCase().includes(query)
            );
        }
        
        if (filteredItems.length === 0) {
            if (query) {
                // If there was a search query, show a "no results" message.
                resultsGrid.innerHTML = `<div class="no-results" style="grid-column: 1 / -1;"><p>No cached songs match "${sanitize(query)}"</p></div>`;
            } else {
                // If there was no query, it means the cache is empty.
                resultsGrid.innerHTML = `<div class="no-results" style="grid-column: 1 / -1;"><p>No SoundCloud songs are cached</p></div>`;
            }
            return;
        }
        
        // Sort by most recently played
        filteredItems.sort((a, b) => b.timestamp - a.timestamp);

        const resultsHtml = filteredItems.map(entry => {
            const track = entry.metadata;
            return `
            <div class="music-item" data-cached-id="${track.id}" style="cursor: pointer;">
                 <div class="song-info">
                    <img src="${track.albumArt}" class="album-thumbnail" style="width: 40px; height: 40px; border-radius: 8px; margin-right: 6px;">
                    <div>
                        <div class="song-title" style="white-space: normal;">${sanitize(track.name)}</div>
                        <div class="album-artist" style="font-size: 0.8em;">${sanitize(track.artist)}</div>
                    </div>
                </div>
            </div>
            `;
        }).join('');
        resultsGrid.className = 'item-list';
        resultsGrid.innerHTML = resultsHtml;
    } catch (error) {
        console.error('Failed to render offline songs:', error);
        resultsGrid.innerHTML = `<div class="no-results" style="grid-column: 1 / -1;"><p>Error loading cached songs.</p></div>`;
    }
}

// This new function will control the view in the "New" tab
function renderSoundcloudPage() {
    const searchContainer = document.getElementById('soundcloud-search-container');
    const offlineSearchContainer = document.getElementById('soundcloud-offline-search-container');
    const filterContainer = document.getElementById('soundcloud-filter-container');
    
    if (isSoundcloudOfflineMode) {
        searchContainer.style.display = 'none';
        offlineSearchContainer.style.display = 'flex';
        filterContainer.style.display = 'none';
        document.getElementById('soundcloudOfflineToggle').classList.add('active');
        renderOfflineSoundcloudView();
    } else {
        searchContainer.style.display = 'block';
        offlineSearchContainer.style.display = 'none';
        filterContainer.style.display = 'flex';
        document.getElementById('soundcloudOfflineToggle').classList.remove('active');
        document.getElementById('soundcloudOfflineSearchInput').value = '';
        renderSoundcloudSearchResults();
    }
}
        
function renderQueue() {
    const lyricsQueuePanel = document.getElementById('lyrics-queue-panel');
    if (!lyricsQueuePanel) return;

    // Create the header with the title and the new autoplay toggle
    const headerHtml = `
        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 0; flex-shrink: 0;">
            <h2 class="section-title" style="margin: 0;">Up Next</h2>
            <div style="display: flex; align-items: center; gap: 10px;">
                <label for="autoplayToggle" style="font-size: 14px; color: var(--secondary-text-color);">Autoplay</label>
                <input type="checkbox" id="autoplayToggle" ${isAutoplayEnabled ? 'checked' : ''}>
            </div>
        </div>
    `;

    if (playQueue.length === 0) {
        lyricsQueuePanel.innerHTML = headerHtml + `
            <div class="now-queue">
                <div class="no-results" style="flex-grow: 1; justify-content: center;">
                    <span class="material-symbols-rounded">queue_music</span>
                    <p>The queue is empty.</p>
                </div>
            </div>
        `;
    } else {
        const queueHtml = playQueue.map((song, index) => `
            <div class="music-item queue-item ${song.id === currentSongId ? "active" : ""}" data-queue-index="${index}" data-id="${song.id}">
                <div class="song-info">
                    <img src="${song.albumArt}" class="album-thumbnail" style="width: 40px; height: 40px; border-radius: 6px; margin: 0 5px;">
                    <div class="song-title">${sanitize(song.name)}</div>
                    <span class="song-artist-queue">${song.artist}</span>
                    <button class="remove-from-queue-btn" data-queue-index="${index}">
                        <span class="material-symbols-rounded" style="font-size: 14px;">cancel</span>
                    </button>
                </div>
            </div>
        `).join('');
        
        lyricsQueuePanel.innerHTML = `<div class="now-queue">${headerHtml}<div class="queue-list-container" style="margin-top: 10px;">${queueHtml}</div></div>`;
    }

    // Attach event listener for the new toggle switch
    const autoplayToggle = document.getElementById('autoplayToggle');
    if (autoplayToggle) {
        autoplayToggle.addEventListener('change', toggleAutoplay);
    }

    makeQueueItemsDraggable();
    addQueueItemEventListeners();
}

function scrollToCurrentSongInQueue() {
    // Use a small timeout to ensure the DOM has updated
    setTimeout(() => {
        const activeSongEl = document.querySelector('#lyrics-queue-panel .queue-item.active');
        if (activeSongEl) {
            activeSongEl.scrollIntoView({
                behavior: 'smooth',
                block: 'center'
            });
        }
    }, 100);
}

function attachSongAndAlbumEventListeners() {
  document.querySelectorAll('.song-actions').forEach(button => {
      button.addEventListener('click', (e) => {
          const songId = parseFloat(button.dataset.id);
          openSongContextMenu(e, songId);
      });
  });
}

function rebuildQueueFromCurrentView() {
    const newQueue = [];
    let songItems;

    // Determine where to source the song list from based on the active view
    if (activeView === 'library') {
        songItems = document.querySelectorAll('#library-grid .item-card[data-album-id]');
    } else if (activeView === 'search') {
        // We will add search logic later, for now, it can be empty
        songItems = document.querySelectorAll('#search-view .item-card');
    } else {
        // Default or Home view, we can source from the entire song list for now
        playQueue = [...songs]; // Fallback to all songs
        console.log(`Queue rebuilt from all songs. ${playQueue.length} songs.`);
        isQueueUserModified = false;
        return;
    }

    if (songItems.length > 0) {
        // This part needs to be adapted based on what each view renders.
        // For the library's album view:
        if (activeView === 'library' && currentFilter === 'albums') {
            const albumSongs = [];
            songItems.forEach(card => {
                const [artist, albumName] = card.dataset.albumId.split('::');
                const songsFromAlbum = songs.filter(s => s.albumArtist === artist && s.album === albumName);
                albumSongs.push(...songsFromAlbum);
            });
            // Remove duplicates in case albums are shown multiple times
            const uniqueIds = new Set();
            playQueue = albumSongs.filter(song => {
                const isDuplicate = uniqueIds.has(song.id);
                uniqueIds.add(song.id);
                return !isDuplicate;
            });

        } else {
             // Fallback for other potential views (like song list view later)
             songItems.forEach(item => {
                const songId = parseFloat(item.dataset.id);
                const song = songs.find(s => s.id === songId);
                if (song && !newQueue.some(s => s.id === song.id)) {
                    newQueue.push(song);
                }
            });
            playQueue = newQueue;
        }

    } else {
        // If the view is empty, just use the full song list
        playQueue = [...songs];
    }
    
    console.log(`Queue rebuilt from ${activeView} view. ${playQueue.length} songs.`);
    isQueueUserModified = false; 
}
        
function addToQueue(songId, position = 'last') {
    isQueueUserModified = true; // Flag that the user is now manually curating the queue
    
    // FIX: Find song from multiple possible sources
    let song = songs.find(s => s.id === songId);
    if (!song && lastSoundcloudSearchResults.length > 0) { // If not in local library, check soundcloud results
         const track = lastSoundcloudSearchResults.find(t => t.id === songId);
         if (track) {
            song = {
                id: track.id,
                name: track.title,
                artist: track.user.username,
                album: 'SoundCloud',
                albumArt: getHighResArtwork(track.artwork_url),
                storage: 'soundcloud'
            };
         }
    }

    if (!song) {
        console.error("Could not find song to add to queue with ID:", songId);
        return;
    }

    if (playQueue.length === 0) {
        rebuildQueueFromCurrentView();
        currentQueueIndex = playQueue.findIndex(s => s.id === currentSongId);
    }
    
    if (currentQueueIndex === -1) {
        currentQueueIndex = playQueue.length > 0 ? playQueue.length -1 : 0;
    }
    
    if (position === 'next') {
        playQueue.splice(currentQueueIndex + 1, 0, song);
    } else { 
        playQueue.push(song);
    }

    Gurasuraisu.showPopup(`Added "${sanitize(song.name)}" to queue.`);
    
    if (isPanelVisible && panelContent === 'queue') {
        renderQueue();
    }
}

async function toggleAutoplay(event) {
    isAutoplayEnabled = event.target.checked;
    if (isAutoplayEnabled) {
        await generateAutoplaySongs();
    } else {
        removeAutoplaySongs();
    }
}

function removeAutoplaySongs() {
    if (autoplaySongIds.size === 0) return;

    playQueue = playQueue.filter(song => !autoplaySongIds.has(song.id));
    autoplaySongIds.clear();
    
    // After removing songs, the current index might be wrong. Let's fix it.
    currentQueueIndex = playQueue.findIndex(s => s.id === currentSongId);

    renderQueue();
}

async function generateAutoplaySongs() {
    removeAutoplaySongs(); // Always start with a clean slate

    const contextQueue = playQueue.length > 0 ? playQueue : (currentlyPlayingSong ? [currentlyPlayingSong] : []);
    if (contextQueue.length === 0) return;

    let finalRecommendations = [];

    // --- Path 1: GuraAI-Powered Recommendations (Highest Priority) ---
    if (isGuraAiEnabled && musicAiModel) {
        console.log("Generating autoplay using GuraAI...");
        finalRecommendations = await generateAiAutoplaySongs();
    }

    // --- Path 2: Advanced Scoring Fallback (If AI is off or fails) ---
    if (finalRecommendations.length === 0) {
        console.log("GuraAI not used, falling back to advanced scoring method...");

        // 1. Create a master set of all songs the user already "owns" or has in their queue to prevent duplicates.
        const ownedSongKeys = new Set(localSongLookup.keys());
        playQueue.forEach(song => {
            const uniqueKey = `${(song.artist || '').toLowerCase().trim()}::${(song.name || '').toLowerCase().trim()}`;
            ownedSongKeys.add(uniqueKey);
        });
        const userQueueSongIds = new Set(playQueue.map(s => s.id));

        // 2. Gather all context signals from the current queue.
        const contextArtists = new Set(contextQueue.map(s => s.artist).filter(Boolean));
        const contextAlbumArtists = new Set(contextQueue.map(s => s.albumArtist).filter(Boolean));
        const contextGenres = new Set(contextQueue.map(s => s.genre).filter(Boolean));
        const contextYears = [...new Set(contextQueue.map(s => s.year).filter(Boolean).map(y => parseInt(y, 10)))];
        const YEAR_RANGE = 5; // Recommend songs from +/- 5 years

        // 3. Score every song in the library based on the context.
        const scoredRecommendations = [];
        for (const candidateSong of songs) {
            if (userQueueSongIds.has(candidateSong.id)) continue; // Skip songs already in queue

            let score = 0;
            if (contextArtists.has(candidateSong.artist)) score += 3; // Strongest signal
            if (contextAlbumArtists.has(candidateSong.albumArtist)) score += 2; // Strong signal
            if (contextGenres.has(candidateSong.genre)) score += 1; // Good signal

            // Check for year proximity
            const candidateYear = parseInt(candidateSong.year, 10);
            if (!isNaN(candidateYear) && contextYears.some(year => Math.abs(year - candidateYear) <= YEAR_RANGE)) {
                score += 1;
            }

            // Add a small boost for popularity
            if (candidateSong.playCount > 10) {
                score += 1;
            }

            if (score > 0) {
                scoredRecommendations.push({ song: candidateSong, score: score });
            }
        }
        
        // 4. Sort by score (descending), with a random factor to break ties.
        scoredRecommendations.sort((a, b) => b.score - a.score || Math.random() - 0.5);
        const localRecommendations = scoredRecommendations.map(item => item.song);

        // 5. Fetch and filter SoundCloud recommendations if enabled.
        let soundcloudRecommendations = [];
        if (isSoundcloudEnabled && soundcloudClientId) {
            const searchTerms = [...new Set([...contextArtists, ...contextGenres])];
            const promises = searchTerms.map(term => 
                fetch(`https://api-v2.soundcloud.com/search/tracks?q=${encodeURIComponent(term)}&client_id=${soundcloudClientId}&limit=20`)
                    .then(res => res.ok ? res.json() : { collection: [] })
                    .catch(() => ({ collection: [] }))
            );
            const results = await Promise.all(promises);
            const allTracks = results.flatMap(data => data.collection);

            soundcloudRecommendations = allTracks
                .map(track => ({
                    id: track.id, name: track.title, artist: track.user.username,
                    album: 'SoundCloud Autoplay', albumArt: getHighResArtwork(track.artwork_url), storage: 'soundcloud',
                    uniqueKey: `${(track.user.username || '').toLowerCase().trim()}::${(track.title || '').toLowerCase().trim()}`
                }))
                .filter(song => !ownedSongKeys.has(song.uniqueKey));
        }

        // 6. Combine, deduplicate, and shuffle the final list.
        const combinedPool = [...localRecommendations, ...soundcloudRecommendations];
        const finalMap = new Map();
        combinedPool.forEach(song => {
            const key = song.uniqueKey || `${(song.artist || '').toLowerCase().trim()}::${(song.name || '').toLowerCase().trim()}`;
            if (!finalMap.has(key)) {
                finalMap.set(key, song);
            }
        });
        finalRecommendations = shuffleArray(Array.from(finalMap.values()));
    }
    
    // --- Final Step: Add the chosen recommendations to the queue ---
    const songsToAdd = finalRecommendations.slice(0, 20);
    if (songsToAdd.length > 0) {
        songsToAdd.forEach(song => autoplaySongIds.add(song.id));
        playQueue.push(...songsToAdd);
    }

    renderQueue();
}

function formatSongsForAiPrompt(songList) {
    if (!songList || songList.length === 0) return "No songs available.";
    // Provide more context: Title, Artist, Genre, and Source (SoundCloud or Local)
    return songList.map(s => 
        `Title: ${s.name}, Artist: ${s.artist}, Genre: ${s.genre || 'Unknown'}, Source: ${s.storage === 'soundcloud' ? 'SoundCloud' : 'Local'}`
    ).join('\n');
}

async function generateAiAutoplaySongs() {
    if (!musicAiModel) return [];

    const contextQueue = playQueue.length > 0 ? playQueue : (currentlyPlayingSong ? [currentlyPlayingSong] : []);
    if (contextQueue.length === 0) return [];

    // --- Build Comprehensive Context for AI ---
    let comprehensiveLibrary = [...songs];
    const userQueueSongIds = new Set(playQueue.map(s => s.id));

    // 1. If SoundCloud is enabled, fetch potential recommendations to add to the AI's knowledge base.
    if (isSoundcloudEnabled && soundcloudClientId) {
        const contextArtists = new Set(contextQueue.map(s => s.artist).filter(Boolean));
        const contextGenres = new Set(contextQueue.map(s => s.genre).filter(Boolean));
        const searchTerms = [...new Set([...contextArtists, ...contextGenres])];
        
        const promises = searchTerms.map(term =>
            fetch(`https://api-v2.soundcloud.com/search/tracks?q=${encodeURIComponent(term)}&client_id=${soundcloudClientId}&limit=10`)
                .then(res => res.ok ? res.json() : { collection: [] })
                .catch(() => ({ collection: [] }))
        );
        const results = await Promise.all(promises);
        const scTracks = results.flatMap(data => data.collection).map(track => ({
            id: track.id, name: track.title, artist: track.user.username,
            album: 'SoundCloud', albumArt: getHighResArtwork(track.artwork_url), storage: 'soundcloud', genre: track.genre
        }));

        // Add SoundCloud tracks to the library if they aren't duplicates of local songs
        scTracks.forEach(scSong => {
            const uniqueKey = `${scSong.artist.toLowerCase().trim()}::${scSong.name.toLowerCase().trim()}`;
            if (!localSongLookup.has(uniqueKey)) {
                comprehensiveLibrary.push(scSong);
            }
        });
    }
    
    // 2. Create a precise prompt for the AI
    const queuePrompt = `The user's current queue contains:\n${formatSongsForAiPrompt(contextQueue)}`;
    const libraryPrompt = `Here is the comprehensive library of available songs (Local and SoundCloud):\n${formatSongsForAiPrompt(comprehensiveLibrary)}`;
    const instructionPrompt = `\nSelect up to 20 songs from the comprehensive library that are similar to the user's queue. CRITICAL: Do NOT include any songs that are already in the queue.`;
    
    const fullPrompt = `${queuePrompt}\n\n${libraryPrompt}\n\n${instructionPrompt}`;

    try {
        const result = await musicAiModel.generateContent(fullPrompt);
        const call = result.response.functionCalls()?.[0];

        if (call && call.name === 'getSongRecommendations') {
            // Find the full song objects from the AI's string recommendations
            const recommendedSongs = call.args.songs
                .map(songString => findSongByString(songString, comprehensiveLibrary))
                .filter(song => song && !userQueueSongIds.has(song.id)); // Final check for duplicates
            return recommendedSongs;
        }
    } catch (error) {
        console.error("GuraAI Autoplay Error:", error);
    }
    return []; // Return empty array on failure
}

function openSongContextMenu(targetElement, songId) {
    if (!targetElement) return; // Safety check

    const contextMenu = document.getElementById('songContextMenu');
    
    document.getElementById('menuAddToQueueNext').onclick = () => {
        addToQueue(songId, 'next');
        contextMenu.classList.remove('visible');
    };
    document.getElementById('menuAddToQueueLast').onclick = () => {
        addToQueue(songId, 'last');
        contextMenu.classList.remove('visible');
    };

    contextMenu.classList.add('visible'); // Make visible before measuring to get dimensions
    const rect = targetElement.getBoundingClientRect();
    const menuWidth = contextMenu.offsetWidth;
    const menuHeight = contextMenu.offsetHeight;
    const viewportWidth = window.innerWidth;
    const viewportHeight = window.innerHeight;

    let top = rect.bottom;
    let left = rect.right - menuWidth; // Align to the right edge of the target

    // Adjust for viewport boundaries
    if (left < 0) {
        left = rect.left; // If it overflows left, align to the left edge instead
    }
    if (top + menuHeight > viewportHeight) {
        top = rect.top - menuHeight; // If it overflows bottom, open upwards
    }
    
    contextMenu.style.top = `${top}px`;
    contextMenu.style.left = `${left}px`;

    // Add a one-time listener to close the menu when clicking elsewhere
    // Use a timeout to prevent the current click from being captured
    setTimeout(() => {
        const closeMenuOnClickOutside = (e) => {
            if (!contextMenu.contains(e.target)) {
                contextMenu.classList.remove('visible');
                document.removeEventListener('click', closeMenuOnClickOutside, true);
                document.removeEventListener('contextmenu', closeMenuOnClickOutside, true);
            }
        };
        // Use the capture phase (true) to catch the click before it bubbles to other elements
        document.addEventListener('click', closeMenuOnClickOutside, true);
        document.addEventListener('contextmenu', closeMenuOnClickOutside, true);
    }, 0);
}

async function playSong(song, playContext = null) {
    if (isPlayerLoading || !song) return;
    
    // --- REVISED QUEUE LOGIC FOR PERSISTENT AUTOPLAY ---
    if (playContext && Array.isArray(playContext)) {
        // This block runs ONLY when a user starts a new playback context (new song, album, etc).
        const wasAutoplayEnabled = isAutoplayEnabled; // Remember the current autoplay state.

        // 1. Always replace the queue with the new context.
        playQueue = [...playContext];
        isQueueUserModified = false;
        
        // 2. Clear any old autoplay songs from the tracking set.
        autoplaySongIds.clear();

        // 3. If autoplay was on before, immediately generate new songs for the new queue.
        if (wasAutoplayEnabled) {
            await generateAutoplaySongs();
        }
    } else if (playQueue.length === 0) {
        // Fallback for an empty queue remains the same.
        rebuildQueueFromCurrentView();
    }
    
    isPlayerLoading = true;

    try {
        audioPlayer.pause();
        song.hasBeenLogged = false;
        currentlyPlayingSong = song;
        
        let fileUrl;
        // This logic now cleanly handles all cases
        if (song.blobUrl) { // Case 1: Playing a cached SoundCloud song
            fileUrl = song.blobUrl;
            audioPlayer.removeAttribute('crossorigin');
            connectAudioGraph(); // Visualizer works!
        } else if (song.streamUrl) { // Case 2: Streaming a new SoundCloud song
            fileUrl = song.streamUrl;
            audioPlayer.crossOrigin = "anonymous";
            connectAudioGraph();
        } else { // Case 3: Playing a local file
            fileUrl = await getSongFileUrl(song);
            audioPlayer.removeAttribute('crossorigin');
            connectAudioGraph();
        }

        if (!fileUrl) {
            Gurasuraisu.showPopup(`Could not find file for "${song.name}"`);
            isPlayerLoading = false;
            playNextSong();
            return;
        }
        
        currentSongId = song.id;
        currentQueueIndex = playQueue.findIndex(s => s.id === currentSongId);

        // Revoke old blob URL if it exists
        if (audioPlayer.src && audioPlayer.src.startsWith('blob:')) {
            URL.revokeObjectURL(audioPlayer.src);
        }

        // Now set the source, which triggers the browser to fetch it using the attributes we just set.
        audioPlayer.src = fileUrl;
        audioPlayer.load(); // Explicitly call load() to ensure the new source is processed.
        
        // Update both the main player and the miniplayer
        updatePlayerUI(song);
        updateMiniplayerUI(song, 'paused'); // Initially show as paused
        await updateMediaSessionMetadata(song);

        // Register media session
        Gurasuraisu.registerMediaSession(
            { title: song.name, artist: song.artist, artwork: [{ src: song.albumArt }] },
            ['playPause', 'next', 'prev']
        );

        if (isPanelVisible) {
            if (panelContent === 'lyrics') {
                renderLyrics();
            } else if (panelContent === 'queue') {
                renderQueue(); // Re-render queue to update the '.active' highlight
                scrollToCurrentSongInQueue(); // Scroll to new song
            }
        }

        await audioPlayer.play();

        proactivelyCacheNextInQueue();

        playPauseIcon.textContent = 'pause';
        playPauseBtn.classList.add('playing');
        Gurasuraisu.updatePlaybackState({ playbackState: 'playing' });
        updateMiniplayerUI(song, 'playing');

    } catch (error) {
        if (error.name !== 'AbortError') console.error("Failed to play song:", song.name, error);
        Gurasuraisu.updatePlaybackState({ playbackState: 'paused' });
        updateMiniplayerUI(song, 'paused');
    } finally {
        isPlayerLoading = false;
    }
}

function updateMiniplayerUI(song, state) {
    // If we are on the Now Playing screen, the miniplayer should ALWAYS be hidden.
    if (activeView === 'now-playing') {
        miniplayer.classList.add('hidden');
        return;
    }

    if (!song || !currentSongId) {
        miniplayer.classList.add('hidden');
        return;
    }

    miniplayer.classList.remove('hidden');
    miniplayerArt.src = song.albumArt;
    miniplayerTitle.textContent = sanitize(song.name);
    miniplayerArtist.textContent = sanitize(song.artist);
    miniplayerPlayBtn.innerHTML = `<span class="material-symbols-rounded">${state === 'playing' ? 'pause' : 'play_arrow'}</span>`;
}
        
async function getSongFileUrl(song) {
    if (!song) return null;

    if (song.storage === 'indexeddb') {
        try {
            const tx = db.transaction(['musicFiles'], 'readonly');
            const request = tx.objectStore('musicFiles').get(song.id);
            const result = await new Promise((resolve, reject) => {
                request.onsuccess = () => resolve(request.result);
                request.onerror = () => reject(request.error);
            });
            return result ? URL.createObjectURL(result.file) : null;
        } catch (e) {
             console.error(`Could not get blob for ${song.name}:`, e);
             return null;
        }
    }

    for (const handle of directoryHandles) {
        try {
            const fileHandle = await handle.getFileHandle(song.handleName);
            const file = await fileHandle.getFile();
            return URL.createObjectURL(file);
        } catch (e) {
            if (e.name === 'NotFoundError') continue;
            console.error(`Error accessing handle for ${song.name} in directory ${handle.name}:`, e);
        }
    }

    console.warn(`Could not find "${song.handleName}" in any connected directories.`);
    return null;
}

async function logSongPlay(songId) {
    try {
        const songTx = db.transaction('songs', 'readwrite');
        const songStore = songTx.objectStore('songs');
        const songReq = songStore.get(songId);

        songReq.onsuccess = () => {
            const songData = songReq.result;
            if (songData) {
                songData.playCount = (songData.playCount || 0) + 1;
                songStore.put(songData);
            }
        };
        
        const historyTx = db.transaction('playHistory', 'readwrite');
        const historyStore = historyTx.objectStore('playHistory');
        historyStore.put({ timestamp: Date.now(), songId: songId });

        await Promise.all([songTx.done, historyTx.done]);

        // Also update the in-memory version
        const inMemorySong = songs.find(s => s.id === songId);
        if (inMemorySong) {
            inMemorySong.playCount = (inMemorySong.playCount || 0) + 1;
        }

    } catch (error) {
        console.error("Failed to log song play:", error);
    }
}
        
function initModalVariables() {
    editModal = document.getElementById('editModal');
    editSongId = document.getElementById('editSongId');
    editTitle = document.getElementById('editTitle');
    editArtist = document.getElementById('editArtist');
    editAlbum = document.getElementById('editAlbum');
    saveEdit = document.getElementById('saveEdit');
    cancelEdit = document.getElementById('cancelEdit');
    saveEdit.addEventListener('click', saveMetadataChanges);
    cancelEdit.addEventListener('click', () => closeModal(editModal));

    sleepTimerModal = document.getElementById('sleepTimerModal');
    document.getElementById('cancelSleepTimer').addEventListener('click', () => setSleepTimer(0));

    playlistModal = document.getElementById('playlistModal');
    document.getElementById('closePlaylistModal').addEventListener('click', () => closeModal(playlistModal));
    document.getElementById('createPlaylistBtn').addEventListener('click', createPlaylistAndAddSong);

    equalizerModal = document.getElementById('equalizerModal');
    document.getElementById('closeEqModal').addEventListener('click', () => closeModal(equalizerModal));
    document.getElementById('resetEq').addEventListener('click', () => {
        ['bass-slider', 'mid-slider', 'treble-slider'].forEach(id => {
            const slider = document.getElementById(id);
            slider.value = 0;
            slider.dispatchEvent(new Event('input')); 
        });
    });
    document.getElementById('bass-slider').addEventListener('input', (e) => { if(eqBass) eqBass.gain.value = e.target.value; });
    document.getElementById('mid-slider').addEventListener('input', (e) => { if(eqMid) eqMid.gain.value = e.target.value; });
    document.getElementById('treble-slider').addEventListener('input', (e) => { if(eqTreble) eqTreble.gain.value = e.target.value; });
    
    manageFoldersModal = document.getElementById('manageFoldersModal');
    document.getElementById('closeFoldersModal').addEventListener('click', () => closeModal(manageFoldersModal));

    manualLyricsSearchModal = document.getElementById('manualLyricsSearchModal');
    document.getElementById('manualLyricsSearchBtn').addEventListener('click', searchLrclibForManualPick);
    document.getElementById('closeManualLyricsModal').addEventListener('click', () => closeModal(manualLyricsSearchModal));
}

function openManageFoldersModal() {
    const folderList = document.getElementById('folderList');
    folderList.innerHTML = '';

    if (directoryHandles.length === 0) {
        folderList.innerHTML = '<p style="color: var(--secondary-text-color); text-align: center;">No folders have been added yet.</p>';
    } else {
        directoryHandles.forEach(handle => {
            const item = document.createElement('div');
            item.style.cssText = 'display:flex; align-items:center; justify-content:space-between; padding:8px; border-radius:8px; margin-bottom:5px; background-color:var(--search-background)';
            item.innerHTML = `<span><span class="material-symbols-rounded" style="vertical-align: middle; margin-right: 8px;">folder</span>${handle.name}</span>
                              <button class="remove-folder-btn" data-name="${handle.name}" style="background: none; border: none; color: #ff6b6b; cursor: pointer;"><span class="material-symbols-rounded">delete</span></button>`;
            folderList.appendChild(item);
        });
        
        document.querySelectorAll('.remove-folder-btn').forEach(btn => {
            btn.onclick = (e) => removeFolder(e.currentTarget.dataset.name);
        });
    }
    
    // Populate settings
    document.getElementById('soundcloudClientId').value = soundcloudClientId;
    document.getElementById('soundcloudToggle').checked = isSoundcloudEnabled;
    document.getElementById('lrclibToggle').checked = isLrclibEnabled;
    openModal(manageFoldersModal);
}

async function saveIntegrationSettings() {
    soundcloudClientId = document.getElementById('soundcloudClientId').value.trim();
    isSoundcloudEnabled = document.getElementById('soundcloudToggle').checked;
    isLrclibEnabled = document.getElementById('lrclibToggle').checked;

    const tx = db.transaction('config', 'readwrite');
    await Promise.all([
        tx.objectStore('config').put({ key: 'soundcloudClientId', value: soundcloudClientId }),
        tx.objectStore('config').put({ key: 'isSoundcloudEnabled', value: isSoundcloudEnabled }),
        tx.objectStore('config').put({ key: 'isLrclibEnabled', value: isLrclibEnabled })
    ]);
    
    toggleSoundcloudTab();
}

function toggleSoundcloudTab() {
    const tab = document.getElementById('soundcloud-tab');
    if (tab) {
        tab.style.display = isSoundcloudEnabled ? 'flex' : 'none';
    }
}

async function searchSoundCloud() {
    const query = document.getElementById('soundcloudSearchInput').value.trim();
    const resultsGrid = document.getElementById('soundcloud-results-grid');
    if (!query) {
        resultsGrid.innerHTML = '';
        lastSoundcloudSearchResults = [];
        return;
    }
    if (!soundcloudClientId) {
        resultsGrid.innerHTML = `<div class="no-results" style="grid-column: 1 / -1;"><p>SoundCloud Client ID is not set</p></div>`;
        return;
    }

    resultsGrid.innerHTML = `<div class="loading-message"><svg width="24" height="24" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg" style="color: var(--text-color);"><style>.spinner_V8m1{transform-origin:center;animation:spinner_zKoa 2s linear infinite}.spinner_V8m1 circle{stroke-linecap:round;animation:spinner_YpZS 1.5s ease-in-out infinite}@keyframes spinner_zKoa{100%{transform:rotate(360deg)}}@keyframes spinner_YpZS{0%{stroke-dasharray:0 150;stroke-dashoffset:0}47.5%{stroke-dasharray:42 150;stroke-dashoffset:-16}95%,100%{stroke-dasharray:42 150;stroke-dashoffset:-59}}</style><g class="spinner_V8m1"><circle cx="12" cy="12" r="9.5" fill="none" stroke-width="3"></circle></g></svg></div>`;

    try {
        const response = await fetch(`https://api-v2.soundcloud.com/search/tracks?q=${encodeURIComponent(query)}&client_id=${soundcloudClientId}&limit=100`);
        if (!response.ok) throw new Error(`API request failed: ${response.statusText}`);
        
        const data = await response.json();
        lastSoundcloudSearchResults = data.collection;
        renderSoundcloudSearchResults(); // New renderer function

    } catch (error) {
        console.error('SoundCloud Search Error:', error);
        resultsGrid.innerHTML = `<div class="no-results" style="grid-column: 1 / -1;"><p>Error searching SoundCloud</p></div>`;
    }
}

// This is a new helper function to manage the cache size
async function manageCacheSize() {
    const tx = db.transaction('soundcloudCache', 'readwrite');
    const store = tx.objectStore('soundcloudCache');
    const index = store.index('timestamp');
    const allEntriesReq = index.getAll();

    allEntriesReq.onsuccess = async () => {
        const entries = allEntriesReq.result;
        let totalSize = entries.reduce((acc, entry) => acc + entry.size, 0);

        if (totalSize > SOUNDCLOUD_CACHE_LIMIT) {
            console.log(`Cache size (${(totalSize / 1024 / 1024).toFixed(2)}MB) exceeds limit. Pruning...`);
            entries.sort((a, b) => a.timestamp - b.timestamp); // Sort oldest first

            for (const entry of entries) {
                if (totalSize <= SOUNDCLOUD_CACHE_LIMIT) break;
                await store.delete(entry.id);
                totalSize -= entry.size;
                console.log(`Removed ${entry.metadata.name} from cache.`);
            }
        }
    };
    await tx.done;
}

// This is a new function to handle background caching
async function cacheSoundcloudTrack(songObject, streamUrl) {
    try {
        const audioResponse = await fetch(streamUrl);
        if (!audioResponse.ok) throw new Error('Could not download audio file for caching.');
        const audioBlob = await audioResponse.blob();

        const cacheEntry = {
            id: songObject.id,
            metadata: songObject,
            blob: audioBlob,
            timestamp: Date.now(),
            size: audioBlob.size
        };

        const tx = db.transaction('soundcloudCache', 'readwrite');
        tx.objectStore('soundcloudCache').put(cacheEntry);
        await tx.done;

        console.log(`Successfully cached "${songObject.name}"`);
        await manageCacheSize();

    } catch (error) {
        console.error(`Failed to cache ${songObject.name}:`, error);
    }
}

// This is a NEW function for proactive background caching
async function proactivelyCacheNextInQueue() {
    if (playQueue.length === 0 || currentQueueIndex < 0) return;

    // Look ahead 2 songs in the queue
    for (let i = 1; i <= 2; i++) {
        const nextIndex = currentQueueIndex + i;
        if (nextIndex >= playQueue.length) break;

        const nextSong = playQueue[nextIndex];
        if (nextSong.storage === 'soundcloud') {
            const tx = db.transaction('soundcloudCache', 'readonly');
            const store = tx.objectStore('soundcloudCache');
            const checkReq = store.get(nextSong.id);
            checkReq.onsuccess = () => {
                if (!checkReq.result) {
                    console.log(`Proactively caching next song: ${nextSong.name}`);
                    // Fetch stream URL and cache without awaiting, so it runs in the background
                    fetch(`https://api-v2.soundcloud.com/tracks/${nextSong.id}?client_id=${soundcloudClientId}`)
                        .then(res => res.json())
                        .then(trackData => {
                            const stream = trackData.media.transcodings.find(t => t.format.protocol === 'progressive');
                            return fetch(`${stream.url}?client_id=${soundcloudClientId}`);
                        })
                        .then(res => res.json())
                        .then(streamData => cacheSoundcloudTrack(nextSong, streamData.url))
                        .catch(err => console.error(`Failed to proactively cache ${nextSong.name}:`, err));
                }
            };
        }
    }
}

// This is a NEW function to save a SoundCloud track to the local library
async function saveSoundcloudTrackToLibrary() {
    if (!currentlyPlayingSong || currentlyPlayingSong.storage !== 'soundcloud') return;
    const songToSave = currentlyPlayingSong;

    try {
        let audioBlob;
        // Check if the song is already cached
        const tx = db.transaction('soundcloudCache', 'readonly');
        const cacheReq = await promiseIDBRequest(tx.objectStore('soundcloudCache').get(songToSave.id));
        
        if (cacheReq && cacheReq.blob) {
            audioBlob = cacheReq.blob;
        } else {
            // If not cached, we must fetch the audio data first
            if (!songToSave.streamUrl) throw new Error("Stream URL is missing.");
            const audioResponse = await fetch(songToSave.streamUrl);
            if (!audioResponse.ok) throw new Error("Could not download audio.");
            audioBlob = await audioResponse.blob();
        }

        const newLocalId = Date.now() + Math.random();
        const newLocalSong = {
            id: newLocalId,
            name: songToSave.name,
            artist: songToSave.artist,
            album: songToSave.name,
            albumArtist: songToSave.artist, // Assume artist is album artist for SC
            storage: 'indexeddb',
            handleName: `${songToSave.name}.mp3`,
            dateAdded: Date.now(),
            year: new Date().getFullYear().toString(),
            albumArt: songToSave.albumArt,
            trackNumber: null,
            discNumber: null,
            lyrics: null,
            lrcData: null,
            playCount: 0
        };

        // Save to the main 'songs' store and the 'musicFiles' store
        const songTx = db.transaction(['songs', 'musicFiles'], 'readwrite');
        songTx.objectStore('songs').put(newLocalSong);
        songTx.objectStore('musicFiles').put({ id: newLocalId, file: audioBlob });
        await songTx.done;
        
        songs.push(newLocalSong); // Add to in-memory library
        processAndSortSongs();
        updateLocalSongLookup([newLocalSong]); 
        Gurasuraisu.showPopup(`Saved "${songToSave.name}" to Library`);

    } catch (error) {
        console.error("Failed to save SoundCloud track to library:", error);
        Gurasuraisu.showPopup("Could not save song");
    }
}

async function updateSoundcloudCacheWithLyrics(song) {
    if (!song || song.storage !== 'soundcloud') return;

    try {
        const tx = db.transaction('soundcloudCache', 'readwrite');
        const store = tx.objectStore('soundcloudCache');
        const request = store.get(song.id);

        request.onsuccess = () => {
            const entry = request.result;
            if (entry) {
                // Add the new lyrics data to the cached metadata
                entry.metadata.lyrics = song.lyrics;
                entry.metadata.lrcData = song.lrcData;
                store.put(entry);
            }
        };
        await tx.done;
        console.log(`Saved lyrics for SC track "${song.name}" to cache.`);
    } catch (error) {
        console.error("Failed to update SoundCloud cache with lyrics:", error);
    }
}

async function playSoundcloudTrack(trackId, playContext = null) {
    const numericTrackId = Number(trackId);
    
    try {
        // Step 1: Fetch metadata for the SC track to build our lookup key.
        const trackResponse = await fetch(`https://api-v2.soundcloud.com/tracks/${numericTrackId}?client_id=${soundcloudClientId}`);
        if (!trackResponse.ok) throw new Error('Could not fetch SC track details.');
        const trackData = await trackResponse.json();

        const uniqueKey = `${(trackData.user.username || '').toLowerCase().trim()}::${(trackData.title || '').toLowerCase().trim()}`;

        // Step 2: Check if this song exists in our local library.
        if (localSongLookup.has(uniqueKey)) {
            const localSong = localSongLookup.get(uniqueKey);
            console.log(`Redirecting SoundCloud play for "${trackData.title}" to local version.`);
            playSong(localSong, playContext);
            return; 
        }

        // Step 3: If not found locally, proceed with streaming from SoundCloud.
        const tx = db.transaction('soundcloudCache', 'readwrite');
        const store = tx.objectStore('soundcloudCache');
        const cachedEntry = await promiseIDBRequest(store.get(numericTrackId));

        let songToPlay;

        if (cachedEntry) {
            songToPlay = cachedEntry.metadata;
            // Ensure cached lyrics are loaded
            if (cachedEntry.metadata.lyrics) {
                songToPlay.lyrics = cachedEntry.metadata.lyrics;
                songToPlay.lrcData = cachedEntry.metadata.lrcData;
            }
            songToPlay.blobUrl = URL.createObjectURL(cachedEntry.blob);
            cachedEntry.timestamp = Date.now();
            store.put(cachedEntry);
        } else {
            const progressiveStream = trackData.media.transcodings.find(t => t.format.protocol === 'progressive');
            if (!progressiveStream || !progressiveStream.url) throw new Error('No streamable URL found.');
            
            const streamResponse = await fetch(`${progressiveStream.url}?client_id=${soundcloudClientId}`);
            const streamData = await streamResponse.json();

            songToPlay = {
                id: trackData.id,
                name: trackData.title,
                artist: trackData.user.username,
                album: trackData.title, // Using title as album for better LRCLIB matching
                albumArt: getHighResArtwork(trackData.artwork_url),
                storage: 'soundcloud',
                streamUrl: streamData.url,
                lyrics: null, // Initialize lyrics properties
                lrcData: null
            };
            // Do not await caching, let it happen in the background
            cacheSoundcloudTrack(songToPlay, streamData.url);
        }

        playSong(songToPlay, playContext);
        await tx.done;

    } catch (error) {
        console.error('Error playing or redirecting SoundCloud track:', error);
        Gurasuraisu.showPopup('Could not play selected item');
    }
}
        
function connectAudioGraph() {
    if (source && audioContext && eqBass) {
        try {
            source.disconnect(); // Disconnect everything first to ensure a clean state
        } catch(e) { /* Fails if not connected, which is fine */ }
        // Reconnect the full chain: source -> EQ -> analyser -> output
        source.connect(eqBass);
        document.getElementById('visualizerCanvas').style.visibility = 'visible';
        console.log("Audio graph connected for visualizer and EQ.");
    }
}

function disconnectAudioGraph() {
    if (source) {
        try {
            // Disconnect the source from the processing graph (EQ/analyser).
            // The HTMLAudioElement will now play directly to the speakers by default.
            source.disconnect();
        } catch(e) { /* Fails if not connected, which is fine */ }
        document.getElementById('visualizerCanvas').style.visibility = 'hidden';
        console.log("Audio graph disconnected for CORS track. Visualizer/EQ disabled.");
    }
}
        
async function removeFolder(folderName) {
    if (!confirm(`Are you sure you want to remove the folder "${folderName}"? All songs from this folder will be removed from your library.`)) {
        return;
    }

    const initialSongCount = songs.length;
    
    // Update the list of active directory handles in memory
    directoryHandles = directoryHandles.filter(h => h.name !== folderName);

    const songsToKeep = [];
    for (const song of songs) {
        // Always keep songs that are stored directly in the browser's database
        if (song.storage === 'indexeddb') {
            songsToKeep.push(song);
            continue;
        }

        // For filesystem-based songs, check if their file still exists in any of the REMAINING folders
        if (song.storage === 'filesystem') {
            let isStillAvailable = false;
            for (const handle of directoryHandles) {
                try {
                    // Check if we can get a handle to the file. If this doesn't throw an error, the file exists.
                    await handle.getFileHandle(song.handleName, { create: false });
                    isStillAvailable = true;
                    break; // The song is safe, no need to check other folders
                } catch (e) {
                    // A "NotFoundError" is expected if the song was in the removed folder.
                    // We only log other potential errors (e.g., permission denied).
                    if (e.name !== 'NotFoundError') {
                        console.warn(`Permission or other error checking for "${song.handleName}" in "${handle.name}".`, e);
                    }
                }
            }
            // Only add the song to our list of survivors if it was found in a remaining folder.
            if (isStillAvailable) {
                songsToKeep.push(song);
            }
        }
    }

    const removedSongCount = initialSongCount - songsToKeep.length;
    
    // Replace the main songs array with the filtered list of survivors.
    songs = songsToKeep;

    // --- Persist all state changes and update the UI ---

    // 1. Save the updated (smaller) list of directory handles to the database.
    const tx = db.transaction('config', 'readwrite');
    tx.objectStore('config').put({ key: 'directoryHandles', value: directoryHandles });
    await tx.done;
    
    // 2. Save the updated (smaller) list of songs to the database.
    await saveSongs();

    // 3. Update the play queue in case a removed song was in it.
    updatePlayQueue();

    // 4. Show a confirmation message and refresh the UI.
    Gurasuraisu.showPopup(`Removed "${folderName}" and ${removedSongCount} song(s).`);
    openManageFoldersModal(); // Refreshes the folder list inside the modal.
    if (activeView === 'library') {
        renderLibraryPage(); // Refreshes the main library view in the background.
    }
}

        async function deleteSong(songIdToDelete) {
            const songIndex = songs.findIndex(s => s.id === songIdToDelete);
            if (songIndex === -1) return;
        
            const songToDelete = songs[songIndex];
            if (songToDelete.storage === 'indexeddb') {
                const tx = db.transaction('musicFiles', 'readwrite');
                tx.objectStore('musicFiles').delete(songIdToDelete);
                await tx.done;
            }
        
            songs.splice(songIndex, 1);
            await saveSongs();
        
            if (songIdToDelete === currentSongId) {
                playNextSong(); 
            } else {
                updatePlayQueue();
            }
        }
        
        function openEditModal(songId) {
            const song = songs.find(s => s.id === songId);
            if (!song) return;
        
            editSongId.value = song.id;
            editTitle.value = song.name;
            editArtist.value = song.artist;
            editAlbum.value = song.album;
            openModal(editModal);
        }

        async function saveMetadataChanges() {
            const songId = parseFloat(editSongId.value);
            const song = songs.find(s => s.id === songId);
            if (!song) return;

            song.name = editTitle.value;
            song.artist = editArtist.value;
            song.album = editAlbum.value;

            if (song.id === currentSongId) {
                musicTitle.textContent = sanitize(song.name);
                musicArtist.textContent = song.artist;
                document.title = `${song.name} by ${song.artist}`;
                updateMediaSessionMetadata(song);
            }

            await saveSongs();
            closeModal(editModal);
        }

        function openPlaylistModal() {
            const playlistList = document.getElementById('playlistList');
            playlistList.innerHTML = '';
            if (playlists.length > 0) {
                 playlists.forEach(p => {
                    const item = document.createElement('div');
                    item.className = 'menu-item';
                    item.textContent = p.name;
                    item.onclick = () => addSongToPlaylist(p.id);
                    playlistList.appendChild(item);
                });
            } else {
                playlistList.innerHTML = '<p style="color: var(--secondary-text-color); text-align: center;">No playlists to add to</p>';
            }
            openModal(playlistModal);
        }
    
async function fetchLyrics(songId) {
    const song = songs.find(s => s.id === songId);
    return song ? song.lyrics : null;
}

function addQueueItemEventListeners() {
    document.querySelectorAll('.queue-item').forEach(item => {
        item.addEventListener('click', (e) => {
            // Prevent click from propagating to the remove button
            if (e.target.closest('.remove-from-queue-btn')) return;

            const songId = parseFloat(item.dataset.id);
            const song = playQueue.find(s => s.id === songId);
            if (song) {
                // --- THE FIX ---
                // We now call the play functions with "null" as the context.
                // This tells the player to find the song in the EXISTING queue
                // instead of creating a new one.
                if (song.storage === 'soundcloud') {
                    playSoundcloudTrack(song.id, null);
                } else {
                    playSong(song, null);
                }
            }
        });
    });

    document.querySelectorAll('.remove-from-queue-btn').forEach(btn => {
        btn.addEventListener('click', (e) => {
            e.stopPropagation();
            isQueueUserModified = true; // <-- ADD THIS LINE: Removing a song is a manual edit.
            const indexToRemove = parseInt(e.currentTarget.dataset.queueIndex, 10);
            
            if (playQueue[indexToRemove].id === currentSongId) {
                playQueue.splice(indexToRemove, 1);
                if (playQueue.length > 0) {
                    let nextIndex = indexToRemove >= playQueue.length ? 0 : indexToRemove;
                    currentQueueIndex = nextIndex - 1;
                    playNextSong();
                } else {
                    resetPlayer();
                }
            } else {
                playQueue.splice(indexToRemove, 1);
                if (indexToRemove < currentQueueIndex) currentQueueIndex--;
            }
            renderQueue();
        });
    });
}

function makeQueueItemsDraggable() {
    const container = document.querySelector('.queue-list-container');
    if (!container) return;
    let draggedQueueItem = null;

    container.querySelectorAll('.queue-item').forEach(item => {
        item.setAttribute('draggable', 'true');
        item.addEventListener('dragstart', () => {
            draggedQueueItem = item;
            setTimeout(() => item.classList.add('dragging'), 0);
        });
        item.addEventListener('dragend', () => {
            if (draggedQueueItem) {
                draggedQueueItem.classList.remove('dragging');
                draggedQueueItem = null;
                updateQueueFromDOM();
            }
        });
    });

    container.addEventListener('dragover', e => {
        e.preventDefault();
        const afterElement = getDragAfterElement(container, e.clientY);
        if (afterElement == null) {
            container.appendChild(draggedQueueItem);
        } else {
            container.insertBefore(draggedQueueItem, afterElement);
        }
    });
}

function getDragAfterElement(container, y) {
    const draggableElements = [...container.querySelectorAll('.queue-item:not(.dragging)')];
    return draggableElements.reduce((closest, child) => {
        const box = child.getBoundingClientRect();
        const offset = y - box.top - box.height / 2;
        if (offset < 0 && offset > closest.offset) {
            return { offset, element: child };
        } else {
            return closest;
        }
    }, { offset: Number.NEGATIVE_INFINITY }).element;
}

function updateQueueFromDOM() {
    isQueueUserModified = true; 
    const newQueueOrder = [];
    document.querySelectorAll('.queue-item').forEach(item => {
        const songId = parseFloat(item.dataset.id);
        const song = playQueue.find(s => s.id === songId);
        if (song) newQueueOrder.push(song);
    });

    playQueue = newQueueOrder;
    currentQueueIndex = playQueue.findIndex(s => s.id === currentSongId);

    // Check if an autoplay song was moved to be next
    if (currentQueueIndex + 1 < playQueue.length) {
        const nextSongId = playQueue[currentQueueIndex + 1].id;
        if (autoplaySongIds.has(nextSongId)) {
            autoplaySongIds.delete(nextSongId);
        }
    }
    
    isShuffleEnabled = false;
    updateShuffleButtonState();
    
    renderQueue();
}
        
async function playNextSong({ userInitiated = false, isTransition = false } = {}) {
    if (userInitiated && repeatMode === 'one') toggleRepeat();
    if (!userInitiated && !isTransition && repeatMode === 'one') {
        audioPlayer.currentTime = 0;
        audioPlayer.play().catch(e => console.error("Repeat-one playback failed", e));
        return;
    }
    if (!playQueue || playQueue.length === 0) return;
    
    currentQueueIndex++;
    
    // If we have reached the end of the queue AND autoplay is enabled...
    if (isAutoplayEnabled && currentQueueIndex >= playQueue.length) {
        // ...await the generation of new songs. This ensures the queue is populated
        // before the function continues. The generate function already handles clearing old songs.
        await generateAutoplaySongs(); 
    }

    if (currentQueueIndex >= playQueue.length) {
        if (repeatMode === 'all') currentQueueIndex = 0;
        else {
            resetPlayer();
            return;
        }
    }

    const nextSong = playQueue[currentQueueIndex];
    if (nextSong) {
        // **THE FIX:** Check song type and call the correct function
        if (nextSong.storage === 'soundcloud') {
            playSoundcloudTrack(nextSong.id);
        } else {
            playSong(nextSong, { isTransition });
        }
        proactivelyCacheNextInQueue();
    }
}
        
function playPreviousSong() {
    if (repeatMode === 'one') toggleRepeat();
    if (!playQueue.length) return;
    if (audioPlayer.currentTime > 5) {
        audioPlayer.currentTime = 0;
        audioPlayer.play().catch(e => console.error("Restart playback failed", e));
        return;
    }
    currentQueueIndex--;
    if (currentQueueIndex < 0) {
        currentQueueIndex = (repeatMode === 'all') ? playQueue.length - 1 : 0;
    }

    const prevSong = playQueue[currentQueueIndex];
    if (prevSong) {
        // **THE FIX:** Check song type and call the correct function
        if (prevSong.storage === 'soundcloud') {
            playSoundcloudTrack(prevSong.id);
        } else {
            playSong(prevSong, { isTransition: false });
        }
        proactivelyCacheNextInQueue();
    }
}

function cleanupBlobs() {
    songs.forEach(song => {
        if (song.url) URL.revokeObjectURL(song.url);
    });
}
   
function toggleShuffle() {
    isShuffleEnabled = !isShuffleEnabled;
    document.getElementById("shuffleBtn").classList.toggle("active", isShuffleEnabled);

    if (playQueue.length <= 1) return; // No need to shuffle if queue is small

    if (isShuffleEnabled) {
        // When shuffle is turned ON, shuffle the current queue but keep the playing song at the top.
        const currentSong = playQueue[currentQueueIndex];
        let songsToShuffle = playQueue.filter(song => song.id !== currentSongId);
        
        shuffleArray(songsToShuffle); // Use the utility function we added previously

        // Rebuild the queue with the current song first, followed by the shuffled list.
        playQueue = [currentSong, ...songsToShuffle];
        currentQueueIndex = 0; // The current song is now at the start of the shuffled queue.
        isQueueUserModified = true; // Shuffling is a user modification of the queue order.
    }
    // Note: When shuffle is turned OFF, we do not re-sort the queue. It remains in its
    // current shuffled order until a new song/album is played.

    // Re-render the queue panel if it's open to show the new shuffled order.
    if (isPanelVisible && panelContent === 'queue') {
        renderQueue();
    }
}

function updateShuffleButtonState() {
    document.getElementById("shuffleBtn").classList.toggle("active", isShuffleEnabled);
}
        
function toggleRepeat() {
    const repeatBtn = document.getElementById('repeatBtn');
    switch(repeatMode) {
        case 'none':
            repeatMode = 'all';
            repeatBtn.innerHTML = '<span class="material-symbols-rounded">repeat</span>';
            repeatBtn.classList.add('active');
            break;
        case 'all':
            repeatMode = 'one';
            repeatBtn.innerHTML = '<span class="material-symbols-rounded">repeat_one</span>';
            break;
        case 'one':
            repeatMode = 'none';
            repeatBtn.innerHTML = '<span class="material-symbols-rounded">repeat</span>';
            repeatBtn.classList.remove('active');
            break;
    }
}
    
function updatePlayQueue() {
    if (isQueueUserModified) {
        currentQueueIndex = playQueue.findIndex(s => s.id === currentSongId);
        // Corrected check: if the queue panel is visible, re-render it
        if (isPanelVisible && panelContent === 'queue') {
            renderQueue();
        }
        return;
    }

    if (isShuffleEnabled) {
        let availableSongs = [...songs];
        let currentSong = currentSongId ? availableSongs.find(s => s.id === currentSongId) : null;
        if (currentSong) availableSongs = availableSongs.filter(s => s.id !== currentSongId);
        
        for (let i = availableSongs.length - 1; i > 0; i--) {
            const j = Math.floor(Math.random() * (i + 1));
            [availableSongs[i], availableSongs[j]] = [availableSongs[j], availableSongs[i]];
        }
        playQueue = currentSong ? [currentSong, ...availableSongs] : availableSongs;
    } else {
        const sortedSongs = [...songs].sort((a, b) => {
            const albumCompare = (a.albumArtist || '').localeCompare(b.albumArtist || '') 
                            || (a.album || '').localeCompare(b.album || '');
            if (albumCompare !== 0) return albumCompare;
            const discCompare = (a.effectiveDiscNumber || 1) - (b.effectiveDiscNumber || 1);
            if (discCompare !== 0) return discCompare;
            return (a.trackNumber || 0) - (b.trackNumber || 0);
        });
        playQueue = sortedSongs;
    }
    
    currentQueueIndex = playQueue.findIndex(s => s.id === currentSongId);
    // Corrected check: if the queue panel is visible, re-render it
    if (isPanelVisible && panelContent === 'queue') {
        renderQueue();
    }
}
        
function groupSongsByAlbum(songsToRender) {
  const albums = {};
  
  songsToRender.forEach(song => {
    const albumArtistName = song.albumArtist || song.artist || 'Unknown Artist';
    const albumName = song.album || 'Unknown Album';
    const albumKey = `${albumArtistName}::${albumName}::${song.effectiveDiscNumber}`;

    if (!albums[albumKey]) {
      const albumDisplayName = song.effectiveDiscNumber > 1 ? `${albumName} (Disc ${song.effectiveDiscNumber})` : albumName;
      albums[albumKey] = {
        name: albumDisplayName,
        artist: albumArtistName,
        year: song.year,
        albumArt: song.albumArt,
        songs: [],
        originalAlbum: albumName,
        originalAlbumArtist: albumArtistName,
        effectiveDiscNumber: song.effectiveDiscNumber,
        dateAdded: 0 
      };
    }
    albums[albumKey].songs.push(song);
  });
  
  for (let key in albums) {
      albums[key].dateAdded = Math.max(...albums[key].songs.map(s => s.dateAdded || 0));
      albums[key].songs.sort((a, b) => (a.trackNumber || 0) - (b.trackNumber || 0));
  }
  
  let albumArray = Object.values(albums);
  
  if (currentSortMode === 'dateAdded') {
      albumArray.sort((a, b) => b.dateAdded - a.dateAdded);
  } else { // 'alpha'
      albumArray.sort((a, b) => {
         const artistCompare = a.originalAlbumArtist.localeCompare(b.originalAlbumArtist);
         if (artistCompare !== 0) return artistCompare;
         const albumCompare = a.originalAlbum.localeCompare(b.originalAlbum);
         if (albumCompare !== 0) return albumCompare;
         return a.effectiveDiscNumber - b.effectiveDiscNumber;
      });
  }
  return albumArray;
}

async function updateMediaSessionMetadata(song) {
    if (!('mediaSession' in navigator)) return;

    // Phase 1: Immediately update text metadata, reusing the old artwork temporarily.
    // This prevents the notification from disappearing.
    const metadata = {
        title: song.name,
        artist: song.artist,
        album: song.album,
    };

    const temporaryArtworkSrc = currentMediaSessionArtBlobUrl || song.albumArt;
    
    navigator.mediaSession.metadata = new MediaMetadata({
        ...metadata,
        artwork: [{ src: temporaryArtworkSrc, sizes: '512x512', type: 'image/png' }]
    });

    // Phase 2: Asynchronously create the new blob URL and update the artwork.
    const oldBlobUrl = currentMediaSessionArtBlobUrl;
    let newBlobUrl = null;

    if (song.albumArt && song.albumArt.startsWith('data:')) {
        try {
            const response = await fetch(song.albumArt);
            const blob = await response.blob();
            newBlobUrl = URL.createObjectURL(blob);
        } catch (e) {
            console.error("Failed to create blob URL for media session artwork", e);
        }
    }
    
    currentMediaSessionArtBlobUrl = newBlobUrl;

    // Update the metadata again, this time with the final, correct artwork.
    const finalArtworkSrc = newBlobUrl || song.albumArt;
    navigator.mediaSession.metadata = new MediaMetadata({
        ...metadata,
        artwork: [
            { src: finalArtworkSrc, sizes: '96x96', type: 'image/png' },
            { src: finalArtworkSrc, sizes: '128x128', type: 'image/png' },
            { src: finalArtworkSrc, sizes: '192x192', type: 'image/png' },
            { src: finalArtworkSrc, sizes: '256x256', type: 'image/png' },
            { src: finalArtworkSrc, sizes: '384x384', type: 'image/png' },
            { src: finalArtworkSrc, sizes: '512x512', type: 'image/png' },
        ]
    });

    // Now that the new artwork is in place, it's safe to revoke the old URL.
    if (oldBlobUrl && oldBlobUrl !== newBlobUrl) {
        URL.revokeObjectURL(oldBlobUrl);
    }
}

function updateMediaSessionPlaybackState(state) {
    if ('mediaSession' in navigator) navigator.mediaSession.playbackState = state;
}

function updateMediaSessionPositionState() {
    if (!('mediaSession' in navigator) || !isFinite(audioPlayer.duration)) return;
    try {
        navigator.mediaSession.setPositionState({
            duration: audioPlayer.duration,
            playbackRate: audioPlayer.playbackRate,
            position: audioPlayer.currentTime,
        });
    } catch (error) {
        console.error("Error setting media session position state:", error);
    }
}

function setupMediaSessionActions() {
    if (!('mediaSession' in navigator)) return;

    navigator.mediaSession.setActionHandler('play', () => playPauseBtn.click());
    navigator.mediaSession.setActionHandler('pause', () => playPauseBtn.click());
    navigator.mediaSession.setActionHandler('nexttrack', () => playNextSong({ userInitiated: true }));
    navigator.mediaSession.setActionHandler('previoustrack', () => playPreviousSong());
    navigator.mediaSession.setActionHandler('stop', () => resetPlayer());

    navigator.mediaSession.setActionHandler('seekforward', (d) => { audioPlayer.currentTime = Math.min(audioPlayer.currentTime + (d.seekOffset || 10), audioPlayer.duration); });
    navigator.mediaSession.setActionHandler('seekbackward', (d) => { audioPlayer.currentTime = Math.max(audioPlayer.currentTime - (d.seekOffset || 10), 0); });
    navigator.mediaSession.setActionHandler('seekto', (d) => { audioPlayer.currentTime = d.seekTime; });
}
        
window.addEventListener("beforeunload", () => {
    if (currentSongId !== null) {
        localStorage.setItem("currentSong", JSON.stringify({
            id: currentSongId,
            progress: audioPlayer.currentTime
        }));
    } else {
        localStorage.removeItem("currentSong");
    }
});

window.addEventListener("load", async () => {
    try {
        if (isMobile) {
            document.body.classList.add('is-mobile');
        }
        
        await initDB();
        initModalVariables();

        if ('showDirectoryPicker' in window) {
            const tx = db.transaction('config', 'readonly');
            const handleReq = tx.objectStore('config').get('directoryHandles');
            const configResult = await new Promise(r => { handleReq.onsuccess = () => r(handleReq.result) });
            
            if (configResult && Array.isArray(configResult.value)) {
                const verifiedHandles = [];
                for (const handle of configResult.value) {
                    if (await verifyPermission(handle, false)) { // Don't prompt on load
                        verifiedHandles.push(handle);
                    }
                }
                directoryHandles = verifiedHandles;
                console.log(`Restored and verified ${directoryHandles.length} folder handles.`);
            }
        }

        // --- Load SoundCloud Settings ---
        const configTx = db.transaction('config', 'readonly');
        const scIdReq = configTx.objectStore('config').get('soundcloudClientId');
        const scEnabledReq = configTx.objectStore('config').get('isSoundcloudEnabled');
        const lrclibReq = configTx.objectStore('config').get('isLrclibEnabled'); 
        
        const scIdResult = await new Promise(r => { scIdReq.onsuccess = () => r(scIdReq.result) });
        const scEnabledResult = await new Promise(r => { scEnabledReq.onsuccess = () => r(scEnabledReq.result) });
        const lrclibEnabledResult = await new Promise(r => { lrclibReq.onsuccess = () => r(lrclibReq.result) }); 
        
        soundcloudClientId = scIdResult ? scIdResult.value : '';
        isSoundcloudEnabled = scEnabledResult ? scEnabledResult.value : false;
        isLrclibEnabled = lrclibEnabledResult ? lrclibEnabledResult.value : false;
        toggleSoundcloudTab();

        await loadSongsAndPlaylists();
        await scanForNewSongs();
        await migrateToFSA();

        const savedData = localStorage.getItem("currentSong");
        if (savedData) {
            const { id, progress } = JSON.parse(savedData);
            const song = songs.find(s => s.id === id);
            if (song) {
                currentSongId = song.id;
                currentlyPlayingSong = song;
                updatePlayerUI(song);
                updateMiniplayerUI(song, 'paused');
                playPauseIcon.textContent = 'play_arrow';
                playPauseBtn.classList.remove('playing');
                isQueueUserModified = false;
                updatePlayQueue();
                const fileUrl = await getSongFileUrl(song);
                if (fileUrl) {
                    audioPlayer.src = fileUrl;
                    audioPlayer.load();
                    audioPlayer.onloadedmetadata = () => {
                         audioPlayer.currentTime = progress || 0;
                         updateTimeDisplays();
                         audioPlayer.onloadedmetadata = null;
                    };
                }
            }
        }
        
        setView('home');
        initDistortionCanvas();
    } catch (error) {
        console.error('Critical error on application load:', error);
    }
});

async function verifyPermission(handle, shouldRequest = false) {
    const options = { mode: 'read' };
    if (await handle.queryPermission(options) === 'granted') return true;
    if (shouldRequest && await handle.requestPermission(options) === 'granted') return true;
    console.warn(`Permission not granted for folder: ${handle.name}`);
    return false;
}

        function updatePlayerUI(song, progress = 0) {
            musicTitle.textContent = sanitize(song.name);
            musicArtist.textContent = song.artist;
            albumArtImg.src = song.albumArt;
            albumArtImg.classList.remove('fade-out');
            updateAllBackgrounds(song.albumArt);
            updateFavicon(song.albumArt);
            updateTimeDisplays(progress, audioPlayer.duration);
        }

        function updateTimeDisplays(current = 0, duration = 0) {
            currentTimeDisplay.textContent = formatTime(current);
            durationDisplay.textContent = formatTime(duration);
        }

let currentLrcLineIndex = -1;

audioPlayer.addEventListener('timeupdate', async () => {
    if (currentSongId) {
        const song = currentlyPlayingSong;
        const percentage = (audioPlayer.currentTime / audioPlayer.duration) * 100;
        progress.style.width = `${percentage}%`;
        const scaledPercentage = (percentage / 100) * 93;
        miniplayerProgress.style.width = `${scaledPercentage}%`;
        updateTimeDisplays(audioPlayer.currentTime, audioPlayer.duration);
        updatePageTitle();

        // Only log plays for local songs
        if (song && song.storage !== 'soundcloud' && !song.hasBeenLogged && audioPlayer.currentTime > 30) {
            song.hasBeenLogged = true;
            await logSongPlay(song.id);
        }

        if (audioPlayer.duration) Gurasuraisu.updateMediaProgress({ currentTime: audioPlayer.currentTime, duration: audioPlayer.duration });
        if ('mediaSession' in navigator) updateMediaSessionPositionState();
        if (crossfadeEnabled && audioPlayer.duration > 0 && audioPlayer.duration - audioPlayer.currentTime < 3 && !audioPlayer.isFading) {
             audioPlayer.isFading = true;
             playNextSong({ isTransition: true });
        }

        if (song && song.lrcData && isPanelVisible && panelContent === 'lyrics') {
            const currentTime = audioPlayer.currentTime;
            let newLrcLineIndex = -1;

            for (let i = 0; i < song.lrcData.length; i++) {
                if (song.lrcData[i].time <= currentTime) newLrcLineIndex = i;
                else break;
            }
            
            if (newLrcLineIndex !== currentLrcLineIndex) {
                const allLyricElements = document.querySelectorAll('#lyrics-scroll-container p');
                if(allLyricElements.length === 0) return;

                const MAX_BLUR = 5.0, BLUR_STEP = 1.5, MIN_OPACITY = 0.4, OPACITY_STEP = 0.2;
                
                allLyricElements.forEach((el, index) => {
                    const distance = Math.abs(index - newLrcLineIndex);
                    const blurValue = (distance === 0) ? 0 : Math.min(MAX_BLUR, distance * BLUR_STEP);
                    const opacityValue = (distance === 0) ? 1 : Math.max(MIN_OPACITY, 1 - distance * OPACITY_STEP);
                    el.style.filter = `blur(${blurValue}px)`;
                    el.style.opacity = opacityValue;
                });

                const newLine = document.getElementById(`lyric-line-${newLrcLineIndex}`);
                if (newLine) newLine.scrollIntoView({ behavior: 'smooth', block: 'start' });

                currentLrcLineIndex = newLrcLineIndex;
            }
        }
    }
});
        
playPauseBtn.addEventListener('click', async () => {
    if (audioContext && audioContext.state === 'suspended') {
        await audioContext.resume();
    }
    if (!currentSongId) return;

    if (!isVisualizerInitialized) initVisualizer();

    if (audioPlayer.paused) {
        if ('mediaSession' in navigator && navigator.mediaSession.metadata === null) {
            const song = currentlyPlayingSong;
            if (song) {
                updateMediaSessionMetadata(song);
                Gurasuraisu.registerMediaSession(
                    { title: song.name, artist: song.artist, album: song.album, artwork: [{ src: song.albumArt }] },
                    ['playPause', 'next', 'prev']
                );
            }
        }
        
        audioPlayer.play().then(() => {
            playPauseIcon.textContent = 'pause';
            playPauseBtn.classList.add('playing');
            updateMiniplayerUI(currentlyPlayingSong, 'playing');
            if (!document.body.classList.contains('reduce-animations')) {
            }
            updateMediaSessionPlaybackState('playing');
            Gurasuraisu.updatePlaybackState({ playbackState: 'playing' });
        }).catch(error => console.error("Play failed:", error));
    } else {
        audioPlayer.pause();
        playPauseIcon.textContent = 'play_arrow';
        playPauseBtn.classList.remove('playing');
        updateMiniplayerUI(currentlyPlayingSong, 'paused');
        updateMediaSessionPlaybackState('paused');
        Gurasuraisu.updatePlaybackState({ playbackState: 'paused' });
    }
});
        
nextBtn.addEventListener('click', async () => await playNextSong({ userInitiated: true }));
prevBtn.addEventListener('click', () => playPreviousSong());

function seekAudio(e) {
    if(isNaN(audioPlayer.duration)) return;
    const rect = progressBar.getBoundingClientRect();
    const clickX = Math.max(0, Math.min(e.clientX, rect.right)) - rect.left;
    const percent = Math.max(0, Math.min(1, clickX / rect.width));
    audioPlayer.currentTime = percent * audioPlayer.duration;
}

function handleProgressDrag(e) { if (isDragging) seekAudio(e.touches ? e.touches[0] : e); }

function closePanel() {
    if (!isPanelVisible) return;
    isPanelVisible = false;
    
    // Remove the 'visible' class from the panel
    document.getElementById('lyrics-queue-panel').classList.remove('visible');
    
    // Remove the 'active' class from the buttons
    document.querySelector('.lyrics-button').classList.remove('active');
    document.querySelector('.queue-button').classList.remove('active');
    
    // Update the .now-playing-wrapper styles
    const nowPlayingWrapper = document.querySelector('.now-playing-wrapper');
    if (nowPlayingWrapper) {
        nowPlayingWrapper.style.padding = '5px';
        nowPlayingWrapper.style.alignItems = 'center';
    }
}
        
progressBar.addEventListener("click", e => seekAudio(e));
progressBar.addEventListener("mousedown", () => { isDragging = true; });
document.addEventListener("mouseup", () => { isDragging = false; });
document.addEventListener("mousemove", e => handleProgressDrag(e));
progressBar.addEventListener("touchstart", () => { isDragging = true; }, { passive: true });
document.addEventListener("touchend", () => { isDragging = false; });
document.addEventListener("touchmove", e => handleProgressDrag(e), { passive: true });


volumeSlider.addEventListener('input', (e) => {
    const volume = e.target.value / 100;
    audioPlayer.volume = volume;
    if (volume === 0) volumeIcon.textContent = 'volume_mute';
    else if (volume < 0.5) volumeIcon.textContent = 'volume_down';
    else volumeIcon.textContent = 'volume_up';
});

audioPlayer.addEventListener('play', () => {
    if (!document.body.classList.contains('reduce-animations')) {
    }
});

audioPlayer.addEventListener('ended', () => {
    audioPlayer.isFading = false;
    playNextSong(); 
});

audioPlayer.addEventListener('durationchange', updateMediaSessionPositionState);
audioPlayer.addEventListener('loadedmetadata', updateMediaSessionPositionState);

document.addEventListener('DOMContentLoaded', async () => {
    try {
        await initDB();
        searchInput = document.getElementById('searchInput');
        const musicUploadInput = document.getElementById('musicUpload');
        const libraryGrid = document.getElementById('library-grid');
        
        searchInput.addEventListener('input', () => {
            clearTimeout(searchTimeout);
            searchTimeout = setTimeout(() => {
                if (activeView === 'search') {
                    renderSearchResults();
                }
            }, 300);
        });

        document.getElementById('search-results-grid').addEventListener('click', (e) => {
            const songItem = e.target.closest('.music-item[data-id]');
            if (songItem) {
                const songId = parseFloat(songItem.dataset.id);
                const song = songs.find(s => s.id === songId);
                if (song) {
                    // Get context from the search results
                    const contextSongs = Array.from(document.querySelectorAll('#search-results-grid .music-item[data-id]'))
                        .map(item => songs.find(s => s.id === parseFloat(item.dataset.id)))
                        .filter(Boolean);

                    isShuffleEnabled = false; 
                    updateShuffleButtonState();
                    
                    playSong(song, contextSongs);
                }
            }
        });
        
        document.getElementById('home-view').addEventListener('click', (e) => {
            const highlightCard = e.target.closest('.highlight-card[data-id]');
            const albumCard = e.target.closest('.item-card[data-album-id]');
    
            if (highlightCard) {
                const songId = parseFloat(highlightCard.dataset.id);
                const song = songs.find(s => s.id === songId);
                if (song) {
                    // Play this single song as its own context
                    playSong(song, [song]);
                }
            } else if (albumCard) {
                const albumId = albumCard.dataset.albumId;
                const [artist, albumName] = albumId.split('::');
                // When playing from a "Recently Played" album card, play the first song of that album
                const songToPlay = songs.find(s => s.albumArtist === artist && s.album === albumName);
                if(songToPlay) {
                    // The context is all songs from that album
                    const albumContext = songs.filter(s => s.albumArtist === artist && s.album === albumName);
                    playSong(songToPlay, albumContext);
                }
            }
        });

        libraryGrid.addEventListener('click', (e) => {
            const songItem = e.target.closest('.music-item[data-id]');
            const albumCard = e.target.closest('.item-card[data-album-id]');
            const artistCard = e.target.closest('.item-card[data-artist-name]');
            const playlistCard = e.target.closest('.item-card[data-playlist-id]');

            if (songItem) {
                const songId = parseFloat(songItem.dataset.id);
                const song = songs.find(s => s.id === songId);
                if (song) {
                    // Get the context from the currently displayed list
                    const contextSongs = Array.from(libraryGrid.querySelectorAll('.music-item[data-id]'))
                        .map(item => songs.find(s => s.id === parseFloat(item.dataset.id)))
                        .filter(Boolean);
                    isShuffleEnabled = false; 
                    updateShuffleButtonState();
                    playSong(song, contextSongs);
                }
            } else if (albumCard) {
                const albumId = albumCard.dataset.albumId;
                const [artist, albumName] = albumId.split('::');
                const albumSongs = songs.filter(s => s.albumArtist === artist && s.album === albumName).sort((a,b) => (a.trackNumber || 0) - (b.trackNumber || 0));
                const contentHtml = `<div class="item-list">${albumSongs.map(song => `
                    <div class="music-item" data-id="${song.id}" style="cursor: pointer;">
                        <div class="song-info">
                            <span class="track-number">${song.trackNumber || ''}</span>
                            <div class="song-title">${sanitize(song.name)}</div>
                        </div>
                    </div>`).join('')}</div>`;
                openDrawer(albumName, artist, contentHtml);
            } else if (artistCard) {
                const artistName = artistCard.dataset.artistName;
                const artistAlbums = groupSongsByAlbum(songs.filter(s => s.artist === artistName));
                const contentHtml = `<div class="item-grid">${artistAlbums.map(album => `
                    <div class="item-card" data-album-id="${album.artist}::${album.originalAlbum}">
                        <img src="${album.albumArt}" alt="${album.name}" class="item-card-art">
                        <div class="item-card-info">
                            <div class="item-card-title">${sanitize(album.name)}</div>
                        </div>
                    </div>`).join('')}</div>`;
                openDrawer(artistName, `${artistAlbums.length} albums`, contentHtml); // Pass details
            } else if (playlistCard) {
                 const playlistId = parseInt(playlistCard.dataset.playlistId, 10);
                 const playlist = playlists.find(p => p.id === playlistId);
                 const playlistSongs = playlist.songIds.map(id => songs.find(s => s.id === id)).filter(Boolean);
                 const contentHtml = `<div class="item-list">${playlistSongs.map(song => `
                    <div class="music-item" data-id="${song.id}" style="cursor: pointer;">
                         <div class="song-info">
                            <img src="${song.albumArt}" class="album-thumbnail" style="width: 40px; height: 40px; border-radius: 8px; margin-right: 6px;">
                            <div>
                                <div class="song-title">${sanitize(song.name)}</div>
                                <div class="album-artist" style="font-size: 0.8em;">${sanitize(song.artist)}</div>
                            </div>
                        </div>
                    </div>`).join('')}</div>`;
                openDrawer(playlist.name, `${playlistSongs.length} songs`, contentHtml, { type: 'playlist', id: playlistId }); // Pass details
            }
        });

        drawerContent.addEventListener('click', (e) => {
            const localSongItem = e.target.closest('.music-item[data-id]');
            const soundcloudSongItem = e.target.closest('.music-item[data-track-id]');
            const songItem = e.target.closest('.music-item[data-id]');
            const albumCard = e.target.closest('.item-card[data-album-id]');
            const backButton = e.target.closest('.drawer-back-btn'); // Correctly find the button

            if (backButton) {
                const artistName = backButton.dataset.artistName;
                const artistAlbums = groupSongsByAlbum(songs.filter(s => s.albumArtist === artistName));
                const contentHtml = `<div class="item-grid">${artistAlbums.map(album => {
                    const albumId = `${album.artist}::${album.originalAlbum}`;
                    return `
                    <div class="item-card" data-album-id="${sanitize(albumId)}">
                        <img src="${album.albumArt}" alt="${sanitize(album.name)}" class="item-card-art">
                        <div class="item-card-info">
                            <div class="item-card-title">${sanitize(album.name)}</div>
                        </div>
                    </div>`;
                }).join('')}</div>`;
                openDrawer(sanitize(artistName), `${artistAlbums.length} albums`, contentHtml);
            } else if (localSongItem) {
                // Logic for playing a local song from the library
                const songId = parseFloat(localSongItem.dataset.id);
                const song = songs.find(s => s.id === songId);
                if (song) {
                    const contextSongs = Array.from(drawerContent.querySelectorAll('.music-item[data-id]'))
                        .map(item => songs.find(s => s.id === parseFloat(item.dataset.id)))
                        .filter(Boolean);
                    playSong(song, contextSongs.length > 0 ? contextSongs : [song]);
                    closeDrawer();
                }
            } else if (soundcloudSongItem) {
                // Build the context from all SoundCloud songs currently in the drawer
                const trackId = soundcloudSongItem.dataset.trackId;
                const contextNodes = drawerContent.querySelectorAll('.music-item[data-track-id]');
                const playContext = Array.from(contextNodes).map(node => ({
                    id: Number(node.dataset.trackId),
                    name: node.querySelector('.song-title').textContent,
                    artist: node.querySelector('.album-artist').textContent,
                    albumArt: node.querySelector('img').src,
                    storage: 'soundcloud'
                }));
                playSoundcloudTrack(trackId, playContext);
                closeDrawer();
            } else if (albumCard) {
                const albumId = albumCard.dataset.albumId;
                const [artist, albumName] = albumId.split('::');
                const albumSongs = songs.filter(s => s.albumArtist === artist && s.album === albumName).sort((a,b) => (a.trackNumber || 0) - (b.trackNumber || 0));
                
                // This now includes the back button in the generated HTML
                const contentHtml = `
                    <button class="action-btn drawer-back-btn" data-artist-name="${sanitize(artist)}"><span class="material-symbols-rounded">arrow_back</span> Back</button>
                    <div class="item-list" style="margin-top: 15px;">
                        ${albumSongs.map(song => `
                        <div class="music-item" data-id="${song.id}" style="cursor: pointer;">
                            <div class="song-info">
                                <span class="track-number">${song.trackNumber || ''}</span>
                                <div class="song-title">${sanitize(song.name)}</div>
                            </div>
                        </div>`).join('')}
                    </div>`;
                
                document.getElementById('drawer-title').textContent = sanitize(albumName);
                document.getElementById('drawer-subtitle').textContent = sanitize(artist);
                drawerContent.innerHTML = contentHtml;
            }
        });

        document.getElementById('uploadBtn').addEventListener('click', async () => {
            if ('showDirectoryPicker' in window) {
                try {
                    const handle = await window.showDirectoryPicker();
                    if (await verifyPermission(handle, true)) {
                        directoryHandles.push(handle);
                        const tx = db.transaction('config', 'readwrite');
                        tx.objectStore('config').put({ key: 'directoryHandles', value: directoryHandles });
                        await tx.done;
                        await processDirectory(handle);
                    }
                } catch (err) {
                    if (err.name !== 'AbortError') console.error('Error picking directory:', err);
                }
            } else {
                musicUploadInput.click();
            }
        });

        musicUploadInput.addEventListener('change', (e) => {
            if (e.target.files.length > 0) addSongs(e.target.files, 'indexeddb');
        });
        
        document.querySelectorAll('.filter-container .filter-btn').forEach(btn => {
            btn.addEventListener('click', () => {
                document.querySelector('.filter-container .filter-btn.active').classList.remove('active');
                btn.classList.add('active');
                currentFilter = btn.dataset.filter;
                if (activeView === 'library') renderLibraryPage();
            });
        });

        const sortBtn = document.getElementById('sortBtn');
        const sortModeDisplay = document.getElementById('sort-mode-display');

        sortBtn.addEventListener('click', () => {
            // Toggle the sort mode
            currentSortMode = currentSortMode === 'alpha' ? 'dateAdded' : 'alpha';
            
            // Update the button's appearance
            if (currentSortMode === 'alpha') {
                sortBtn.innerHTML = `<span class="material-symbols-rounded">sort_by_alpha</span><span id="sort-mode-display"></span>`;
            } else {
                sortBtn.innerHTML = `<span class="material-symbols-rounded">history</span><span id="sort-mode-display"></span>`;
            }
            
            // Re-render the library with the new sorting
            renderLibraryPage();
        });

        // ADD listener for the new "Save to Library" button
        document.getElementById('menuSaveToLibrary').addEventListener('click', () => {
            saveSoundcloudTrackToLibrary();
            moreOptionsMenu.classList.remove('visible');
        });
    
        // ADD listener for the offline search input
        document.getElementById('soundcloudOfflineSearchInput').addEventListener('input', renderOfflineSoundcloudView);
    
        // ADD listeners for the new filter buttons
        document.getElementById('soundcloud-filter-container').addEventListener('click', (e) => {
            const btn = e.target.closest('.filter-btn-sc');
            if (btn) {
                document.querySelector('#soundcloud-filter-container .filter-btn-sc.active').classList.remove('active');
                btn.classList.add('active');
                soundcloudFilter = btn.dataset.filter;
                renderSoundcloudSearchResults();
            }
        });

        document.body.addEventListener('click', async (e) => {
            // AI Playlist Creation Button
            if (e.target.id === 'aiCreatePlaylistBtn') {
                const promptInput = document.getElementById('aiPlaylistPrompt');
                const prompt = promptInput.value.trim();
                if (!prompt) return;
        
                e.target.htmlContent = '<svg width="18" height="18" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg" style="color: var(--text-color);"><style>.spinner_V8m1{transform-origin:center;animation:spinner_zKoa 2s linear infinite}.spinner_V8m1 circle{stroke-linecap:round;animation:spinner_YpZS 1.5s ease-in-out infinite}@keyframes spinner_zKoa{100%{transform:rotate(360deg)}}@keyframes spinner_YpZS{0%{stroke-dasharray:0 150;stroke-dashoffset:0}47.5%{stroke-dasharray:42 150;stroke-dashoffset:-16}95%,100%{stroke-dasharray:42 150;stroke-dashoffset:-59}}</style><g class="spinner_V8m1"><circle cx="12" cy="12" r="9.5" fill="none" stroke-width="3"></circle></g></svg>';
                e.target.disabled = true;
        
                const fullPrompt = `${prompt}\n\nLibrary:\n${formatLibraryForPrompt()}`;
                const result = await musicAiModel.generateContent(fullPrompt);
                const call = result.response.functionCalls()?.[0];
                if (call && call.name === 'createPlaylist') {
                    availableMusicFunctions.createPlaylist(call.args);
                } else {
                    Gurasuraisu.showPopup("GuraAI was unable to create a playlist from that prompt.");
                }
                promptInput.value = '';
                e.target.htmlContent = '<span class="material-symbols-rounded" style="font-size: 18px;">add</span>';
                e.target.disabled = false;
            }
        
            // --- AI Home Page Prompt Bar & Dynamic Buttons ---
            const handleHomeAiPrompt = async (prompt) => {
                if (!prompt || !musicAiModel) return;
                const fullPrompt = `${prompt}\n\nLibrary:\n${formatSongsForAiPrompt(songs)}`;
                try {
                    const result = await musicAiModel.generateContent(fullPrompt);
                    const call = result.response.functionCalls()?.[0];
        
                    if (call && call.name === 'createPlaylist') {
                        availableMusicFunctions.createPlaylist(call.args);
                    } else if (call && call.name === 'getSongRecommendations') {
                        const recommendedSongs = call.args.songs.map(s => findSongByString(s)).filter(Boolean);
                        if (recommendedSongs.length > 0) {
                             const contentHtml = `<div class="item-list">${recommendedSongs.map(song => `
                                <div class="music-item" data-id="${song.id}" style="cursor: pointer;">
                                     <div class="song-info">
                                        <img src="${song.albumArt}" class="album-thumbnail" style="width: 40px; height: 40px; border-radius: 8px; margin-right: 6px;">
                                        <div><div class="song-title">${sanitize(song.name)}</div><div class="album-artist" style="font-size: 0.8em;">${sanitize(song.artist)}</div></div>
                                    </div>
                                </div>`).join('')}</div>`;
                            openDrawer("GuraAI Recommendations", prompt, contentHtml);
                        } else {
                             Gurasuraisu.showPopup("GuraAI couldn't find any matching songs for that.");
                        }
                    } else {
                        Gurasuraisu.showPopup("GuraAI could not process that request.");
                    }
                } catch (err) {
                    console.error("Error handling Home AI Prompt:", err);
                    Gurasuraisu.showPopup("An error occurred with the AI request.");
                }
            };
        
            if (e.target.id === 'aiPromptSubmit') {
                const input = document.getElementById('aiPromptInput');
                handleHomeAiPrompt(input.value.trim());
                input.value = '';
            }
        
            if (e.target.matches('#ai-dynamic-prompts .action-btn')) {
                handleHomeAiPrompt(e.target.dataset.prompt);
            }

            if (e.target.closest('#drawer-delete-playlist-btn')) {
                const button = e.target.closest('#drawer-delete-playlist-btn');
                const playlistId = parseInt(button.dataset.playlistId, 10);
                if (playlistId) {
                    deletePlaylist(playlistId);
                }
            }
        });
        
        setupLongPressListeners(document.getElementById('library-grid'));
        setupLongPressListeners(document.getElementById('search-results-grid'));
        setupLongPressListeners(drawerContent);

        initVisualizer();
        setupMediaSessionActions();

        document.getElementById('shuffleBtn').addEventListener('click', toggleShuffle);
        document.getElementById('repeatBtn').addEventListener('click', toggleRepeat);

        const lyricsQueuePanel = document.getElementById('lyrics-queue-panel');
        isPanelVisible = false;
        panelContent = null; // 'lyrics' or 'queue'

        const togglePanel = (newContent) => {
            if (isPanelVisible && panelContent === newContent) {
                closePanel();
            } else {
                // Show or switch the panel
                isPanelVisible = true;
                panelContent = newContent;
                
                if (panelContent === 'lyrics') {
                    renderLyrics();
                } else {
                    renderQueue();
                    scrollToCurrentSongInQueue();
                }
                
                lyricsQueuePanel.classList.add('visible');

                // Only modify .now-playing-wrapper if viewport is 981px or larger
                const nowPlayingWrapper = document.querySelector('.now-playing-wrapper');
                if (nowPlayingWrapper && window.innerWidth >= 981) {
                    nowPlayingWrapper.style.setProperty('padding', '5px 20px 5px 5px', 'important');
                    nowPlayingWrapper.style.setProperty('align-items', 'flex-end', 'important');
                }
            }
            
            document.querySelector('.lyrics-button').classList.toggle('active', isPanelVisible && panelContent === 'lyrics');
            document.querySelector('.queue-button').classList.toggle('active', isPanelVisible && panelContent === 'queue');
        };
        
        document.querySelector('.lyrics-button').addEventListener('click', () => togglePanel('lyrics'));
        document.querySelector('.queue-button').addEventListener('click', () => togglePanel('queue'));
                
        tabBtns.forEach(btn => {
            btn.addEventListener('click', () => {
                if (isDrawerOpen) {
                    closeDrawer();
                    return; 
                }
                const viewName = btn.dataset.view;
                const currentViewElement = document.getElementById(`${activeView}-view`);
                if (currentViewElement) {
                    scrollPositions[activeView] = currentViewElement.scrollTop;
                }
                setView(viewName);
            });
        });
    
        miniplayer.addEventListener('click', (e) => {
            if (e.target.closest('.mini-control-btn')) return;
        
            const currentViewElement = document.getElementById(`${activeView}-view`);
            if (currentViewElement) {
                scrollPositions[activeView] = currentViewElement.scrollTop;
            }
        
            setView('now-playing');
        });
        
        // Wire up miniplayer controls
        miniplayerPlayBtn.addEventListener('click', (e) => {
            e.stopPropagation();
            playPauseBtn.click();
        });
        document.getElementById('miniplayer-next-btn').addEventListener('click', (e) => {
            e.stopPropagation();
            nextBtn.click();
        });
        document.getElementById('miniplayer-prev-btn').addEventListener('click', (e) => {
            e.stopPropagation();
            prevBtn.click();
        });

        const nowPlayingView = document.getElementById('now-playing-view');
        const moreButton = nowPlayingView.querySelector('.more-button');
        const moreOptionsMenu = document.getElementById('moreOptionsMenu');

        moreButton.addEventListener('click', (e) => {
            e.stopPropagation();
            if (!currentSongId || !currentlyPlayingSong) {
                Gurasuraisu.showPopup('No song is currently playing');
                return;
            }
            
            const isLocal = currentlyPlayingSong.storage !== 'soundcloud';
        
            // Show/hide menu items based on song type
            document.getElementById('menuEditMetadata').style.display = isLocal ? 'flex' : 'none';
            document.getElementById('menuDeleteSong').style.display = isLocal ? 'flex' : 'none';
            document.getElementById('menuAddToPlaylist').style.display = isLocal ? 'flex' : 'none';

            // Show "Save to Library" ONLY for SoundCloud songs.
            document.getElementById('menuSaveToLibrary').style.display = isLocal ? 'none' : 'flex';
                    
            moreOptionsMenu.classList.toggle('visible');
        });

        document.addEventListener('click', (e) => {
            // Close menu if clicking outside of it or its trigger button
            if (!e.target.closest('#moreOptionsMenu') && !e.target.closest('.more-button')) {
                moreOptionsMenu.classList.remove('visible');
            }
        });

        document.getElementById('menuDeleteSong').addEventListener('click', async () => {
            if (currentSongId && confirm('Delete this song? This is permanent.')) await deleteSong(currentSongId);
            moreOptionsMenu.classList.remove('visible');
        });
        
        document.getElementById('menuFullscreenBtn').addEventListener('click', () => {
            isFullscreen = !isFullscreen; // Toggle the state
            toolbar.classList.toggle('hidden', isFullscreen); // Update toolbar based on new state
        
            // Toggle additional styles based on fullscreen state
            const albumArt = document.querySelector('.album-art');
            const playerControls = document.querySelector('.player-controls');
            const volumeControl = document.querySelector('.volume-control');
            
            if (albumArt) {
                albumArt.style.setProperty('margin-top', isFullscreen ? '0px' : '', 'important');
            }
            
            if (playerControls) {
                playerControls.style.display = isFullscreen ? 'none' : '';
            }
        
            if (volumeControl) {
                volumeControl.style.display = isFullscreen ? 'none' : '';
            }
        });
        
        document.getElementById('menuEditMetadata').addEventListener('click', () => { if (currentSongId) openEditModal(currentSongId); moreOptionsMenu.classList.remove('visible'); });
        document.getElementById('menuCrossfade').addEventListener('click', toggleCrossfade);
        document.getElementById('menuSleepTimer').addEventListener('click', () => { openModal(sleepTimerModal); moreOptionsMenu.classList.remove('visible'); });
        document.getElementById('menuAddToPlaylist').addEventListener('click', () => { if (currentSongId) openPlaylistModal(); moreOptionsMenu.classList.remove('visible'); });
        document.getElementById('menuEqualizer').addEventListener('click', () => { openModal(equalizerModal); moreOptionsMenu.classList.remove('visible'); });

        document.getElementById('shuffleBtn').addEventListener('click', toggleShuffle);
        document.getElementById('repeatBtn').addEventListener('click', toggleRepeat);

        document.getElementById('manageFoldersBtn').addEventListener('click', openManageFoldersModal);
        document.getElementById('saveIntegrations').addEventListener('click', saveIntegrationSettings);

        const soundcloudSearchInput = document.getElementById('soundcloudSearchInput');
        soundcloudSearchInput.addEventListener('input', () => {
            clearTimeout(soundcloudSearchTimeout);
            soundcloudSearchTimeout = setTimeout(searchSoundCloud, 300);
        });
        
        document.getElementById('soundcloud-results-grid').addEventListener('click', e => {
            const trackCard = e.target.closest('.item-card[data-track-id]');
            const cachedCard = e.target.closest('.music-item[data-cached-id]');
            const artistCard = e.target.closest('.item-card[data-artist-name]');
            const albumCard = e.target.closest('.item-card[data-album-name]');
        
            if (trackCard) {
                // Build the context from the current search results
                const playContext = lastSoundcloudSearchResults.map(track => ({
                    id: track.id,
                    name: track.title,
                    artist: track.user.username,
                    album: 'SoundCloud',
                    albumArt: getHighResArtwork(track.artwork_url),
                    storage: 'soundcloud'
                }));
                playSoundcloudTrack(trackCard.dataset.trackId, playContext);
            } else if (cachedCard) {
                const trackId = parseFloat(cachedCard.dataset.cachedId);
                // When playing from offline view, the context is all other visible offline songs
                const contextNodes = document.querySelectorAll('#soundcloud-results-grid .music-item[data-cached-id]');
                const playContext = Array.from(contextNodes).map(node => {
                    return {
                        id: parseFloat(node.dataset.cachedId),
                        name: node.querySelector('.song-title').textContent,
                        artist: node.querySelector('.album-artist').textContent,
                        albumArt: node.querySelector('img').src,
                        storage: 'soundcloud'
                    };
                });
                playSoundcloudTrack(trackId, playContext);
            } else if (artistCard) {
                // An artist was clicked in the online search view
                const artistName = artistCard.dataset.artistName;
                const artistTracks = lastSoundcloudSearchResults.filter(t => t.user.username === artistName);
                
                const contentHtml = `<div class="item-list">${artistTracks.map(track => { // <-- track is defined here
                    // **THE FIX:** Use the 'track' object from the map, not 'songObject'.
                    const artwork = getHighResArtwork(track.artwork_url);
                    return `
                    <div class="music-item" data-track-id="${track.id}" style="cursor: pointer;">
                         <div class="song-info">
                            <img src="${artwork}" class="album-thumbnail" style="width: 40px; height: 40px; border-radius: 8px; margin-right: 6px;">
                            <div>
                                <div class="song-title">${sanitize(track.title)}</div>
                                <div class="album-artist" style="font-size: 0.8em;">${sanitize(track.user.username)}</div>
                            </div>
                        </div>
                    </div>
                    `}).join('')}</div>`;
                
                openDrawer(artistName, `${artistTracks.length} tracks found`, contentHtml);
            } else if (albumCard) {
                // An album was clicked in the online search view
                const albumName = albumCard.dataset.albumName;
                const albumTracks = lastSoundcloudSearchResults.filter(t => t.title.split('-')[0].trim() === albumName);
                const representativeArtist = albumTracks.length > 0 ? albumTracks[0].user.username : '';
        
                const contentHtml = `<div class="item-list">${albumTracks.map(track => { // <-- track is defined here
                    // **THE FIX:** Use the 'track' object from the map, not 'songObject'.
                    const artwork = getHighResArtwork(track.artwork_url);
                    return `
                    <div class="music-item" data-track-id="${track.id}" style="cursor: pointer;">
                         <div class="song-info">
                            <img src="${artwork}" class="album-thumbnail" style="width: 40px; height: 40px; border-radius: 8px; margin-right: 6px;">
                            <div>
                                <div class="song-title">${sanitize(track.title)}</div>
                                <div class="album-artist" style="font-size: 0.8em;">${sanitize(track.user.username)}</div>
                            </div>
                        </div>
                    </div>
                    `}).join('')}</div>`;
        
                openDrawer(albumName, representativeArtist, contentHtml);
            }
        });
    
        // Add the new listener for the offline toggle
        document.getElementById('soundcloudOfflineToggle').addEventListener('click', () => {
            isSoundcloudOfflineMode = !isSoundcloudOfflineMode;
            renderSoundcloudPage();
        });

        setupDrawerInteractions();
    } catch (error) {
        console.error('Failed to initialize application:', error);
    }
});

// Call the AI initializer on page load
initializeMusicAi();

document.getElementById('uploadBtn').addEventListener('click', async () => {
    if ('showDirectoryPicker' in window) {
        try {
            const handle = await window.showDirectoryPicker();
            
            for (const existingHandle of directoryHandles) {
                if (await handle.isSameEntry(existingHandle)) {
                    Gurasuraisu.showPopup("This folder has already been added.");
                    return;
                }
            }

            if (await verifyPermission(handle, true)) {
                directoryHandles.push(handle);
                const tx = db.transaction('config', 'readwrite');
                tx.objectStore('config').put({ key: 'directoryHandles', value: directoryHandles });
                await tx.done;
                await processDirectory(handle);
            }
        } catch (err) {
            if (err.name !== 'AbortError') console.error('Error picking directory:', err);
        }
    } else {
        document.getElementById('musicUpload').click();
    }
});

        musicUpload.addEventListener('change', (e) => {
            if (e.target.files.length > 0) addSongs(e.target.files, 'indexeddb');
        });
        
        async function processDirectory(handle) {
            const filesToAdd = [];
            const existingSongNames = new Set(songs.map(s => s.handleName));

            for await (const entry of handle.values()) {
                if (entry.kind === 'file' && isAudioFile({ name: entry.name }) && !existingSongNames.has(entry.name)) {
                    filesToAdd.push(entry);
                }
            }

            if (filesToAdd.length > 0) {
                Gurasuraisu.showPopup(`${filesToAdd.length} new songs added to Library`);
                await addSongs(filesToAdd, 'filesystem');
            } else {
                Gurasuraisu.showPopup('No new songs found in the selected directory.');
            }
        }

        function toggleCrossfade() {
            crossfadeEnabled = !crossfadeEnabled;
            document.getElementById('crossfadeStatus').textContent = crossfadeEnabled ? 'On' : 'Off';
        }

        function setSleepTimer(minutes) {
            clearTimeout(sleepTimerId);
            if (minutes > 0) {
                sleepTimerId = setTimeout(() => {
                    audioPlayer.pause();
                    playPauseIcon.textContent = 'play_arrow';
                    playPauseBtn.classList.remove('playing');
                }, minutes * 60 * 1000);
                Gurasuraisu.showPopup(`Sleep timer set for ${minutes} minutes.`);
            } else {
                Gurasuraisu.showPopup('Sleep timer cancelled.');
            }
            closeModal(sleepTimerModal);
        }
        
async function loadSongsAndPlaylists() {
    try {
        const songTx = db.transaction('songs', 'readonly');
        const songRequest = songTx.objectStore('songs').getAll();
        const loadedSongs = await new Promise((resolve, reject) => {
            songRequest.onsuccess = () => resolve(songRequest.result);
            songRequest.onerror = () => reject(songRequest.error);
        });
        
        songs = Array.isArray(loadedSongs) ? loadedSongs : [];
        songs.forEach(song => { if (!song.dateAdded) song.dateAdded = song.id; });
        processAndSortSongs();
        updateLocalSongLookup(songs, { clear: true });

        const playlistTx = db.transaction('playlists', 'readonly');
        const playlistRequest = playlistTx.objectStore('playlists').getAll();
        const loadedPlaylists = await new Promise((resolve, reject) => {
            playlistRequest.onsuccess = () => resolve(playlistRequest.result);
            playlistRequest.onerror = () => reject(playlistRequest.error);
        });
        playlists = Array.isArray(loadedPlaylists) ? loadedPlaylists : [];
        
        console.log(`Loaded ${songs.length} songs and ${playlists.length} playlists.`);

    } catch (error) {
        console.error("Failed to load data from IndexedDB:", error);
        songs = []; playlists = [];
    }
}

        async function createPlaylistAndAddSong() {
            const newName = document.getElementById('newPlaylistName').value.trim();
            if (!newName) return;
            if (!currentSongId) return Gurasuraisu.showPopup("Please play a song first.");
        
            const newPlaylist = { name: newName, songIds: [currentSongId] };
            
            try {
                const tx = db.transaction('playlists', 'readwrite');
                const request = tx.objectStore('playlists').add(newPlaylist);
                await new Promise((resolve, reject) => {
                    request.onerror = () => reject(request.error);
                    tx.oncomplete = () => {
                        newPlaylist.id = request.result;
                        resolve();
                    };
                });
        
                playlists.push(newPlaylist);
                document.getElementById('newPlaylistName').value = '';
                closeModal(playlistModal);
                Gurasuraisu.showPopup(`Added song to new playlist "${newName}"`);
            } catch (error) {
                console.error("Failed to create playlist:", error);
            }
        }

        async function addSongToPlaylist(playlistId) {
            const playlist = playlists.find(p => p.id === playlistId);
            if (!playlist || !currentlyPlayingSong) return;
        
            const songToAdd = currentlyPlayingSong;
            
            if (!playlist.songIds.includes(songToAdd.id)) {
                playlist.songIds.push(songToAdd.id);
                
                // If it's a SC song, ensure it's cached so we have its metadata for later
                if (songToAdd.storage === 'soundcloud') {
                    const tx = db.transaction('soundcloudCache', 'readonly');
                    const checkReq = await promiseIDBRequest(tx.objectStore('soundcloudCache').get(songToAdd.id));
                    if (!checkReq) {
                        // If not cached, cache it now.
                        await cacheSoundcloudTrack(songToAdd, songToAdd.streamUrl);
                    }
                }
                
                const writeTx = db.transaction('playlists', 'readwrite');
                writeTx.objectStore('playlists').put(playlist);
                await writeTx.done;
                Gurasuraisu.showPopup(`Added to "${playlist.name}"`);
            } else {
                Gurasuraisu.showPopup(`Song is already in "${playlist.name}"`);
            }
            closeModal(playlistModal);
        }

        Gurasuraisu.onMediaControl({
            playPause: () => playPauseBtn.click(),
            next: () => nextBtn.click(),
            prev: () => prevBtn.click()
        });
    </script>
</body>
</html>
